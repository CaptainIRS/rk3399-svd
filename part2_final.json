[
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "SDMMC_CTRL",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x01000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USE_INTERNAL_DMAC",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Present only for the Internal DMAC configuration; else, it is\nreserved.\n0: The host performs data transfers through the slave interface\n1: Internal DMAC used for data transfe"
          },
          {
            "name": "RESERVED",
            "bit_range": "24:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CEATA_DEVICE_INTERRUPT_STATUS",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Interrupts not enabled in CE-ATA device (nIEN = 1 in ATA\ncontrol register)\n1: Interrupts are enabled in CE-ATA device (nIEN = 0 in ATA\ncontrol register)\nSoftware should appropriately write to this bit after power-on\nreset or any other reset to CE-ATA device. After reset, usually\nCE-ATA device interrupt is disabled (nIEN = 1). If the host\nenables CE-ATA device interrupt, then software should set this\nbit."
          },
          {
            "name": "SEND_AUTO_STOP_CCSD",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Clear bit if Mobile Storage Host Controller does not reset the\nbit.\n1: Send internally generated STOP after sending CCSD to CE-ATA\ndevice.\nNOTE: Always set send_auto_stop_ccsd and send_ccsd bits\ntogether send_auto_stop_ccsd should not be set independent of\nsend_ccsd.\nWhen set, Mobile Storage Host Controller automatically sends\ninternally- generated STOP command (CMD12) to CE-ATA device.\nAfter sending internally-generated STOP command, Auto\nCommand Done (ACD) in RINTSTS is set and generates interrupt\nto host if Auto Command Done interrupt is not masked. After\nsending the CCSD, Mobile Storage Host Controller automatically\nclears send_auto_stop_ccsd bit."
          },
          {
            "name": "SEND_CCSD",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Clear bit if Mobile Storage Host Controller does not reset the\nbit.\n1: Send Command Completion Signal Disable (CCSD) to CE-ATA\ndevice\nWhen set, Mobile Storage Host Controller sends CCSD to CE-ATA\ndevice. Software sets this bit only if current command is\nexpecting CCS (that is, RW_BLK) and interrupts are enabled in\nCE-ATA device. Once the CCSD pattern is sent to device, Mobile\nStorage Host Controller automatically clears send_ccsd bit. It also\nsets Command Done (CD) bit in RINTSTS register and generates\ninterrupt to host if Command Done interrupt is not masked.\nNOTE: Once send_ccsd bit is set, it takes two card clock cycles to\ndrive the CCSD on the CMD line. Due to this, during the boundary\nconditions it may happen that CCSD is sent to the CE-ATA device,\neven if the device signalled CCS"
          },
          {
            "name": "ABORT_READ_DATA",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: no change\n1: after suspend command is issued during read-transfer,\nsoftware polls card to find when suspend happened. Once\nsuspend occurs, software sets bit to reset data state-machine,\nwhich is waiting for next block of data. Bit automatically clears\nonce data state machine resets to idle.\nUsed in SDIO card suspend sequence."
          },
          {
            "name": "SEND_IRQ_RESPONSE",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: no change\n1: send auto IRQ response\nBit automatically clears once response is sent.\nTo wait for MMC card interrupts, host issues CMD40, and SDMMC\nController waits for interrupt response from MMC card(s). In\nmeantime, if host wants SDMMC Controller to exit waiting for\ninterrupt state, it can set this bit, at which time SDMMC\nController command state-machine sends CMD40 response on\nbus and returns to idle state."
          },
          {
            "name": "READ_WAIT",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: clear read wait\n1: assert read wait\nFor sending read-wait to SDIO cards"
          },
          {
            "name": "DMA_ENABLE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: disable DMA transfer mode\n1: enable DMA transfer mode\nEven when DMA mode is enabled, host can still push/pop data\ninto or from FIFO; this should not happen during the normal\noperation. If there is simultaneous FIFO access from host/DMA,\nthe data coherency is lost. Also, there is no arbitration inside\nSDMMC Controller to prioritize simultaneous host/DMA access."
          },
          {
            "name": "INT_ENABLE",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Global interrupt enable/disable bit:\n0: disable interrupts\n1: enable interrupts\nThe int port is 1 only when this bit is 1 and one or more\nunmasked interrupts are set."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DMA_RESET",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: no change\n1: reset internal DMA interface control logic\nTo reset DMA interface, firmware should set bit to 1. This bit is\nauto-cleared after two AHB clocks."
          },
          {
            "name": "FIFO_RESET",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: no change\n1: reset to data FIFO To reset FIFO pointers\nTo reset FIFO, firmware should set bit to 1. This bit is auto-\ncleared after completion of reset operation"
          },
          {
            "name": "CONTROLLER_RESET",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: no change\n1: reset SDMMC controller\nTo reset controller, firmware should set bit to 1. This bit is auto-\ncleared after two AHB and two cclk_in clock cycles.\nThis resets:\na. BIU/CIU interface\nb. CIU and state machines\nc. abort_read_data, send_irq_response, and read_wait bits of\nControl register\nd. start_cmd bit of Command register\nDoes not affect any registers or DMA interface, or FIFO or host\ninterrupts"
          }
        ],
        "description": "Control register"
      },
      {
        "type": "register",
        "name": "SDMMC_PWREN",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "POWER_ENABLE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Power on/off switch for the card.\nOnce power is turned on, firmware should wait for\nregulator/switch ramp-up time before trying to initialize card.\n0: power off\n1: power on\nBit values output to card_power_en port."
          }
        ],
        "description": "Power-enable register"
      },
      {
        "type": "register",
        "name": "SDMMC_CLKDIV",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_DIVIDER0",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Clock divider-0 value. Clock division is 2*n.\nFor example, value of 0 means divide by 2*0 = 0 (no division,\nbypass), value of 1 means divide by 2*1 = 2, value of \"ff\"means\ndivide by 2*255 = 510, and so on"
          }
        ],
        "description": "Clock-divider register"
      },
      {
        "type": "register",
        "name": "SDMMC_CLKSRC",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_SOURCE",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock divider source for up to 16 SD cards supported. Each card\nhas two bits assigned to it. For example, bits[1:0] assigned for\ncard-0, which maps and internally routes clock divider[3:0]\noutputs to cclk_out[15:0] pins, depending on bit value.\n00: Clock divider 0\nThe cclk_out is always from clock divider 0, and this register is\nnot implemented."
          }
        ],
        "description": "SD clock source register"
      },
      {
        "type": "register",
        "name": "SDMMC_CLKENA",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CCLK_LOW_POWER",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Low-power control for SD card clock and MMC card clock\nsupported.\n0: non-low-power mode\n1: low-power mode; stop clock when card in IDLE (should be\nnormally set to only MMC and SD memory cards; for SDIO cards,\nif interrupts must be detected, clock should not be stopped)."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CCLK_ENABLE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock-enable control for SD card clock and MMC card clock\nsupported.\n0: clock disabled\n1: clock enabled"
          }
        ],
        "description": "Clock-enable register"
      },
      {
        "type": "register",
        "name": "SDMMC_TMOUT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0xffffff40",
        "bit_ranges": [
          {
            "name": "DATA_TIMEOUT",
            "bit_range": "31:8",
            "attr": "RW",
            "reset": "0xffffff",
            "description": "Value for card Data Read Timeout; same value also used for Data\nStarvation by Host timeout.\nValue is in number of card output clocks cclk_out of selected\ncard.\nNote: The software timer should be used if the timeout value is in\nthe order of 100 ms. In this case, read data timeout interrupt\nneeds to be disabled."
          },
          {
            "name": "RESPONSE_TIMEOUT",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x40",
            "description": "Response timeout value.\nValue is in number of card output clocks \u2013cclk_out."
          }
        ],
        "description": "Time-out register"
      },
      {
        "type": "register",
        "name": "SDMMC_CTYPE",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARD_WIDTH_8",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Indicates if card is 8-bit:\n0: non 8-bit mode\n1: 8-bit mode"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARD_WIDTH",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Indicates if card is 1-bit or 4-bit:\n0: 1-bit mode\n1: 4-bit mode"
          }
        ],
        "description": "Card-type register"
      },
      {
        "type": "register",
        "name": "SDMMC_BLKSIZ",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000200",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BLOCK_SIZE",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0200",
            "description": "Block size"
          }
        ],
        "description": "Block-size register"
      },
      {
        "type": "register",
        "name": "SDMMC_BYTCNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000200",
        "bit_ranges": [
          {
            "name": "BYTE_COUNT",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000200",
            "description": "Number of bytes to be transferred; should be integer multiple of\nBlock Size for block transfers.\nFor undefined number of byte transfers, byte count should be set\nto 0. When byte count is set to 0, it is responsibility of host to\nexplicitly send stop/abort command to terminate data transfer."
          }
        ],
        "description": "Byte-count register"
      },
      {
        "type": "register",
        "name": "SDMMC_INTMASK",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDIO_INT_MASK",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Mask SDIO interrupts.\nWhen masked, SDIO interrupt detection for that card is disabled.\nA 0 masks an interrupt, and 1 enables an interrupt."
          },
          {
            "name": "RESERVED",
            "bit_range": "23:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_NOBUSY_INT_MASK",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: data no busy interrupt not masked\n1: data no busy interrupt masked"
          },
          {
            "name": "INT_MASK",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Bits used to mask unwanted interrupts. Value of 0 masks\ninterrupt; value of 1 enables interrupt.\n[15]: End-bit error (read)/Write no CRC (EBE)\n[14]: Auto command done (ACD)\n[13]: Start-bit error (SBE)\n[12]: Hardware locked write error (HLE)\n[11]: FIFO underrun/overrun error (FRUN)\n[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int\n[9]: Data read timeout (DRTO)\n[8]: Response timeout (RTO)\n[7]: Data CRC error (DCRC)\n[6]: Response CRC error (RCRC)\n[5]: Receive FIFO data request (RXDR)\n[4]: Transmit FIFO data request (TXDR)\n[3]: Data transfer over (DTO)\n[2]: Command done (CD)\n[1]: Response error (RE)\n[0]: Card detect (CD)"
          }
        ],
        "description": "Interrupt-mask register"
      },
      {
        "type": "register",
        "name": "SDMMC_CMDARG",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CMD_ARG",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Value indicates command argument to be passed to card."
          }
        ],
        "description": "Command-argument register"
      },
      {
        "type": "register",
        "name": "SDMMC_CMD",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "START_CMD",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Start command. Once command is taken by CIU, bit is cleared.\nWhen bit is set, host should not attempt to write to any command\nregisters. If write is attempted, hardware lock error is set in raw\ninterrupt register.\nOnce command is sent and response is received from SD_MMC\ncards, Command Done bit is set in raw interrupt register."
          },
          {
            "name": "RESERVED",
            "bit_range": "30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USE_HOLD_REG",
            "bit_range": "29",
            "attr": "RW",
            "reset": "0x0",
            "description": "Use Hold Register\n0: CMD and DATA sent to card bypassing HOLD Register\n1: CMD and DATA sent to card through the HOLD Register\nNote:\na. Set to 1'b1 for SDR12 and SDR25 (with non-zero phase-shifted\ncclk_in_drv); zero phase shift is not allowed in these modes.\nb. Set to 1'b0 for SDR50, SDR104, and DDR50 (with zero phase-\nshifted cclk_in_drv).\nc. Set to 1'b1 for SDR50, SDR104, and DDR50 (with non-zero\nphase-shifted cclk_in_drv)."
          },
          {
            "name": "VOLT_SWITCH",
            "bit_range": "28",
            "attr": "RW",
            "reset": "0x0",
            "description": "Voltage switch bit.\n0: no voltage switching\n1: voltage switching enabled; must be set for CMD11 only"
          },
          {
            "name": "BOOT_MODE",
            "bit_range": "27",
            "attr": "RW",
            "reset": "0x0",
            "description": "Boot Mode.\n0: mandatory Boot operation\n1: alternate Boot operation"
          },
          {
            "name": "DISABLE_BOOT",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Boot. When software sets this bit along with start_cmd,\nCIU terminates the boot operation. Do NOT set disable_boot and\nenable_boot together."
          },
          {
            "name": "EXPECT_BOOT_ACK",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Expect Boot Acknowledge. When Software sets this bit along with\nenable_boot, CIU expects a boot acknowledge start pattern of 0-\n1-0 from the selected card."
          },
          {
            "name": "ENABLE_BOOT",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Boot\u2014this bit should be set only for mandatory boot\nmode.When Software sets this bit along with start_cmd, CIU\nstarts the boot sequence for the corresponding card by asserting\nthe CMD line low. Do NOT set disable_boot and enable_boot\ntogether."
          },
          {
            "name": "CCS_EXPECTED",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Interrupts are not enabled in CE-ATA device (nIEN = 1 in  ATA\ncontrol register), or command does not expect CCS  from device\n1: Interrupts are enabled in CE-ATA device (nIEN = 0), and\nRW_BLK command expects command completion signal from CE-\nATA device.\nIf the command expects Command Completion Signal (CCS) from\nthe CE-ATA device, the software should set this control bit.\nMobile Storage Host Controller sets Data Transfer Over (DTO) bit\nin RINTSTS register and generates interrupt to host if Data\nTransfer Over interrupt is not masked."
          },
          {
            "name": "READ_CEATA_DEVICE",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Host is not performing read access (RW_REG or RW_BLK)\ntowards CE-ATA device\n1: Host is performing read access (RW_REG or RW_BLK)\ntowards CE-ATA device\nSoftware should set this bit to indicate that CE-ATA device is\nbeing accessed for read transfer. This bit is used to disable read\ndata timeout indication while performing CE-ATA read transfers.\nMaximum value of I/O transmission delay can be no less than 10\nseconds. Mobile Storage Host Controller should not indicate read\ndata timeout while waiting for data from CE-ATA device."
          },
          {
            "name": "UPDATE_CLOCK_REGISTERS_ONLY",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: normal command sequence\n1: do not send commands, just update clock register value into\ncard clock domain\nFollowing register values transferred into card clock domain:\nCLKDIV, CLRSRC, CLKENA.\nChanges card clocks (change frequency, truncate off or on, and\nset low-frequency mode); provided in order to change clock\nfrequency or stop clock without having to send command to\ncards.\nDuring normal command sequence, when\nupdate_clock_registers_only = 0, following control registers are\ntransferred from BIU to CIU:  CMD, CMDARG, TMOUT, CTYPE,\nBLKSIZ, BYTCNT. CIU uses new register values for new command\nsequence to card.\nWhen bit is set, there are no Command Done interrupts because\nno command is sent to SD_MMC_CEATA cards."
          },
          {
            "name": "RESERVED",
            "bit_range": "20:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SEND_INITIALIZATION",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: do not send initialization sequence (80 clocks of 1) before\nsending this command\n1: send initialization sequence before sending this command\nAfter power on, 80 clocks must be sent to card for initialization\nbefore sending any commands to card. Bit should be set while\nsending first command to card so that controller will initialize\nclocks before sending command to card. This bit should not be\nset for either of the boot modes (alternate or mandatory)."
          },
          {
            "name": "STOP_ABORT_CMD",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: neither stop nor abort command to stop current data transfer\nin progress. If abort is sent to function-number currently selected\nor not in data-transfer mode, then bit should be set to 0.\n1: stop or abort command intended to stop current data transfer\nin progress.\nWhen open-ended or predefined data transfer is in progress, and\nhost issues stop or abort command to stop data transfer, bit\nshould be set so that command/data state-machines of CIU can\nreturn correctly to idle state. This is also applicable for Boot mode\ntransfers. To Abort boot mode, this bit should be set along with\nCMD[26] = disable_boot."
          },
          {
            "name": "WAIT_PRVDATA_COMPLETE",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: send command at once, even if previous data transfer has not\ncompleted\n1: wait for previous data transfer completion before sending\ncommand\nThe wait_prvdata_complete = 0 option typically used to query\nstatus of card during data transfer or to stop current data\ntransfer; card_number should be same as in previous command."
          },
          {
            "name": "SEND_AUTO_STOP",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: no stop command sent at end of data transfer\n1: send stop command at end of data transfer\nWhen set, SDMMC Controller sends stop command to SD_MMC\ncards at end of data transfer.\na. when send_auto_stop bit should be set, since some data\ntransfers do not need explicit stop commands\nb. open-ended transfers that software should explicitly send to\nstop command\nAdditionally, when \"resume\" is sent to resume \u2013suspended\nmemory access of SD-Combo card \u2013bit should be set correctly if\nsuspended data transfer needs send_auto_stop.\nDon't care if no data expected from card."
          },
          {
            "name": "TRANSFER_MODE",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: block data transfer command\n1: stream data transfer command\nDon't care if no data expected."
          },
          {
            "name": "WR",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: read from card\n1: write to card\nDon't care if no data expected from card."
          },
          {
            "name": "DATA_EXPECTED",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: no data transfer expected (read/write)\n1: data transfer expected (read/write)"
          },
          {
            "name": "CHECK_RESPONSE_CRC",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: do not check response CRC\n1: check response CRC\nSome of command responses do not return valid CRC bits.\nSoftware should disable CRC checks for those commands in order\nto disable CRC checking by controller"
          },
          {
            "name": "RESPONSE_LENGTH",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: short response expected from card\n1: long response expected from card"
          },
          {
            "name": "RESPONSE_EXPECT",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: no response expected from card\n1: response expected from card"
          },
          {
            "name": "CMD_INDEX",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Command index"
          }
        ],
        "description": "Command register"
      },
      {
        "type": "register",
        "name": "SDMMC_RESP0",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESPONSE0",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Bit[31:0] of response"
          }
        ],
        "description": "Response-0 register"
      },
      {
        "type": "register",
        "name": "SDMMC_RESP1",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESPONSE",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Register represents bit[63:32] of long response.\nWhen CIU sends auto-stop command, then response is saved in\nregister. Response for previous command sent by host is still\npreserved in Response 0 register. Additional auto-stop issued\nonly for data transfer commands, and response type is always\n\"short\" for them."
          }
        ],
        "description": "Response-1 register"
      },
      {
        "type": "register",
        "name": "SDMMC_RESP2",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESPONSE2",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Bit[95:64] of long response"
          }
        ],
        "description": "Response-2 register"
      },
      {
        "type": "register",
        "name": "SDMMC_RESP3",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESPONSE3",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Bit[127:96] of long response"
          }
        ],
        "description": "Response-3 register"
      },
      {
        "type": "register",
        "name": "SDMMC_MINTSTS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDIO_INTERRUPT",
            "bit_range": "24",
            "attr": "RO",
            "reset": "0x0",
            "description": "Interrupt from SDIO card; SDIO interrupt for card enabled only if\ncorresponding sdio_int_mask bit is set in Interrupt mask register\n(mask bit 1 enables interrupt; 0 masks interrupt).\n0: no SDIO interrupt from card\n1: SDIO interrupt from card"
          },
          {
            "name": "RESERVED",
            "bit_range": "23:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_NOBUSY_INT_STATUS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Data no busy Interrupt Status"
          },
          {
            "name": "INT_STATUS",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0000",
            "description": "Interrupt enabled only if corresponding bit in interrupt mask\nregister is set.\n[15]: End-bit error (read)/Write no CRC (EBE)\n[14]: Auto command done (ACD)\n[13]: Start-bit error (SBE)\n[12]: Hardware locked write error (HLE)\n[11]: FIFO underrun/overrun error (FRUN)\n[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int\n[9]: Data read timeout (DRTO)\n[8]: Response timeout (RTO)\n[7]: Data CRC error (DCRC)\n[6]: Response CRC error (RCRC)\n[5]: Receive FIFO data request (RXDR)\n[4]: Transmit FIFO data request (TXDR)\n[3]: Data transfer over (DTO)\n[2]: Command done (CD)\n[1]: Response error (RE)\n[0]: Card detect (CD)"
          }
        ],
        "description": "Masked interrupt-status register"
      },
      {
        "type": "register",
        "name": "SDMMC_RINTSTS",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDIO_INTERRUPT",
            "bit_range": "24",
            "attr": "RO",
            "reset": "0x0",
            "description": "Interrupt from SDIO card; Writes to these bits clear them. Value\nof 1 clears bit and 0 leaves bit intact.\n0: no SDIO interrupt from card\n1: SDIO interrupt from card"
          },
          {
            "name": "RESERVED",
            "bit_range": "23:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_NOBUSY_INT_STATUS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Data no busy interrupt status"
          },
          {
            "name": "INT_STATUS",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0000",
            "description": "Writes to bits clear status bit. Value of 1 clears status bit, and\nvalue of 0 leaves bit intact. Bits are logged regardless of interrupt\nmask status.\n[15]: End-bit error (read)/Write no CRC (EBE)\n[14]: Auto command done (ACD)\n[13]: Start-bit error (SBE)\n[12]: Hardware locked write error (HLE)\n[11]: FIFO underrun/overrun error (FRUN)\n[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int\n[9]: Data read timeout (DRTO)\n[8]: Response timeout (RTO)\n[7]: Data CRC error (DCRC)\n[6]: Response CRC error (RCRC)\n[5]: Receive FIFO data request (RXDR)\n[4]: Transmit FIFO data request (TXDR)\n[3]: Data transfer over (DTO)\n[2]: Command done (CD)\n[1]: Response error (RE)\n[0]: Card detect (CD)"
          }
        ],
        "description": "Raw interrupt-status register"
      },
      {
        "type": "register",
        "name": "SDMMC_STATUS",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00000406",
        "bit_ranges": [
          {
            "name": "DMA_REQ",
            "bit_range": "31",
            "attr": "RO",
            "reset": "0x0",
            "description": "DMA request signal state"
          },
          {
            "name": "DMA_ACK",
            "bit_range": "30",
            "attr": "RO",
            "reset": "0x0",
            "description": "DMA acknowledge signal state"
          },
          {
            "name": "FIFO_COUNT",
            "bit_range": "29:17",
            "attr": "RO",
            "reset": "0x0000",
            "description": "Number of filled locations in FIFO"
          },
          {
            "name": "RESPONSE_INDEX",
            "bit_range": "16:11",
            "attr": "RO",
            "reset": "0x00",
            "description": "Index of previous response, including any auto-stop sent by core"
          },
          {
            "name": "DATA_STATE_MC_BUSY",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x1",
            "description": "Data transmit or receive state-machine is busy"
          },
          {
            "name": "DATA_BUSY",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "Inverted version of raw selected card_data[0]\n0: card data not busy\n1: card data busy\ndefault value is 1 or 0 depending on cdata_in"
          },
          {
            "name": "DATA_3_STATUS",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "Raw selected card_data[3]; checks whether card is present\n0: card not present\n1: card present\ndefault value is 1 or 0 depending on cdata_in"
          },
          {
            "name": "COMMAND_FSM_STATES",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Command FSM states:\n0: idle\n1: send init sequence\n2: Tx cmd start bit\n3: Tx cmd tx bit\n4: Tx cmd index + arg\n5: Tx cmd crc7\n6: Tx cmd end bit\n7: Rx resp start bit\n8: Rx resp IRQ response\n9: Rx resp tx bit\n10: Rx resp cmd idx\n11: Rx resp data\n12: Rx resp crc7\n13: Rx resp end bit\n14: Cmd path wait NCC\n15: Wait; CMD-to-response turnaround\nThe command FSM state is represented using 19 bits.\nThe STATUS Register[7:4] has 4 bits to represent the command\nFSM states. Using these 4 bits, only 16 states can be\nrepresented. Thus three states cannot be represented in the\nSTATUS[7:4] register. The three states that are not represented\nin the STATUS Register[7:4] are:\na. Bit 16 \u2013Wait for CCS\nb. Bit 17 \u2013Send CCSD\nc. Bit 18 \u2013Boot Mode\nDue to this, while command FSM is in \"Wait for CCS state\" or\n\"Send CCSD\" or \"Boot Mode\", the Status register indicates status\nas 0 for the bit field [7:4]."
          },
          {
            "name": "FIFO_FULL",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "FIFO is full status"
          },
          {
            "name": "FIFO_EMPTY",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x1",
            "description": "FIFO is empty status"
          },
          {
            "name": "FIFO_TX_WATERMARK",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x1",
            "description": "FIFO reached Transmit watermark level; not qualified with data\ntransfer"
          },
          {
            "name": "FIFO_RX_WATERMARK",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "FIFO reached Receive watermark level; not qualified with data\ntransfer"
          }
        ],
        "description": "Status register"
      },
      {
        "type": "register",
        "name": "SDMMC_FIFOTH",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DMA_MUTIPLE_TRANSACTION_SIZE",
            "bit_range": "30:28",
            "attr": "RW",
            "reset": "0x0",
            "description": "Burst size of multiple transaction; should be programmed same\nas DMA controller multiple-transaction-size SRC/DEST_MSIZE.\n0: 1 transfers\n1: 4\n2: 8\n3: 16\n4: 32\n5: 64\n6: 128\n7: 256\nThe unit for transfer is the H_DATA_WIDTH parameter. A single\ntransfer (dw_dma_single assertion in case of Non DW DMA\ninterface) would be signalled based on this value.\nValue should be sub-multiple of (RX_WMark + 1)*\n(F_DATA_WIDTH/H_DATA_WIDTH) and (FIFO_DEPTH -\nTX_WMark)* (F_DATA_WIDTH/ H_DATA_WIDTH)\nFor example, if FIFO_DEPTH = 16, FDATA_WIDTH ==\nH_DATA_WIDTH\nAllowed combinations for MSize and TX_WMark are:\nMSize = 1, TX_WMARK = 1-15\nMSize = 4, TX_WMark = 8\nMSize = 4, TX_WMark = 4\nMSize = 4, TX_WMark = 12\nMSize = 8, TX_WMark = 8\nMSize = 8, TX_WMark = 4\nAllowed combinations for MSize and RX_WMark are:\nMSize = 1, RX_WMARK = 0-14\nMSize = 4, RX_WMark = 3\nMSize = 4, RX_WMark = 7\nMSize = 4, RX_WMark = 11\nMSize = 8, RX_WMark = 7\nRecommended:\nMSize = 8, TX_WMark = 8, RX_WMark = 7"
          },
          {
            "name": "RX_WMARK",
            "bit_range": "27:16",
            "attr": "RW",
            "reset": "0x000",
            "description": "FIFO threshold watermark level when receiving data to card.\nWhen FIFO data count reaches greater than this number,\nDMA/FIFO request is raised. During end of packet, request is\ngenerated regardless of threshold programming in order to\ncomplete any remaining data.\nIn non-DMA mode, when receiver FIFO threshold (RXDR)\ninterrupt is enabled, then interrupt is generated instead of DMA\nrequest. During end of packet, interrupt is not generated if\nthreshold programming is larger than any remaining data. It is\nresponsibility of host to read remaining bytes on seeing Data\nTransfer Done interrupt.\nIn DMA mode, at end of packet, even if remaining bytes are less\nthan threshold, DMA request does single transfers to flush out\nany remaining bytes before Data Transfer Done interrupt is set.\n12 bits-1 bit less than FIFO-count of status register, which is 13\nbits.\nLimitation: RX_WMark <= FIFO_DEPTH-2\nRecommended: (FIFO_DEPTH/2) - 1; (means greater than\n(FIFO_DEPTH/2) - 1)\nNOTE: In DMA mode during CCS time-out, the DMA does not generate the\nrequest at the end of packet, even if remaining bytes are less than\nthreshold. In this case, there will be some data left in the FIFO. It is the\nresponsibility of the application to reset the FIFO after the CCS timeout."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TX_WMARK",
            "bit_range": "11:0",
            "attr": "RW",
            "reset": "0x000",
            "description": "FIFO threshold watermark level when transmitting data to card.\nWhen FIFO data count is less than or equal to this number,\nDMA/FIFO request is raised. If Interrupt is enabled, then interrupt\noccurs. During end of packet, request or interrupt is generated,\nregardless of threshold programming.\nIn non-DMA mode, when transmit FIFO threshold (TXDR)\ninterrupt is enabled, then interrupt is generated instead of DMA\nrequest. During end of packet, on last interrupt, host is\nresponsible for filling FIFO with only required remaining bytes\n(not before FIFO is full or after CIU completes data transfers,\nbecause FIFO may not be empty).\nIn DMA mode, at end of packet, if last transfer is less than burst\nsize, DMA controller does single cycles until required bytes are\ntransferred.\n12 bits -1 bit less than FIFO-count of status register, which is 13\nbits.\nLimitation: TX_WMark >= 1;\nRecommended: FIFO_DEPTH/2; (means less than or equal to\nFIFO_DEPTH/2)"
          }
        ],
        "description": "FIFO threshold register"
      },
      {
        "type": "register",
        "name": "SDMMC_CDETECT",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARD_DETECT_N",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Value on card_detect_n input ports; read-only bits. 0 represents\npresence of card."
          }
        ],
        "description": "Card-detect register"
      },
      {
        "type": "register",
        "name": "SDMMC_WRTPRT",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WRITE_PROTECT",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Value on card_write_prt input port. 1 represents write protection."
          }
        ],
        "description": "Write-protect register"
      },
      {
        "type": "register",
        "name": "SDMMC_TCBCNT",
        "offset": "0x005c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TRANS_CARD_BYTE_COUNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Number of bytes transferred by CIU unit to card.\nIn 32-bit or 64-bit AMBA data-bus-width modes, register should\nbe accessed in full to avoid read-coherency problems. In 16-bit\nAMBA data-bus-width mode, internal 16-bit coherency register is\nimplemented. User should first read lower 16 bits and then higher\n16 bits. When reading lower 16 bits, higher 16 bits of counter are\nstored in temporary register. When higher 16 bits are read, data\nfrom temporary register is supplied.\nBoth TCBCNT and TBBCNT share same coherency register.\nWhen AREA_OPTIMIZED parameter is 1, register should be read\nonly after data transfer completes; during data transfer, register\nreturns 0."
          }
        ],
        "description": "Transferred CIU card byte count"
      },
      {
        "type": "register",
        "name": "SDMMC_TBBCNT",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TRANS_FIFO_BYTE_COUNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Number of bytes transferred between Host/DMA memory and BIU\nFIFO.\nIn 32-bit or 64-bit AMBA data-bus-width modes, register should\nbe accessed in full to avoid read-coherency problems. In 16-bit\nAMBA data-bus-width mode, internal 16-bit coherency register is\nimplemented. User should first read lower 16 bits and then higher\n16 bits. When reading lower 16 bits, higher 16 bits of counter are\nstored in temporary register. When higher 16 bits are read, data\nfrom temporary register is supplied.\nBoth TCBCNT and TBBCNT share same coherency register."
          }
        ],
        "description": "Transferred host/DMA to/from BIU-FIFO byte count"
      },
      {
        "type": "register",
        "name": "SDMMC_DEBNCE",
        "offset": "0x0064",
        "size": "W",
        "reset": "0x00ffffff",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DEBOUNCE_COUNT",
            "bit_range": "23:0",
            "attr": "RW",
            "reset": "0xffffff",
            "description": "Number of host clocks (clk) used by debounce filter logic; typical\ndebounce time is 5-25 ms."
          }
        ],
        "description": "Card detect debounce register"
      },
      {
        "type": "register",
        "name": "SDMMC_USRID",
        "offset": "0x0068",
        "size": "W",
        "reset": "0x07967797",
        "bit_ranges": [
          {
            "name": "USRID",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x07967797",
            "description": "User identification register.\nThe default value is determined by Configuration Value."
          }
        ],
        "description": "User ID register"
      },
      {
        "type": "register",
        "name": "SDMMC_VERID",
        "offset": "0x006c",
        "size": "W",
        "reset": "0x5342270a",
        "bit_ranges": [
          {
            "name": "VERID",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x5342270a",
            "description": "Version identification register; register value is hard-wired. Can\nbe read by firmware to support different versions of core."
          }
        ],
        "description": "Version ID register"
      },
      {
        "type": "register",
        "name": "SDMMC_HCON",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HCON",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Configuration Dependent.\nHardware configurations selected by user before synthesizing\ncore. Register values can be used to develop configuration-\nindependent software drivers.\n[0]: CARD_TYPE\n0: MMC_ONLY\n1: SD_MMC\n[5:1]: NUM_CARDS - 1\n[6]: H_BUS_TYPE\n0: APB\n1: AHB\n[9:7]: H_DATA_WIDTH\n0: 16 bits\n1: 32 bits\n2: 64 bits\nothers: reserved\n[15:10]: H_ADDR_WIDTH\n0 to 7:  reserved\n8:  9 bits\n9: 10 bits\n...\n31: 32 bits\n32 to 63: reserved\n[17:16]: DMA_INTERFACE\n0: none\n1: DMA 1\n2: DMA 2\n3: DMA 3\n[20:18]: GE_DMA_DATA_WIDTH\n0: 16 bits\n1: 32 bits\n2: 64 bits\nothers: reserved\n[21]: FIFO_RAM_INSIDE\n0: outside\n1: inside\n[22]: IMPLEMENT_HOLD_REG\n0: no hold register\n1: hold register\n[23]: SET_CLK_FALSE_PATH\n0: no false path\n1: false path set\n[25:24]: NUM_CLK_DIVIDER-1\n[26]: AREA_OPTIMIZED\n0: no area optimization\n1: Area optimization"
          }
        ],
        "description": "Hardware configuration register"
      },
      {
        "type": "register",
        "name": "SDMMC_UHS_REG",
        "offset": "0x0074",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DDR_REG",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "DDR mode. Determines the voltage fed to the buffers by an\nexternal voltage regulator.\n0: non-DDR mode\n1: DDR mode\nUHS_REG [16] should be set for card."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "UHS-1 register"
      },
      {
        "type": "register",
        "name": "SDMMC_RST_n",
        "offset": "0x0078",
        "size": "W",
        "reset": "0x00000001",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARD_RESET",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x1",
            "description": "Hardware reset.\n0: active mode\n1: reset\nThese bits cause the cards to enter pre-idle state, which requires\nthem to be re-initialized. CARD_RESET[0] should be set to 1'b1\nto reset card."
          }
        ],
        "description": "Hardware reset register"
      },
      {
        "type": "register",
        "name": "SDMMC_BMOD",
        "offset": "0x0080",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PBL",
            "bit_range": "10:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "Programmable Burst Length. These bits indicate the maximum\nnumber of beats to be performed in one IDMAC transaction. The\nIDMAC will always attempt to burst as specified in PBL each time\nit starts a Burst transfer on the host bus. The permissible values\nare 1, 4, 8, 16, 32, 64, 128 and 256. This value is the mirror of\nMSIZE of FIFOTH register. In order to change this value, write\nthe required value to FIFOTH register. This is an encode value as\nfollows.\n0: 1 transfers\n1: 4 transfers\n2: 8 transfers\n3: 16 transfers\n4: 32 transfers\n5: 64 transfers\n6: 128 transfers\n7: 256 transfers\nTransfer unit is either 16, 32, or 64 bits, based on\nHDATA_WIDTH.\nPBL is a read-only value and is applicable only for Data Access; it\ndoes not apply to descriptor accesses."
          },
          {
            "name": "DE",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "IDMAC Enable. When set, the IDMAC is enabled."
          },
          {
            "name": "DSL",
            "bit_range": "6:2",
            "attr": "RW",
            "reset": "0x00",
            "description": "Descriptor Skip Length. Specifies the number of\nHWord/Word/Dword (depending on 16/32/64-bit bus) to skip\nbetween two unchained descriptors. This is applicable only for\ndual buffer structure."
          },
          {
            "name": "FB",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Fixed Burst. Controls whether the AHB Master interface performs\nfixed burst transfers or not. When set, the AHB will use only\nSINGLE, INCR4, INCR8 or INCR16 during start of normal burst\ntransfers. When reset, the AHB will use SINGLE and INCR burst\ntransfer operations."
          },
          {
            "name": "SWR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Software Reset. When set, the DMA Controller resets all its\ninternal registers.\nIt is automatically cleared after 1 clock cycle."
          }
        ],
        "description": "Bus mode register"
      },
      {
        "type": "register",
        "name": "SDMMC_PLDMND",
        "offset": "0x0084",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PD",
            "bit_range": "31:0",
            "attr": "WO",
            "reset": "0x00000000",
            "description": "Poll Demand. If the OWN bit of a descriptor is not set, the FSM\ngoes to the Suspend state. The host needs to write any value into\nthis register for the IDMAC FSM to resume normal descriptor\nfetch operation. This is a write only register."
          }
        ],
        "description": "Poll demand register"
      },
      {
        "type": "register",
        "name": "SDMMC_DBADDR",
        "offset": "0x0088",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "SDL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Start of Descriptor List. Contains the base address of the First\nDescriptor.\nThe LSB bits [0/1/2:0] for 16/32/64-bit bus-width) are ignored\nand taken as all-zero by the IDMAC internally. Hence these LSB\nbits are read-only."
          }
        ],
        "description": "Descriptor list base address register"
      },
      {
        "type": "register",
        "name": "SDMMC_IDSTS",
        "offset": "0x008c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FSM",
            "bit_range": "16:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "DMAC FSM present state.\n0: DMA_IDLE\n1: DMA_SUSPEND\n2: DESC_RD\n3: DESC_CHK\n4: DMA_RD_REQ_WAI\n5: DMA_WR_REQ_WAI\n6: DMA_RD\n7: DMA_WR\n8: DESC_CLOSE"
          },
          {
            "name": "EB",
            "bit_range": "12:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "Error Bits. Indicates the type of error that caused a Bus Error.\nValid only with atal Bus\nError bit\u2014IDSTS[2] (IDSTS64[2], in case of 64-bit address\nconfiguration) set. This field does not generate an interrupt.\n1: Host Abort received during transmission\n2: Host Abort received during reception\nOthers: Reserved"
          },
          {
            "name": "AIS",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Abnormal Interrupt Summary. Logical OR of the following:\nIDSTS[2] Fatal Bus Interrupt\nIDSTS[4] DU bit Interrupt\nOnly unmasked bits affect this bit.\nThis is a sticky bit and must be cleared each time a\ncorresponding bit that causes AIS to be set is cleared. Writing a 1\nclears this bit."
          },
          {
            "name": "NIS",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Normal Interrupt Summary. Logical OR of the following:\nIDSTS[0] Transmit Interrupt\nIDSTS[1] Receive Interrupt\nOnly unmasked bits affect this bit.\nThis is a sticky bit and must be cleared each time a\ncorresponding bit that causes NIS to be set is cleared. Writing a 1\nclears this bit."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CES",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Card Error Summary. Indicates the status of the transaction\nto/from the card; also present in RINTSTS. Indicates the logical\nOR of the following bits:\nEBE: End Bit Error\nRTO: Response Timeout/Boot Ack Timeout\nRCRC: Response CRC\nSBE: Start Bit Error\nDRTO: Data Read Timeout/BDS timeout\nDCRC: Data CRC for Receive\nRE: Response Error\nWriting a 1 clears this bit.\nThe abort condition of the IDMAC depends on the setting of this\nCES bit. If the CES bit is enabled, then the IDMAC aborts on a\n\"response error\"; however, it will not abort if the CES bit is\ncleared."
          },
          {
            "name": "DU",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Descriptor Unavailable Interrupt. This bit is set when the\ndescriptor is unavailable due to OWN bit = 0 (DES0[31] =0).\nWriting a 1 clears this bit."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FBE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Fatal Bus Error Interrupt. Indicates that a Bus Error occurred\n(IDSTS[12:10]) (IDSTS64[12:10], in case of 64-bit address\nconfiguration). When this bit is set, the DMA disables all its bus\naccesses. Writing a 1 clears this bit."
          },
          {
            "name": "RI",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Interrupt. Indicates the completion of data reception for\na descriptor. Writing a 1 clears this bit."
          },
          {
            "name": "TI",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Interrupt. Indicates that data transmission is finished\nfor a descriptor. Writing 1 clears this bit."
          }
        ],
        "description": "Internal DMAC status register"
      },
      {
        "type": "register",
        "name": "SDMMC_IDINTEN",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "AI",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Abnormal Interrupt Summary Enable. When set, an abnormal\ninterrupt is enabled.\nThis bit enables the following bits:\nIDINTEN[ 2] Fatal Bus Error Interrupt\nIDINTEN[4] DU Interrupt"
          },
          {
            "name": "NI",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Normal Interrupt Summary Enable. When set, a normal interrupt\nis enabled. When reset, a normal interrupt is disabled. This bit\nenables the following bits:\nIDINTEN[0] Transmit Interrupt\nIDINTEN[1] Receive Interrupt"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CES",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Card Error summary Interrupt Enable. When set, it enables the\nCard Interrupt summary."
          },
          {
            "name": "DU",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Descriptor Unavailable Interrupt. When set along with Abnormal\nInterrupt Summary Enable, the DU interrupt is enabled."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FBE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Fatal Bus Error Enable. When set with Abnormal Interrupt\nSummary Enable, the Fatal Bus Error Interrupt is enabled. When\nreset, Fatal Bus Error Enable Interrupt is disabled."
          },
          {
            "name": "RI",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Interrupt Enable. When set with Normal Interrupt\nSummary Enable, Receive Interrupt is enabled. When reset,\nReceive Interrupt is disabled."
          },
          {
            "name": "TI",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Interrupt Enable. When set with Normal Interrupt\nSummary Enable, Transmit Interrupt is enabled. When reset,\nTransmit Interrupt is disabled."
          }
        ],
        "description": "Internal DMAC interrupt enable register"
      },
      {
        "type": "register",
        "name": "SDMMC_DSCADDR",
        "offset": "0x0094",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HDA",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Host Descriptor Address Pointer. Cleared on reset. Pointer\nupdated by IDMAC during operation. This register points to the\nstart address of the current descriptor read by the IDMAC."
          }
        ],
        "description": "Current host descriptor address register"
      },
      {
        "type": "register",
        "name": "SDMMC_BUFADDR",
        "offset": "0x0098",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HBA",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Host Buffer Address Pointer. Cleared on Reset. Pointer updated\nby IDMAC during operation. This register points to the current\nData Buffer Address being accessed by the IDMAC."
          }
        ],
        "description": "Current buffer descriptor address register"
      },
      {
        "type": "register",
        "name": "SDMMC_CARDTHRCTL",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:28",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARDRDTHRESHOLD",
            "bit_range": "27:16",
            "attr": "RW",
            "reset": "0x000",
            "description": "Card Read Threshold size"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BSYCLRINTEN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Busy Clear Interrupt generation:\n0: Busy Clear Interrupt disabled\n1: Busy Clear Interrupt enabled\nNote: The application can disable this feature if it does not want\nto wait for a Busy Clear Interrupt. For example, in a multi-card\nscenario, the application can switch to the other card without\nwaiting for a busy to be completed. In such cases, the application\ncan use the polling method to determine the status of busy. By\ndefault this feature is disabled and backward-compatible to the\nlegacy drivers where polling is used."
          },
          {
            "name": "CARDRDTHREN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Card Read Threshold Enable.\n0: Card Read Threshold disabled\n1: Card Read Threshold enabled. Host Controller initiates Read\nTransfer only if CardRdThreshold amount of space is available in\nreceive FIFO."
          }
        ],
        "description": "Card read threshold enable register"
      },
      {
        "type": "register",
        "name": "SDMMC_BACK_END_POWER",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BACK_END_POWER",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Back end power\n0: Off; Reset\n1: Back-end Power supplied to card application"
          }
        ],
        "description": "Back-end power register"
      },
      {
        "type": "register",
        "name": "SDMMC_EMMC_DDR_REG",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HALF_START_BIT",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Control for start bit detection mechanism inside Mobile Storage\nHost Controller based on duration of start bit; each bit refers to\none slot. For eMMC 4.5, start bit can be:\n0: Full cycle (HALF_START_BIT = 0)\n1: Less than one full cycle (HALF_START_BIT = 1)\nSet HALF_START_BIT=1 for eMMC 4.5 and above; set to 0 for SD\napplications."
          }
        ],
        "description": "eMMC4.5 DDR start bit detection control register"
      },
      {
        "type": "register",
        "name": "SDMMC_FIFO_BASE",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "FIFO_BASE_ADDR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "FIFO base address"
          }
        ],
        "description": "FIFO base address register"
      }
    ],
    "name": "SDMMC",
    "summary": [
      {
        "name": "SDMMC_CTRL",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x01000000",
        "description": "Control register"
      },
      {
        "name": "SDMMC_PWREN",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Power-enable register"
      },
      {
        "name": "SDMMC_CLKDIV",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "Clock-divider register"
      },
      {
        "name": "SDMMC_CLKSRC",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "SD clock source register"
      },
      {
        "name": "SDMMC_CLKENA",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Clock-enable register"
      },
      {
        "name": "SDMMC_TMOUT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0xffffff40",
        "description": "Time-out register"
      },
      {
        "name": "SDMMC_CTYPE",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Card-type register"
      },
      {
        "name": "SDMMC_BLKSIZ",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000200",
        "description": "Block-size register"
      },
      {
        "name": "SDMMC_BYTCNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000200",
        "description": "Byte-count register"
      },
      {
        "name": "SDMMC_INTMASK",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt-mask register"
      },
      {
        "name": "SDMMC_CMDARG",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command-argument register"
      },
      {
        "name": "SDMMC_CMD",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command register"
      },
      {
        "name": "SDMMC_RESP0",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response-0 register"
      },
      {
        "name": "SDMMC_RESP1",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response-1 register"
      },
      {
        "name": "SDMMC_RESP2",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response-2 register"
      },
      {
        "name": "SDMMC_RESP3",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response-3 register"
      },
      {
        "name": "SDMMC_MINTSTS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "description": "Masked interrupt-status register"
      },
      {
        "name": "SDMMC_RINTSTS",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "description": "Raw interrupt-status register"
      },
      {
        "name": "SDMMC_STATUS",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00000406",
        "description": "Status register"
      },
      {
        "name": "SDMMC_FIFOTH",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO threshold register"
      },
      {
        "name": "SDMMC_CDETECT",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "description": "Card-detect register"
      },
      {
        "name": "SDMMC_WRTPRT",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "description": "Write-protect register"
      },
      {
        "name": "SDMMC_TCBCNT",
        "offset": "0x005c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transferred CIU card byte count"
      },
      {
        "name": "SDMMC_TBBCNT",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transferred host/DMA to/from BIU-FIFO byte count"
      },
      {
        "name": "SDMMC_DEBNCE",
        "offset": "0x0064",
        "size": "W",
        "reset": "0x00ffffff",
        "description": "Card detect debounce register"
      },
      {
        "name": "SDMMC_USRID",
        "offset": "0x0068",
        "size": "W",
        "reset": "0x07967797",
        "description": "User ID register"
      },
      {
        "name": "SDMMC_VERID",
        "offset": "0x006c",
        "size": "W",
        "reset": "0x5342270a",
        "description": "Version ID register"
      },
      {
        "name": "SDMMC_HCON",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "description": "Hardware configuration register"
      },
      {
        "name": "SDMMC_UHS_REG",
        "offset": "0x0074",
        "size": "W",
        "reset": "0x00000000",
        "description": "UHS-1 register"
      },
      {
        "name": "SDMMC_RST_n",
        "offset": "0x0078",
        "size": "W",
        "reset": "0x00000001",
        "description": "Hardware reset register"
      },
      {
        "name": "SDMMC_BMOD",
        "offset": "0x0080",
        "size": "W",
        "reset": "0x00000000",
        "description": "Bus mode register"
      },
      {
        "name": "SDMMC_PLDMND",
        "offset": "0x0084",
        "size": "W",
        "reset": "0x00000000",
        "description": "Poll demand register"
      },
      {
        "name": "SDMMC_DBADDR",
        "offset": "0x0088",
        "size": "W",
        "reset": "0x00000000",
        "description": "Descriptor list base address register"
      },
      {
        "name": "SDMMC_IDSTS",
        "offset": "0x008c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Internal DMAC status register"
      },
      {
        "name": "SDMMC_IDINTEN",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "description": "Internal DMAC interrupt enable register"
      },
      {
        "name": "SDMMC_DSCADDR",
        "offset": "0x0094",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current host descriptor address register"
      },
      {
        "name": "SDMMC_BUFADDR",
        "offset": "0x0098",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current buffer descriptor address register"
      },
      {
        "name": "SDMMC_CARDTHRCTL",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "description": "Card read threshold enable register"
      },
      {
        "name": "SDMMC_BACK_END_POWER",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "description": "Back-end power register"
      },
      {
        "name": "SDMMC_EMMC_DDR_REG",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "description": "eMMC4.5 DDR start bit detection control register"
      },
      {
        "name": "SDMMC_FIFO_BASE",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO base address register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "USB3_GSBUSCFG0",
        "offset": "0xc100",
        "size": "W",
        "reset": "0x00000001",
        "bit_ranges": [
          {
            "name": "DATRDREQINFO",
            "bit_range": "31:28",
            "attr": "RW",
            "reset": "0x0",
            "description": "DATRDREQINFO\nAXI-cache for Data Read (DatRdReqInfo)"
          },
          {
            "name": "DESRDREQINFO",
            "bit_range": "27:24",
            "attr": "RW",
            "reset": "0x0",
            "description": "DESRDREQINFO\nAXI-cache for Descriptor Read (DesRdReqInfo)."
          },
          {
            "name": "DATWRREQINFO",
            "bit_range": "23:20",
            "attr": "RW",
            "reset": "0x0",
            "description": "DATWRREQINFO\nAXI-cache for Data Write (DatWrReqInfo)."
          },
          {
            "name": "DESWRREQINFO",
            "bit_range": "19:16",
            "attr": "RW",
            "reset": "0x0",
            "description": "DESWRREQINFO\nAXI-cache for Descriptor Write (DesWrReqInfo)"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATBIGEND",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Data Access is Big Endian\nThis bit controls the endian mode for data accesses.0, Little-\nendian (default); 1, Big-endian;"
          },
          {
            "name": "DESBIGEND",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Descriptor Access is Big Endian\nThis bit controls the endian mode for descriptor accesses. 0,\nLittle-endian (default); 1, Big-endian."
          },
          {
            "name": "RESERVED",
            "bit_range": "9:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INCR256BRSTENA",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR256 Burst Type Enable\nIf software set this bit to 1, the AXI master uses INCR to do the\n256-beat burst."
          },
          {
            "name": "INCR128BRSTENA",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR128 Burst Type Enable\nIf software set this bit to 1, the AXI master uses INCR to do the\n128-beat burst."
          },
          {
            "name": "INCR64BRSTENA",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR64 Burst Type Enable\nIf software set this bit to 1, AXI master uses INCR to do the 64-\nbeat burst."
          },
          {
            "name": "INCR32BRSTENA",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR32 Burst Type Enable\nIf software set this bit to 1, the AXI master uses INCR to do the\n32-beat burst."
          },
          {
            "name": "INCR16BRSTENA",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR16 Burst Type Enable\nIf software set this bit to 1, the AXI master uses INCR to do the\n16-beat burst."
          },
          {
            "name": "INCR8BRSTENA",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR8 Burst Type Enable\nIf software set this bit to 1, the AXI master uses INCR to do the\n8-beat burst."
          },
          {
            "name": "INCR4BRSTENA",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "INCR4 Burst Type Enable\nWhen this bit is enabled the controller is allowed to do bursts of\nbeat length 1, 2, 3, and 4. It is highly recommended that this bit\nis enabled to prevent descriptor reads and writes from being\nbroken up into separate transfers."
          },
          {
            "name": "INCRBRSTENA",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x1",
            "description": "Undefined Length INCR Burst Type Enable\nThis bit determines the set of burst lengths the master interface\nuses. It works in conjunction with the\nGSBUSCFG0[7:1] enables (INCR256/128/64/32/16/8/4).\n0: INCRX burst mode\nARLEN/AWLEN do not use INCR. They use only the following\nburst lengths:\n1;\n4 (if GSBUSCFG0.INCR4BrstEna = 1);\n8 (if GSBUSCFG0.INCR8BrstEna = 1);\n16 (if GSBUSCFG0.INCR16BrstEna = 1);\n32 (if GSBUSCFG0.INCR32BrstEna = 1);\n64 (if GSBUSCFG0.INCR64BrstEna = 1);\n128 (if GSBUSCFG0.INCR128BrstEna = 1);\n256 (if GSBUSCFG0.INCR256BrstEna = 1);\n1: INCR (undefined length) burst mode\nARLEN/AWLEN uses any length less than or equal to the largest-\nenabled burst length of INCR4/8/16/32/64/128/256.\nFor cache line-aligned applications, this bit is typically set to 0 to\nensure that the master interface uses only power-of-2 burst\nlengths (as enabled via GSBUSCFG0[7:0])."
          }
        ],
        "description": "Global SoC Bus Configuration Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GSBUSCFG1",
        "offset": "0xc104",
        "size": "W",
        "reset": "0x00000300",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "EN1KPAGE",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "1K Page Boundary Enable\nBy default (this bit is disabled) the AXI breaks transfers at the 4k\npage boundary. When this bit is enabled, the AXI master (DMA\ndata) breaks transfers at the 1k page boundary."
          },
          {
            "name": "PIPETRANSLIMIT",
            "bit_range": "11:8",
            "attr": "RW",
            "reset": "0x3",
            "description": "AXI Pipelined Transfers Burst Request Limit\nThe field controls the number of outstanding pipelined transfer\nrequests the AXI master pushes to the AXI slave. When the AXI\nmaster reaches this limit, it does not make any more requests on\nthe AXI ARADDR and AWADDR buses until the associated data\nphases complete.\nThis field is encoded as follows:\n0: 1 request\n1: 2 requests\n2: 3 requests\n3: 4 requests\n...\nF: 16 requests"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Global SoC Bus Configuration Register 1"
      },
      {
        "type": "register",
        "name": "USB3_GTXTHRCFG",
        "offset": "0xc108",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USBTXPKTCNTSEL",
            "bit_range": "29",
            "attr": "RO",
            "reset": "0x0",
            "description": "USB Transmit Packet Count Enable\nThis field enables/disables the USB transmission multi-packet\nthresholding:\n0: USB transmission multi-packet thresholding is disabled; the\ncore can only start transmission on the USB after the entire\npacket has been fetched into the corresponding TXFIFO.\n1: USB transmission multi-packet thresholding is enabled. The\ncore can only start transmission on the USB after USB Transmit\nPacket Count amount of packets for the USB transaction (burst)\nare already in the corresponding TXFIFO. This mode is only valid\nin the host mode. It is only used for SuperSpeed."
          },
          {
            "name": "RESERVED",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USBTXPKTCNT",
            "bit_range": "27:24",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB Transmit Packet Count\nThis field specifies the number of packets that must be in the\nTXFIFO before the core can start transmission for the\ncorresponding USB transaction (burst). This field is only valid\nwhen the USB Transmit Packet Count Enable field is set to one.\nValid values are from 1 to 15.\nNote: This field must be less than or equal to the USB Maximum\nTX Burst Size field."
          },
          {
            "name": "USBMAXTXBURSTSIZE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "USB Maximum TX Burst Size\nWhen USBTxPktCntSel is 1, this field specifies the Maximum Bulk\nOUT burst the core can execute. When the system bus is slower\nthan the USB, TX FIFO can underrun during a long burst.\nYou can program a smaller value to this field to limit the TX burst\nsize that the core can execute.\nIt only applies to SS Bulk, Isochronous, and Interrupt OUT\nendpoints in the host mode. Valid values are from 1 to 16."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Global Tx Threshold Control Register"
      },
      {
        "type": "register",
        "name": "USB3_GRXTHRCFG",
        "offset": "0xc10c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USBRXPKTCNTSEL",
            "bit_range": "29",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB ReceivePacket Count Enable\nThis field enables/disables the USB reception multi-packet\nthresholding:\n0: The core can only start reception on the USB when the RX\nFIFO has space for at least one packet.\n1: The core can only start reception on the USB when the RX\nFIFO has space for at least USBRxPktCnt amount of packets.\nThis mode is valid in both host and device mode. It is only used\nfor SuperSpeed.\nIn device mode, Setting this bit to 1 also enables the functionality\nof reporting NUMP in the ACK TP based on the RX FIFO space\ninstead of reporting a fixed NUMP derived from DCFG.NUMP\nIf you are using external buffer control (EBC) feature, disable this\nmode by setting USBRxPktCntSel to 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USBRXPKTCNT",
            "bit_range": "27:24",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB Receive Packet Count\nIn host mode, this field specifies the space (in terms of the\nnumber of packets) that must be available in the RX FIFO before\nthe core can start the corresponding USB RX transaction (burst).\nIn device mode, this field specifies the space (in terms of the\nnumber of packets) that must be available in the RX FIFO before\nthe core can send ERDY for a flow-controlled endpoint.\nThis field is valid only when the USB Receive Packet Count Enable\nfield is set to 1. The valid values for this field are from 1 to 15.\nNote: This field must be less than or equal to the USB Maximum\nReceive Burst Size field."
          },
          {
            "name": "USBMAXRXBURSTSIZE",
            "bit_range": "23:19",
            "attr": "RW",
            "reset": "0x00",
            "description": "USB Maximum Receive Burst Size\nIn host mode, this field specifies the Maximum Bulk IN burst the\nusb3 controller can perform.\nWhen the system bus is slower than the USB, RX FIFO can\noverrun during a long burst.\nYou can program a smaller value to this field to limit the RX burst\nsize that the core can perform. It only applies to SS Bulk,\nIsochronous, and Interrupt IN endpoints in the host mode.\nIn device mode, this field specifies the NUMP value that is sent in\nERDY for an OUT endpoint.\nThis field is valid only when USBRxPktCntSel is one. The valid\nvalues for this field are from 1 to 16."
          },
          {
            "name": "RESERVED",
            "bit_range": "18:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Global Rx Threshold Control Register"
      },
      {
        "type": "register",
        "name": "USB3_GCTL",
        "offset": "0xc110",
        "size": "W",
        "reset": "0x30c12004",
        "bit_ranges": [
          {
            "name": "PWRDNSCALE",
            "bit_range": "31:19",
            "attr": "RW",
            "reset": "0x0618",
            "description": "Power Down Scale (PwrDnScale)\nThe USB3 suspend_clk input replaces pipe3_rx_pclk as a clock\nsource to a small part of the USB3 core that operates when the\nSS PHY is in its lowest power (P3) state, and therefore does not\nprovide a clock.\nThe Power Down Scale field specifies how many suspend_clk\nperiods fit into a 16 kHz clock period. When performing the\ndivision, round up the remainder.\nFor example, when using an 8-bit/16-bit/32-bit PHY and 25-MHz\nSuspend clock,\nPower Down Scale = 25000 kHz/16 kHz = 13'd1563 (rounder up)\nNote:\nMinimum Suspend clock frequency is 32 kHz\nMaximum Suspend clock frequency is 125 MHz\nThe LTSSM uses Suspend clock for 12-ms and 100-ms timers\nduring suspend mode. According to the USB 3.0 specification, the\naccuracy on these timers is 0% to +50%.\n12 ms + 0~+50% accuracy = 18 ms (Range is 12 ms - 18 ms)\n100 ms + 0~+50% accuracy = 150 ms (Range is 100 ms -\n150ms).\nThe suspend clock accuracy requirement is:\n(12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period\nmust be between 12,000 and 18,000\n(100,0000/62.5) * (GCTL[31:19]) * actual suspend_clk_period\nmust be between 100,000 and 150,000\nFor example, if your suspend_clk frequency varies from 7.5 MHz\nto 10.5MHz, then the value needs to programmed is:\nPower Down Scale = 10500/16 = 657 (rounded up; and fastest\nfrequency used)."
          },
          {
            "name": "MASTERFILTBYPASS",
            "bit_range": "18",
            "attr": "RW",
            "reset": "0x0",
            "description": "Master Filter Bypass\nWhen this bit is set to 1'b1, all the filters are bypassed. The\ndouble synchronizers to mac_clk preceding the filters are also\nbypassed. For enabling the filters, this bit must be 1'b0."
          },
          {
            "name": "BYPSSETADDR",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Bypass SetAddress in Device Mode.\nWhen BYPSSETADDR bit is set, the device core uses the value in\nthe DCFG[DevAddr] bits directly for comparing the device\naddress in the tokens.\nFor simulation, you can use this feature to avoid sending an\nactual SET ADDRESS control transfer on the USB, and make the\ndevice core respond to a new address.\nWhen the xHCI Debug capability is enabled and this bit is set, the\nDebug Target immediately enters the configured state without\nrequiring the Debug Host to send a SetAddress or SetConfig\nrequest.\nNote: You can set this bit for simulation purposes only. In the\nactual hardware, this bit must be set to 1'b0."
          },
          {
            "name": "U2RSTECN",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x1",
            "description": "U2RSTECN\nIf the SuperSpeed connection fails during POLL or LMP exchange,\nthe device connects at non-SS mode.\nIf this bit is set, then device attempts three more times to\nconnect at SS, even if it previously failed to operate in SS mode.\nFor each attempt, the device checks receiver termination eight\ntimes.\nFrom 2.60a release, this bit controls whether to check for\nRx.Detect eight times or one time for every attempt. Device\ncontroller on USB 2.0 reset checks for receiver termination eight\ntimes per attempt if\nthis bit is set to zero, or only once per attempt if the bit is set to\none.\nNote: This bit is applicable only in device mode."
          },
          {
            "name": "FRMSCLDWN",
            "bit_range": "15:14",
            "attr": "RW",
            "reset": "0x0",
            "description": "FRMSCLDWN\nThis field scales down device view of a SOF/USOF/ITP duration.\nFor SS/HS mode:\nValue of 2'h3 implements interval to be 15.625 us\nValue of 2'h2 implements interval to be 31.25 us\nValue of 2'h1 implements interval to be 62.5 us\nValue of 2'h0 implements interval to be 125us\nFor FS mode, the scale-down value is multiplied by 8.\nWhen xHCI Debug Capability is enabled, this field also scales\ndown the MaxPacketSize of the IN and OUT bulk endpoint to\nallow more traffic during simulation. It can only be changed from\na non-zero\nvalue during simulation.\n2'h0: 1024 bytes\n2'h1: 512 bytes\n2'h2: 256 bytes\n2'h3: 128 bytes"
          },
          {
            "name": "PRTCAPDIR",
            "bit_range": "13:12",
            "attr": "RW",
            "reset": "0x2",
            "description": "PRTCAPDIR: Port Capability Direction (PrtCapDir)\n2'b01: for Host configurations\n2'b10: for Device configurations\nSW should base on IDDIG input to set usb3 controller as an OTG\n2.0/3.0 device with A-device or B-device."
          },
          {
            "name": "CORESOFTRESET",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Core Soft Reset (CoreSoftReset)\n1'b0 - No soft reset;\n1'b1 - Soft reset to core\nClears the interrupts and all the CSRs except the following\nregisters:\nGCTL; GUCTL; GSTS; GSNPSID; GGPIO; GUID; GUSB2PHYCFGn\nregisters; GUSB3PIPECTLn registers; DCFG; DCTL; DEVTEN;\nDSTS.\nWhen you reset PHYs (using GUBS3PHYCFG or GUSB3PIPECTL\nregisters), you must keep the core in reset state until PHY clocks\nare stable. This controls the bus, ram, and mac domain resets.\nNote: This bit is for debug purposes only. Use USBCMD.HCRESET\nin xHCI Mode and DCTL.SoftReset in device mode for soft reset."
          },
          {
            "name": "SOFITPSYNC",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "SOFITPSYNC\nIf this bit is set to 0 operating in host mode, the core keeps the\nUTMI/ULPI PHY on the first port in a non-suspended state\nwhenever there is a SuperSpeed port that is not in Rx.Detect,\nSS.Disable and U3.\nIf this bit is set to 1 operating in host mode, the core keeps the\nUTMI/ULPI PHY on the first port in a non-suspended state\nwhenever the other non-SuperSpeed ports are not in a\nsuspended state. This feature is useful because it saves power by\nsuspending UTMI/ULPI when SuperSpeed only is active, and it\nhelps resolve when the PHY does not transmit a host resume\nunless it is placed in suspend state. This bit must be programmed\nas a part of initialization at power-on reset, and must not be\ndynamically changed afterwards.\nNote:\nUSB2PHYCFGn[6].PhySusp eventually decides to put the\nUTMI/ULPI PHY in to suspend state. In addition, when this bit is\nset to 1, the core generates ITP from the ref_clk based counter.\nOtherwise, ITP and SOF are generated from utmi/ulpi_clk[0]\nbased counter. To program the reference clock period inside the\ncore, refer to GUCTL[31:22].REFCLKPER.\nThis feature is valid in Host and DRD/OTG configurations and\nused only in Host mode operation.\nIf you never use this feature or the\nGFLADJ.GFLADJ_REFCLK_LPM_SEL, the minimum frequency for\nthe ref_clk can be as low as 32KHz. You can connect the\nsuspend_clk (as low as 32 KHz) to the ref_clk.\nIf you plan to enable hardware-based LPM or software-based LPM\n(PORTPMSC. HLE=1), then you cannot use this feature.\nTurn off this feature by setting this bit to 0 and use the\nGFLADJ.GFLADJ_REFCLK_LPM_SEL feature.\nIf you set this bit to 1, the GUSB2PHYCFG.U2_FREECLK_EXISTS\nbit and the DWC_USB3_FREECLK_USB2_EXIST parameter must\nbe set to 0.\nProgram this bit to 0 if the core is intended to be operated in USB\n3.0 mode."
          },
          {
            "name": "U1U2TIMERSCALE",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable U1/U2 timer Scaledown (U1U2TimerScale).\nIf set to 1 along with GCTL[5:4] (ScaleDown) = 2'bX1, disables\nthe scale down of U1/U2 inactive timer values. This is for\nsimulation mode only."
          },
          {
            "name": "DEBUGATTACH",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Debug Attach\nWhen this bit is set:\n1. SS Link proceeds directly to the Polling link state (after\nRUN/STOP in the DCTL register is asserted) without checking\nremote termination;\n2. Link LFPS polling timeout is infinite;\n3. Polling timeout during TS1 is infinite (in case link is waiting for\nTXEQ to finish)."
          },
          {
            "name": "RAMCLKSEL",
            "bit_range": "7:6",
            "attr": "RW",
            "reset": "0x0",
            "description": "RAM Clock Select (RAMClkSel)\n2'b00: bus clock\n2'b01: pipe clock (Only used in device mode)\n2'b10: In device mode, pipe/2 clock. In Host mode, controller\nswitches ram_clk between pipe/2 clock, mac2_clk and bus_clk\nbased on the status of the U2/U3 ports\n2'b11: In device mode, selects mac2_clk as ram_clk (when 8-bit\nUTMI or ULPI used. Not supported in 16-bit UTMI mode); In Host\nmode, controller switches ram_clk between pipe_clk, mac2_clk\nand bus_clk based on the status of the U2/U3 ports.\nIn device mode, upon a USB reset and USB disconnect, the\nhardware clears these bits to 2'b00."
          },
          {
            "name": "SCALEDOWN",
            "bit_range": "5:4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Scale-Down Mode (ScaleDown)\nWhen Scale-Down mode is enabled for simulation, the core uses\nscaled-down timing values, resulting in faster simulations.\nWhen Scale-Down mode is disabled, actual timing values are\nused. This is required for hardware operation.\nHS/FS/LS Modes:\n2'b00: Disables all scale-downs. Actual timing values are used.\n2'b01: Enables scale-down of all timing values except Device\nmode suspend and resume. These include Speed enumeration,\nHNP/SRP, and Host mode suspend and resume\n2'b10: Enables scale-down of Device mode suspend and resume\ntiming values only.\n2'b11: Enables bit 0 and bit 1 scale-down timing values.\nSS Mode:\n2'b00: Disables all scale-downs. Actual timing values are used.\n2'b01: Enables scaled down SS timing and repeat values\nincluding: (1) Number of TxEq training sequences reduce to 8;\n(2) LFPS polling burst time reduce to 256 nS; (3) LFPS warm\nreset receive reduce to 30 uS. 2'b10: No TxEq training sequences\nare sent. Overrides Bit 4.\n2'b11: Enables bit 0 and bit 1 scale-down timing values."
          },
          {
            "name": "DISSCRAMBLE",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Scrambling (DisScramble)\nTransmit request to Link Partner on next transition to Recovery or\nPolling."
          },
          {
            "name": "U2EXIT_LFPS",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x1",
            "description": "U2EXIT_LFPS\nIf this bit is:\n0: the link treats 248ns LFPS as a valid U2 exit.\n1: the link waits for 8us of LFPS before it detects a valid U2 exit.\nThis bit is added to improve interoperability with a third party\nhost controller. This host controller in U2 state while performing\nreceiver detection generates an LFPS glitch of about 4ms\nduration. This causes the device to exit from U2 state because\nthe LFPS filter value is 248ns. With the new functionality enabled,\nthe device can stay in U2 while ignoring this glitch from the host\ncontroller."
          },
          {
            "name": "GBLHIBERNATIONEN",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "GblHibernationEn\nThis bit enables hibernation at the global level. If hibernation is\nnot enabled through this bit, the PMU immediately accepts the\nD0->D3 and D3->D0 power state change requests, but does not\nsave or restore any core state. In addition, the PMUs never drive\nthe PHY interfaces and let the core continue to drive the PHY\ninterfaces."
          },
          {
            "name": "DSBLCLKGTNG",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Clock Gating (DsblClkGtng)\nThis bit is set to 1 and the core is in Low Power mode, internal\nclock gating is disabled. You can set this bit to 1'b1 after Power\nOn Reset."
          }
        ],
        "description": "Global Core Control Register"
      },
      {
        "type": "register",
        "name": "USB3_GPMSTS",
        "offset": "0xc114",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PORTSEL",
            "bit_range": "31:28",
            "attr": "WO",
            "reset": "0x0",
            "description": "Global Power Management Status Register\nThis field selects the port number."
          },
          {
            "name": "RESERVED",
            "bit_range": "27:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "U3WAKEUP",
            "bit_range": "16:12",
            "attr": "RO",
            "reset": "0x00",
            "description": "U3Wakeup\nThis field gives the following USB 3.0 port wakeup conditions:\nBit [12]: Overcurrent Detected\nBit [13]: Resume Detected\nBit [14]: Connect Detected\nBit [15]: Disconnect Detected\nBit [16]: Last Connection State"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "U2WAKEUP",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "U2Wakeup\nThis field indicates the following USB 2.0 port wakeup conditions:\nBit [0]: Overcurrent Detected\nBit [1]: Resume Detected\nBit [2]: Connect Detected\nBit [3]: Disconnect Detected\nBit [4]: Last Connection State\nBit [5]: ID Change Detected\nBit [6]: SRP Request Detected\nBit [7]: ULPI Interrupt Detected\nBit [8]: USB Reset Detected\nBit [9]: Resume Detected Changed"
          }
        ],
        "description": "Global Power Management Status Register"
      },
      {
        "type": "register",
        "name": "USB3_GSTS",
        "offset": "0xc118",
        "size": "W",
        "reset": "0x7e800000",
        "bit_ranges": [
          {
            "name": "CBELT",
            "bit_range": "31:20",
            "attr": "RO",
            "reset": "0x7e8",
            "description": "Current BELT Value\nIn Host mode, this field indicates the minimum value of all\nreceived device BELT values and the BELT value that is set by the\nSet Latency Tolerance Value command."
          },
          {
            "name": "RESERVED",
            "bit_range": "19:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SSIC_IP",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "SSIC interrupt pending\nThis field indicates that there is a pending interrupt related to\nSSIC in the SEVT register.\nNote: When the DWC_USB3_NUM_SSIC_PORTS parameter is set\nto zero, this bit is reserved."
          },
          {
            "name": "OTG_IP",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "OTG Interrupt Pending\nThis field indicates that there is a pending interrupt pertaining to\nOTG in OEVT register."
          },
          {
            "name": "BC_IP",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "Battery Charger Interrupt Pending\nThis field indicates that there is a pending interrupt pertaining to\nBC in BCEVT register."
          },
          {
            "name": "ADP_IP",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "ADP Interrupt Pending\nhis field indicates that there is a pending interrupt pertaining to\nADP in ADPEVT register."
          },
          {
            "name": "HOST_IP",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Host Interrupt Pending\nThis field indicates that there is a pending interrupt pertaining to\nxHC in the Host event queue."
          },
          {
            "name": "DEVICE_IP",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "Device Interrupt Pending\nThis field indicates that there is a pending interrupt pertaining to\nperipheral (device) operation in the Device event queue."
          },
          {
            "name": "CSRTIMEOUT",
            "bit_range": "5",
            "attr": "W1C",
            "reset": "0x0",
            "description": "CSR Timeout\nWhen this bit is 1'b1, it indicates that the software performed a\nwrite or read to a core register that could not be completed\nwithin DWC_USB3_CSR_ACCESS_TIMEOUT bus clock cycles\n(default:\nh1FFFF)."
          },
          {
            "name": "BUSERRADDRVLD",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Bus Error Address Valid\nIndicates that the GBUSERRADDR register is valid and reports the\nfirst bus address that encounters a bus error."
          },
          {
            "name": "RESERVED",
            "bit_range": "3:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CURMOD",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Current Mode of Operation\nCurrent Mode of Operation"
          }
        ],
        "description": "Global Status Register"
      },
      {
        "type": "register",
        "name": "USB3_GUCTL1",
        "offset": "0xc11c",
        "size": "W",
        "reset": "0x0004018a",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FILTER_SE0_FSLS_EOP",
            "bit_range": "29",
            "attr": "RW",
            "reset": "0x0",
            "description": "FILTER_SE0_FSLS_EOP\n0: Default behaviour, no change in Linestate check for SE0\ndetection in FS/LS\n1: Feature enabled, FS/LS SE0 is filtered for 2 clocks for\ndetecting EOP\nThis bit is applicable for FS/LS operation. If this feature is\nenabled, then SE0 on the linestate is validated for 2 consecutive\nutmi/ulpi clock edges for EOP detection. This feature is applicable\nonly in FS in device mode and FS/LS mode of operation in host\nmode.\nDevice mode: FS - If GUCTL1.FILTER_SE0_FSLS_EOP is set, then\nfor device LPM hanshake, the core will ignore single SE0 glitch on\nthe linestate during transmit. Only 2 or more SE0 is considered\nas a valid EOP on FS.\nHost mode: FS/LS - If GUCTL1.FILTER_SE0_FSLS_EOP is set,\nthen the core will ignore single SE0 glitch on the linestate during\ntransmit. Only 2 or more SE0 is considered as a valid EOP on\nFS/LS port. Enable this feature if the LineState has SE0 glitches\nduring transmission. This bit is quasi-static, i.e., should not be\nchanged during device operation."
          },
          {
            "name": "TX_IPGAP_LINECHECK_DIS",
            "bit_range": "28",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX_IPGAP_LINECHECK_DIS\n0: Default behaviour, no change in Linestate check\n1: Feature enabled, 2.0 MAC disables Linestate check during HS\ntransmit\nThis bit is applicable for HS operation of u2mac. If this feature is\nenabled, then the 2.0 mac operating in HS ignores the UTMI/ULPI\nLinestate during the transmit of a token (during token-to-token\nand token-to-data IPGAP). When enabled, the controller\nimplements a fixed 40-bit TxEndDelay after the packet is given\non UTMI and ignores the Linestate during this time. This fetaure\nis applicable only in HS mode of operation.\nDevice mode: If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then\nfor device LPM handshake, the core will ignore the linestate after\nTX and wait for a fixed clocks ( 40 bit times equivalent) after\ntransmiting ACK on utmi.\nHost mode: If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then\nthe ipgap between (tkn to tkn/data) is added by 40 bit times of\nTXENDDELAY, and linestate is ignored during this 40 bit times\ndelay.\nEnable this bit if the LineState will not reflect the expected line\nstate (J) during transmission. This bit is quasi-static, i.e., should\nnot be changed during device operation."
          },
          {
            "name": "DEV_TRB_OUT_SPR_IND",
            "bit_range": "27",
            "attr": "RW",
            "reset": "0x0",
            "description": "DEV_TRB_OUT_SPR_IND\n0: Default behaviour, no change in TRB status dword\n1: Feature enabled, OUT TRB status indicates Short Packet\nThis bit is applicable for device mode only (and ignored in host\nmode). If the device application (SW/HW) wants to know if a\nshort packet was received for an OUT in the TRB status itself,\nthen this feature can be enabled, so that a bit is set in the TRB\nwriteback in the buf_size dword. Bit[26] - SPR of the trbstatus,\nRSVD, SPR,PCM1, bufsize dword will be set during an OUT\ntransfer TRB write back if this is the last TRB used for that\ntransfer descriptor. This bit is quasi-static, i.e., should not be\nchanged during device operation."
          },
          {
            "name": "DEV_FORCE_20_CLK_FOR_30_CLK",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "DEV_FORCE_20_CLK_FOR_30_CLK\n0: Default behaviour, Uses 3.0 clock when operating in 2.0 mode\n1: Feature enabled\nThis bit is applicable (and to be set) for device mode\n(DCFG.Speed!= SS) only. In the 3.0 device core, if the core is\nprogrammed to operate in 2.0 only (i.e., Device Speed is\nprogrammed to 2.0 speeds in DCFG[Speed]), then setting this bit\nmakes the internal 2.0 (utmi/ulpi) clock to be routed as the 3.0\n(pipe) clock. Enabling this feature allows the pipe3 clock to be\nnot-running when forcibily operating in 2.0 device mode. Note:\nWhen using this feature, all pipe3 inputs must be in inactive\nmode, esp. pipe3 clocks not running and pipe3_phystatus_async\nmust be tied to 0. This bit should not be set if the core is\nprogrammed to operate in SuperSpeed mode (even when it falls\nback to 2.0). This bit is quasi-static, i.e., should not be changed\nduring operation."
          },
          {
            "name": "P3_IN_U2",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "P3_IN_U2\n0: Default behaviour, When SuperSpeed link is in U2 ,\nPowerState P2 is attempted on the PIPE Interface.\n1: When SuperSpeed link is in U2, PowerState P3 is attempted if\nGUSB3PIPECTL[17] is set.\nSetting this bit enables P3 Power State when the SuperSpeed link\nis in U2. Another Power Saving option. When setting this bit to 1\nto enable P3 in P2, GUSB3PIPECTL[27] should be set to 0 to\nmake sure that the U2 exit is attempted in P0."
          },
          {
            "name": "DEV_L1_EXIT_BY_HW",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "DEV_L1_EXIT_BY_HW\n0: Default behaviour, disables device L1 hardware exit logic\n1: feature enabled\nThis bit is applicable for device mode (2.0) only. This field\nenables device controller sending remote wakeup for L1 if the\ndevice becomes ready for sending/accepting data when in L1\nstate. If the host expects the device to send remote wkp\nsignalling to resume after going into L1 in flow controlled state,\nthen this bit can be set to send the remote wake signal\nautomatically when the device controller becomes ready. This HW\nremote wake feature is applicable only to bulk and interrupt\ntransfers, and not for Isoch/Control\nWhen control transfers are in progress, the LPM will be rejected\n(NYET response). Only after control transfers are completed\n(either with ACK/STALL), LPM will be accepted\nFor Isoch transfers, the host needs to do the wake-up and start\nthe transfer. Device controller will not do remote-wakeup when\nIsoch endpoints get ready. The device SW needs to keep the\nGUSB2PHYCFG[EnblSlpM] reset in order to keep the PHY clock to\nbe running for keeping track of SOF intervals.\nWhen L1 hibernation is enabled, the controller will not do\nautomatic exit for hibernation requests thru L1.\nThis bit is quasi-static, i.e., should not be changed during device\noperation."
          },
          {
            "name": "IP_GAP_ADD_ON",
            "bit_range": "23:21",
            "attr": "RW",
            "reset": "0x0",
            "description": "IP_GAP_ADD_ON\nThis register field is used to add on to the default inter packet\ngap setting in the USB 2.0 MAC. This should be programmed to a\nnon zero value only in case where you need to increase the\ndefault inter packet delay calculations in the USB 2.0 MAC\nmodule DWC_usb3_u2mac.v"
          },
          {
            "name": "DEV_LSP_TAIL_LOCK_DIS",
            "bit_range": "20",
            "attr": "RW",
            "reset": "0x0",
            "description": "DEV_LSP_TAIL_LOCK_DIS\n0: Default behaviour, enables device lsp lock logic for tail TRB\nupdate\n1: Fix disabled\nThis is a bug fix for STAR 9000716195 that affects the CSP mode\nfor OUT endpoints in device mode. The issue is that tail TRB\nindex is not synchronized with the cache Scratchpad bytecount\nupdate. If the fast-forward request comes in-between the\nbytecount update ona newly fetched TRB and the tail-index write\nupdate in TPF, the RDP works on an incorrect tail index and\nmisses the byte count decrement for the newly fetched TRB in\nthe fast-forwarding process. This fix needs to be present all the\ntimes."
          },
          {
            "name": "NAK_PER_ENH_FS",
            "bit_range": "19",
            "attr": "RW",
            "reset": "0x0",
            "description": "NAK_PER_ENH_FS\n1: Enables performance enhancement for FS async endpoints in\nthe presence of NAKs\n0: Enhancement not applied\nIf a periodic endpoint is present , and if a bulk endpoint which is\nalso active is being NAKed by the device, then this could result in\na decrease in performance of other Full Speed bulk endpoint\nwhich is ACked by the device. Setting this bit to 1, will enable the\nhost controller to schedule more transactions to the async\nendpoints (bulk/ control) and hence will improve the performance\nof the bulk endpoint. This control bit should be enabled only if the\nexisting performance with the default setting is not sufficient for\nyour FullSpeed application. Setting this bit will only control, and\nis only required for Full Speed transfers."
          },
          {
            "name": "NAK_PER_ENH_HS",
            "bit_range": "18",
            "attr": "RW",
            "reset": "0x1",
            "description": "NAK_PER_ENH_HS\n1: Enables performance enhancement for HS async endpoints in\nthe presence of NAKs\n0: Enhancement not applied\nIf a periodic endpoint is present , and if a bulk endpoint which is\nalso active is being NAKed by the device, then this could result in\na decrease in performance of other High Speed bulk endpoint\nwhich is ACked by the device. Setting this bit to 1, will enable the\nhost controller to schedule more transactions to the async\nendpoints (bulk/ control) and hence will improve the performance\nof the bulk endpoint. This control bit should be enabled only if the\nexisting performance with the default setting is not sufficient for\nyour HighSpeed application. Setting this bit will only control, and\nis only required for High Speed transfers."
          },
          {
            "name": "PARKMODE_DISABLE_SS",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "PARKMODE_DISABLE_SS\nThis bit is used only in host mode, and is for debug purpose only.\nWhen this bit is set to 1 all SS bus instances in park mode are\ndisabled."
          },
          {
            "name": "PARKMODE_DISABLE_HS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "PARKMODE_DISABLE_HS\nThis bit is used only in host mode.\nWhen this bit is set to 1 all HS bus instances park mode are\ndisabled.\nTo improve performance in park mode, the xHCI scheduler\nqueues in three requests of 4 packets each for High Speed\nasynchronous endpoints in a micro-frame. But if a device is slow\nand if it NAKs more than 3 times, then it is rescheduled only in\nthe next micro-frame. This could decrease the performance of a\nslow device even further.\nIn a few high speed devices (such as Sandisk Cruzer Blade 4GB\nVID:1921, PID:21863 and Flex Drive VID:3744, PID:8552) when\nan IN request is sent within 900ns of the ACK of the previous\npacket, these devices send a NAK. When connected to these\ndevices, if required, the software can disable the park mode if\nyou see performance drop in your system. When park mode is\ndisabled, pipelining of multiple packet is disabled and instead one\npacket at a time is requested by the scheduler. This allows up to\n12 NAKs in a micro-frame and improves performance of these\nslow devices."
          },
          {
            "name": "PARKMODE_DISABLE_FSLS",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "PARKMODE_DISABLE_FSLS\nThis bit is used only in host mode, and is for debug purpose only.\nWhen this bit is set to 1 all FS/LS bus instances in park mode\ndisabled."
          },
          {
            "name": "RESERVED",
            "bit_range": "14:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "L1_SUSP_THRLD_EN_FOR_HOST",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x1",
            "description": "L1_SUSP_THRLD_EN_FOR_HOST\nThis bit is used only in host mode.\nThe host controller asserts the utmi_l1_suspend_n and\nutmi_sleep_n output signals (see LPM Interface Signals table in\nthe Databook) as follows:\nThe controller asserts the utmi_l1_suspend_n signal to put the\nPHY into deep low-power mode in L1 when both of the following\nare true:\nThe HIRD/BESL value used is greater than or equal to the value\nin L1_SUSP_THRLD_FOR_HOST field.\nThe L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b1. The\ncontroller asserts utmi_sleep_n on L1 when one of the following\nis true:\nThe HIRD/BESL value used is less than the value in\nL1_SUSP_THRLD_FOR_HOST field.\nThe L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b0."
          },
          {
            "name": "L1_SUSP_THRLD_FOR_HOST",
            "bit_range": "7:4",
            "attr": "RW",
            "reset": "0x8",
            "description": "L1_SUSP_THRLD_FOR_HOST\nThis field is effective only when the\nL1_SUSP_THRLD_EN_FOR_HOST bit is set to 1. For more details,\nrefer to the description of the L1_SUSP_THRLD_EN_FOR_HOST\nbit."
          },
          {
            "name": "HC_ERRATA_ENABLE",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x1",
            "description": "Host ELD Enable\nWhen this bit is set to 1, it enables the Exit Latency Delta (ELD)\nsupport defined in the xHCI 1.0 Errata.\nThis bit is used only in the host mode. This bit has to be set to 1\nin Host mode."
          },
          {
            "name": "HC_PARCHK_DISABLE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host Parameter Check Disable\nWhen this bit is set to 0 (by default), the xHC checks that the\ninput slot/EP context fields comply to the xHCI Specification.\nUpon detection of a parameter error during command execution,\nthe xHC generates an event TRB with completion code indicating\nPARAMETER ERROR.\nWhen the bit is set to 1, the xHC does not perform parameter\nchecks and does not generate PARAMETER ERROR completion\ncode."
          },
          {
            "name": "OVRLD_L1_SUSP_COM",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x1",
            "description": "OVRLD_L1_SUSP_COM\nIf this bit is set, the utmi_l1_suspend_com_n is overloaded with\nthe utmi_sleep_n signal. This bit is usually set if the PHY stops\nthe port clock during L1 sleep condition."
          },
          {
            "name": "LOA_FILTER_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "LOA_FILTER_EN\nIf this bit is set, the USB 2.0 port babble is checked at least three\nconsecutive times before the port is disabled. This prevents false\ntriggering of the babble condition when using low quality cables.\nNote: This bit is valid only in host mode."
          }
        ],
        "description": "Global User Control Register 1"
      },
      {
        "type": "register",
        "name": "USB3_GSNPSID",
        "offset": "0xc120",
        "size": "W",
        "reset": "0x5533290a",
        "bit_ranges": [
          {
            "name": "SNPSID",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x5533300a",
            "description": "SNPSID\nSNPSID[31:16] indicates Core Identification Number. 0x5533 is\nASCII for U3 (DWC_usb3).\nSNPSID[15:0] indicates the release number. Current Release is\n3.00a.\nSoftware uses this register to configure release-specific features\nin the driver."
          }
        ],
        "description": "Global SNPS ID Register"
      },
      {
        "type": "register",
        "name": "USB3_GGPIO",
        "offset": "0xc124",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPO",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "General Purpose Output\nThis field's value is driven out on the gp_out[15:0] core output\nport."
          },
          {
            "name": "GPI",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0000",
            "description": "General Purpose Input\nThis field's read value reflects the gp_in[15:0] core input value."
          }
        ],
        "description": "Global General Purpose Input/Output Register"
      },
      {
        "type": "register",
        "name": "USB3_GUID",
        "offset": "0xc128",
        "size": "W",
        "reset": "0x12345678",
        "bit_ranges": [
          {
            "name": "USERID",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x12345678",
            "description": "USERID\nApplication-programmable ID field."
          }
        ],
        "description": "Global User ID Register"
      },
      {
        "type": "register",
        "name": "USB3_GUCTL",
        "offset": "0xc12c",
        "size": "W",
        "reset": "0x02008010",
        "bit_ranges": [
          {
            "name": "REFCLKPER",
            "bit_range": "31:22",
            "attr": "RW",
            "reset": "0x008",
            "description": "REFCLKPER\nThis field indicates in terms of nano seconds the period of ref_clk.\nThe default value of this register is set to 'h8 (8ns/125 MHz).\nThis field needs to be updated during power-on initialization, if\nGCTL.SOFITPSYNC or GFLADJ.GFLADJ_REFCLK_LPM_SEL is set to\n1. The programmable maximum value is 62ns, and the minimum\nvalue is 8ns.\nYou must use a reference clock with a period that is an integer\nmultiple, so that ITP can meet the jitter margin of 32ns. The\nallowable ref_clk frequencies whose period is not integer\nmultiples are 16/17/19.2/24/39.7MHz.\nThis field must not be set to 0 at any time. If you never plan to\nuse this feature, then set this field to 'h8, the default value."
          },
          {
            "name": "NOEXTRDL",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "No Extra Delay Between SOF and the First\nSome HS devices misbehave when the host sends a packet\nimmediately after a SOF. However, adding an extra delay\nbetween a SOF and the first packet can reduce the USB data rate\nand performance.\nThis bit is used to control whether the host must wait for 2\nmicroseconds before it sends the first packet after a SOF, or not.\nUser can set this bit to one to improve the performance if those\nproblematic devices are not a concern in the user's host\nenvironment.\n1'b0: Host waits for 2 microseconds after a SOF before it sends\nthe first USB packet.\n1'b1: Host doesn't wait after a SOF before it sends the first USB\npacket."
          },
          {
            "name": "RESERVED",
            "bit_range": "20:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SPRSCTRLTRANSEN",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Sparse Control Transaction Enable\nSome devices are slow in responding to Control transfers.\nScheduling multiple transactions in one microframe/frame can\ncause these devices to misbehave.\nIf this bit is set to 1'b1, the host controller schedules transactions\nfor a Control transfer in different microframes/frames."
          },
          {
            "name": "RESBWHSEPS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Reserving 85% Bandwidth for HS Periodic EPs\nBy default, HC reserves 80% of the bandwidth for periodic EPs. If\nthis bit is set, the bandwidth is relaxed to 85% to accommodate\ntwo high speed, high bandwidth ISOC EPs.\nUSB 2.0 required 80% bandwidth allocated for ISOC traffic. If two\nHigh-bandwidth ISOC devices (HD Webcams) are connected, and\nif each requires 1024-bytes X 3 packets per Micro-Frame, then\nthe bandwidth required is around 82%. If this bit is set, then it is\npossible to connect two Webcams of 1024bytes X 3 paylod per\nMicro-Frame each. Otherwise, you may have to reduce the\nresolution of the Webcams.\nThis bit is valid in Host and DRD configuration and is used in host\nmode operation only. Ignore this bit in device mode."
          },
          {
            "name": "CMDEVADDR",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x1",
            "description": "Compliance Mode for Device Address\nWhen this bit is 1'b1, Slot ID may have different value than\nDevice Address if max_slot_enabled < 128.\n1'b1: Increment Device Address on each Address Device\ncommand.\n1'b0: Device Address is equal to Slot ID.\nThe xHCI compliance requires this bit to be set to 1. The 0 mode\nis for debug purpose only. This allows you to easily identify a\ndevice connected to a port in the Lecroy or Eliisys trace during\nhardware debug.\nThis bit is valid in Host and DRD configuration and is used in host\nmode operation only. Ignore this bit in device mode."
          },
          {
            "name": "USBHSTINAUTORETRYEN",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host IN Auto Retry\nWhen set, this field enables the Auto Retry feature. For IN\ntransfers (non-isochronous) that encounter data packets with\nCRC errors or internal overrun scenarios, the auto retry feature\ncauses the Host core to reply to the device with a non-\nterminating retry ACK (that is, an ACK transaction packet with\nRetry = 1 and NumP != 0).\nIf the Auto Retry feature is disabled (default), the core will\nrespond with a terminating retry ACK (that is, an ACK transaction\npacket with Retry = 1 and NumP = 0).\n1'b0: Auto Retry Disabled\n1'b1: Auto Retry Enabled\nNote: This bit is also applicable to the device mode."
          },
          {
            "name": "ENOVERLAPCHK",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Check for LFPS Overlap During Remote Ux\n1'b1: The SuperSpeed link when exiting U1/U2/U3 waits for\neither the remote link LFPS or TS1/TS2 training symbols before it\nconfirms that the LFPS handshake is complete. This is done to\nhandle the case where the LFPS glitch causes the link to start\nexiting from the low power state. Looking for the LFPS overlap\nmakes sure that the link partner also sees the LFPS.\n1'b0: When the link exists U1/U2/U3 because of a remote exit, it\ndoes not look for an LFPS overlap."
          },
          {
            "name": "EXTCAPSUPPTEN",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "External Extended Capability Support Enable\nWhen set, this field enables extended capabilities to be\nimplemented outside the core.\nWhen the ExtCapSupEN is set and the Debug Capability is\nenabled, the Next Capability pointer in Debug Capability returns\n16.\nA read to the first DWORD of the last internal extended capability\n(the \"xHCI Supported Protocol Capability for USB 3.0\" when the\nDebug Capability is not enabled) returns a value of 4 in the Next\nCapability Pointer field.\nThis indicates to software that there is another capability four\nDWORDs after this capability (for example, at address N+16\nwhere N is the address of this DWORD). If enabled, an external\naddress decoder that snoops the xHC slave interface must be\nimplemented.\nIf it sees an access to N+16 or greater, the slave access is re-\nrouted to a piece of hardware which returns the external\ncapability pointer register of the new capability and also handles\nreads/writes to this new capability and the side effects.\nIf disabled, a read to the first DWORD of the last internal\nextended capability returns 0 in the 'Next Capability Pointer' field.\nThis indicates there are no more capabilities."
          },
          {
            "name": "INSRTEXTRFSBODI",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Insert Extra Delay Between FS Bulk OUT\nSome FS devices are slow to receive Bulk OUT data and can get\nstuck when there are consecutive Bulk OUT transactions with\nshort inter-transaction delays. This bit is used to control whether\nthe host inserts extra delay between consecutive Bulk OUT\ntransactions to a FS Endpoint.\n1'b0: Host doesn't insert extra delay between consecutive Bulk\nOUT transactions to a FS Endpoint.\n1'b1: Host inserts about 12us extra delay between consecutive\nBulk OUT transactions to a FS Endpoint to work around the\ndevice issue.\nNote: Setting this bit to one will reduce the Bulk OUT transfer\nperformance for most of the FS devices."
          },
          {
            "name": "DTCT",
            "bit_range": "10:9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Device Timeout Coarse Tuning\nThis field is a Host mode parameter which determines how long\nthe host waits for a response from device before considering a\ntimeout.\nThe core first checks the DTCT value. If it is 0, then the timeout\nvalue is defined by the DTFT. If it is non-zero, then it uses the\nfollowing timeout values:\n2'b00: 0 usec -> use DTFT value instead\n2'b01: 500 usec\n2'b10: 1.5 msec\n2'b11: 6.5 msec"
          },
          {
            "name": "DTFT",
            "bit_range": "8:0",
            "attr": "RW",
            "reset": "0x010",
            "description": "Device Timeout Fine Tuning\nThis field is a Host mode parameter which determines how long\nthe host waits for a response from device before considering a\ntimeout.\nFor the DTFT field to take effect, DTCT must be set to 2'b00.\nThe DTFT value is the number of 125 MHz clocks * 256 to count\nbefore considering a device timeout.\nThe minimum value of DTFT is 2.\nFor example, if the mac3_clk is 125 MHz clk (8 ns period), this is\ncalculated as follows:\n(DTFT value) * 256 * (8 ns)\nQuick Reference:\nif DTFT = 0x2, 2*256*8 = 4usec timeout\nif DTFT = 0x5, 5*256*8 = 10usec timeout\nif DTFT = 0xA, 10*256*8 = 20usec timeout\nif DTFT = 0x10, 16*256*8 = 32usec timeout\nif DTFT = 0x19, 25*256*8 = 51usec timeout\nif DTFT = 0x31, 49*256*8 = 100usec timeout\nif DTFT = 0x62, 98*256*8 = 200usec timeout"
          }
        ],
        "description": "Global User Control Register"
      },
      {
        "type": "register",
        "name": "USB3_GBUSERRADDRLO",
        "offset": "0xc130",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "BUSERRADDR",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Bus Address - Low\nThis register contains the lower 32 bits of the first bus address\nthat encountered a SoC bus error. It is valid when the\nGSTS.BusErrAddrVld field is 1. It can only be cleared by resetting\nthe core.\nNote: Only supported in AHB and AXI configurations."
          }
        ],
        "description": "Global SoC Bus Error Address Register - Low"
      },
      {
        "type": "register",
        "name": "USB3_GBUSERRADDRHI",
        "offset": "0xc134",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "BUSERRADDR",
            "bit_range": "31:0",
            "attr": "RU",
            "reset": "0x00000000",
            "description": "Bus Address - High\nhis register contains the higher 32 bits of the first bus address\nthat encountered a SoC bus error. It is valid when the\nGSTS.BusErrAddrVld field is 1. It can only be cleared by resetting\nthe core.\nNote: Only supported in AHB and AXI configurations."
          }
        ],
        "description": "Global SoC Bus Error Address Register - High"
      },
      {
        "type": "register",
        "name": "USB3_GPRTBIMAPLO",
        "offset": "0xc138",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BINUM1",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "SS USB Instance Number for Port 1\nApplication-programmable ID field."
          }
        ],
        "description": "Global SS Port to Bus Instance Mapping Register - Low"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS0",
        "offset": "0xc140",
        "size": "W",
        "reset": "0x2020400a",
        "bit_ranges": [
          {
            "name": "GHWPARAMS0",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x2020400a",
            "description": "Global Hardware Parameters Register 0\nGlobal Hardware Parameters Register 0"
          }
        ],
        "description": "Global Hardware Parameters Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS1",
        "offset": "0xc144",
        "size": "W",
        "reset": "0x0160c93b",
        "bit_ranges": [
          {
            "name": "GHWPARAMS1",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x0160c93b",
            "description": "Global Hardware Parameters Register 1\nGlobal Hardware Parameters Register 1"
          }
        ],
        "description": "Global Hardware Parameters Register 1"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS2",
        "offset": "0xc148",
        "size": "W",
        "reset": "0x12345678",
        "bit_ranges": [
          {
            "name": "GHWPARAMS2",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x12345678",
            "description": "Global Hardware Parameters Register 2\nGlobal Hardware Parameters Register 2"
          }
        ],
        "description": "Global Hardware Parameters Register 2"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS3",
        "offset": "0xc14c",
        "size": "W",
        "reset": "0x069cd085",
        "bit_ranges": [
          {
            "name": "GHWPARAMS3",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x069cd085",
            "description": "Global Hardware Parameters Register 3\nGlobal Hardware Parameters Register 3"
          }
        ],
        "description": "Global Hardware Parameters Register 3"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS4",
        "offset": "0xc150",
        "size": "W",
        "reset": "0x47822008",
        "bit_ranges": [
          {
            "name": "GHWPARAMS4",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x47822008",
            "description": "Global Hardware Parameters Register 4\nGlobal Hardware Parameters Register 4"
          }
        ],
        "description": "Global Hardware Parameters Register 4"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS5",
        "offset": "0xc154",
        "size": "W",
        "reset": "0x04202088",
        "bit_ranges": [
          {
            "name": "GHWPARAMS5",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x04202088",
            "description": "Global Hardware Parameters Register 5\nGlobal Hardware Parameters Register 5"
          }
        ],
        "description": "Global Hardware Parameters Register 5"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS6",
        "offset": "0xc158",
        "size": "W",
        "reset": "0x077c8020",
        "bit_ranges": [
          {
            "name": "GHWPARAMS6",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x077c8020",
            "description": "Global Hardware Parameters Register 6\nGlobal Hardware Parameters Register 6"
          }
        ],
        "description": "Global Hardware Parameters Register 6"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS7",
        "offset": "0xc15c",
        "size": "W",
        "reset": "0x03080756",
        "bit_ranges": [
          {
            "name": "GHWPARAMS7",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x03080756",
            "description": "Global Hardware Parameters Register 7\nGlobal Hardware Parameters Register 7"
          }
        ],
        "description": "Global Hardware Parameters Register 7"
      },
      {
        "type": "register",
        "name": "USB3_GDBGFIFOSPACE",
        "offset": "0xc160",
        "size": "W",
        "reset": "0x00420000",
        "bit_ranges": [
          {
            "name": "SPACE_AVAILABLE",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0042",
            "description": "Space Avalible\nSpace Avalible"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_QUEUE_SELECT",
            "bit_range": "8:0",
            "attr": "RW",
            "reset": "0x000",
            "description": "FIFO/Queue Select (or) Port-Select\nFIFO/Queue Select[8:5] indicates the FIFO/Queue Type\nFIFO/Queue Select[4:0] indicates the FIFO/Queue Number\nPort-Select[3:0] selects the port-number when accessing\nGDBGLTSSM register."
          }
        ],
        "description": "Global Debug Queue/FIFO Space Available Register"
      },
      {
        "type": "register",
        "name": "USB3_GDBGLTSSM",
        "offset": "0xc164",
        "size": "W",
        "reset": "0x41010440",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXELECIDLE",
            "bit_range": "30",
            "attr": "RO",
            "reset": "0x1",
            "description": "RxElecidle\nReflect status of Pipe interface."
          },
          {
            "name": "RESERVED",
            "bit_range": "29:27",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LTDBTIMEOUT",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "LTDB Timeout\nLTDB Timeout"
          },
          {
            "name": "LTDBLINKSTATE",
            "bit_range": "25:22",
            "attr": "RO",
            "reset": "0x4",
            "description": "LTDB Link State\nLTDB Link State"
          },
          {
            "name": "LTDBSUBSTATE",
            "bit_range": "21:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "LTDB Sub-State\nLTDB Sub-State"
          },
          {
            "name": "ELASTICBUFFERMODE",
            "bit_range": "17",
            "attr": "RO",
            "reset": "0x0",
            "description": "ELASTICBUFFERMODE\nReflect status of Pipe interface."
          },
          {
            "name": "TXELECLDLE",
            "bit_range": "16",
            "attr": "RO",
            "reset": "0x1",
            "description": "TXELECLDLE\nReflect status of Pipe interface."
          },
          {
            "name": "RXPOLARITY",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "RXPOLARITY\nReflect status of Pipe interface."
          },
          {
            "name": "TXDETRXLOOPBACK",
            "bit_range": "14",
            "attr": "RO",
            "reset": "0x0",
            "description": "Tx Detect Rx/Loopback\nReflect status of Pipe interface."
          },
          {
            "name": "LTDBPHYCMDSTATE",
            "bit_range": "13:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "LTSSM PHY command State\n000: PHY_IDLE (PHY command state is in IDLE. No PHY request\npending)\n001: PHY_DET (Request to start Receiver detection)\n010: PHY_DET_3 (Wait for Phy_Status (Receiver detection))\n011: PHY_PWR_DLY (Delay Pipe3_PowerDown P0 -> P1/P2/P3\nrequest)\n100: PHY_PWR_A (Delay for internal logic)\n101: PHY_PWR_B (Wait for Phy_Status(Power state change\nrequest))"
          },
          {
            "name": "POWERDOWN",
            "bit_range": "10:9",
            "attr": "RO",
            "reset": "0x2",
            "description": "POWERDOWN\nReflect status of Pipe interface."
          },
          {
            "name": "RXEQTRAIN",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "RXEQTRAIN\nReflect status of Pipe interface."
          },
          {
            "name": "TXDEEMPHASIS",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x1",
            "description": "TXDEEMPHASIS\nReflect status of Pipe interface."
          },
          {
            "name": "LTDBCLKSTATE",
            "bit_range": "5:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "LTSSM Clock State\nIn multi-port host configuration, the port number is defined by\nPort-Select[3:0] field in the GDBGFIFOSPACE register.\nNote:GDBGLTSSM register is not applicable for USB 2.0-only\nmode.\n000: CLK_NORM (PHY is in non-P3 state and PCLK is running)\n001: CLK_TO_P3 (P3 entry request to PHY);\n010: CLK_WAIT1 (Wait for Phy_Status (P3 request));\n011: CLK_P3 (PHY is in P3 and PCLK is not running);\n100: CLK_TO_P0 (P3 exit request to PHY);\n101: CLK_WAIT2 (Wait for Phy_Status (P3 exit request))"
          },
          {
            "name": "TXSWING",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "TXSWING\nReflect status of Pipe interface."
          },
          {
            "name": "RXTERMINATION",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "RXTERMINATION\nReflect status of Pipe interface."
          },
          {
            "name": "TXONESZEROS",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "TXONESZEROS\nReflect status of Pipe interface."
          }
        ],
        "description": "Global Debug LTSSM Register"
      },
      {
        "type": "register",
        "name": "USB3_GDBGLNMCC",
        "offset": "0xc168",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LNMCC_BERC",
            "bit_range": "8:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "LNMCC_BERC\nThis field indicates the bit error rate information for the port\nselected in the GDBGFIFOSPACE.PortSelect field.This field is for\ndebug purposes only."
          }
        ],
        "description": "Global Debug LNMCC Register"
      },
      {
        "type": "register",
        "name": "USB3_GDBGBMU",
        "offset": "0xc16c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "BMU_BCU",
            "bit_range": "31:8",
            "attr": "RW",
            "reset": "0x000000",
            "description": "BMU_BCU Debug information\nBMU_BCU Debug information"
          },
          {
            "name": "BMU_DCU",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "BMU_DCU Debug information\nBMU_DCU Debug information"
          },
          {
            "name": "BMU_CCU",
            "bit_range": "3:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "BMU_CCU Debug information\nBMU_CCU Debug information"
          }
        ],
        "description": "Global Debug BMU Register"
      },
      {
        "type": "register",
        "name": "USB3_GDBGLSPMUX",
        "offset": "0xc170",
        "size": "W",
        "reset": "0x003f0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LOGIC_ANALYZER_TRACE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x3f",
            "description": "Logic Analyzer Trace Port MUX Select\nCurrently only bits[21:16] are used. A value of 6'h3F drives \"0\"s\non the logic_analyzer_trace signal. If you plan to OR (instead\nusing a mux) this signal with other trace signals in your system\nto generate a common trace signal, you can use this feature."
          },
          {
            "name": "ENDBC",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "EnDbc\nEnable debugging of Debug capablity LSP in Host mode. Use\nHostSelect to select DbC LSP debug information presented in the\nGDBGLSP register."
          },
          {
            "name": "RESERVED",
            "bit_range": "14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HOSTSELECT",
            "bit_range": "13:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Host LSP Select\nSelects the LSP debug information presented in the GDBGLSP\nregister in host mode."
          },
          {
            "name": "DEVSELECT",
            "bit_range": "7:4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Device LSP Select\nSelects the LSP debug information presented in the GDBGLSP\nregister in device mode. Or bit[7:4] of HOSTSELECT, Selects the\nLSP debug information presented in the GDBGLSP register in host\nmode."
          },
          {
            "name": "EPSELECT",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Device Endpoint Select\nSelects the Endpoint debug information presented in the\nGDBGEPINFO registers in device mode. Or bit[3:0] of\nHOSTSELECT, Selects the LSP debug information presented in the\nGDBGLSP register in host mode."
          }
        ],
        "description": "Global Debug LSP MUX Register - Device"
      },
      {
        "type": "register",
        "name": "USB3_GDBGLSP",
        "offset": "0xc174",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "LSPDEBUG",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "LSP Debug Information\nLSP Debug Information"
          }
        ],
        "description": "Global Debug LSP Register"
      },
      {
        "type": "register",
        "name": "USB3_GDBGEPINFO0",
        "offset": "0xc178",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "EPDEBUG",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Endpoint Debug Information Low 32-bit\nEndpoint Debug Information Low 32-bit"
          }
        ],
        "description": "Global Debug Endpoint Information Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GDBGEPINFO1",
        "offset": "0xc17c",
        "size": "W",
        "reset": "0x00800000",
        "bit_ranges": [
          {
            "name": "EPDEBUG",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00800000",
            "description": "Endpoint Debug Information High 32-bit\nEndpoint Debug Information High 32-bit"
          }
        ],
        "description": "Global Debug Endpoint Information Register 1"
      },
      {
        "type": "register",
        "name": "USB3_GPRTBIMAP_HSLO",
        "offset": "0xc180",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BINUM1",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "HS USB Instance Number for Port 1\nApplication-programmable ID field."
          }
        ],
        "description": "Global High-Speed Port to Bus Instance Mapping Register - Low"
      },
      {
        "type": "register",
        "name": "USB3_GPRTBIMAP_FSLO",
        "offset": "0xc188",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BINUM1",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "FS USB Instance Number for Port 1\nApplication-programmable ID field."
          }
        ],
        "description": "Global Full-Speed Port to Bus Instance Mapping Register - Low"
      },
      {
        "type": "register",
        "name": "USB3_GUSB2PHYCFG0",
        "offset": "0xc200",
        "size": "W",
        "reset": "0x40102400",
        "bit_ranges": [
          {
            "name": "PHYSOFTRST",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "UTMI PHY Soft Reset\nCauses the usb2phy_reset signal to be asserted to reset a UTMI\nPHY. Not applicable to ULPI because ULPI PHYs are reset via their\nFunctionControl.Reset register, and the core automatically writes\nto this register when the core is reset (vcc_reset_n,\nUSBCMD.HCRST, DCTL.SoftReset, or GCTL.SoftReset)"
          },
          {
            "name": "U2_FREECLK_EXISTS",
            "bit_range": "30",
            "attr": "RW",
            "reset": "0x1",
            "description": "U2_FREECLK_EXISTS\nSpecifies whether your USB 2.0 PHY provides a free-running PHY\nclock, which is active when the clock control input is active.\nIf your USB 2.0 PHY provides a free-running PHY clock, it must be\nconnected to the utmi_clk[0] input. The remaining utmi_clk[n]\nmust be connected to the respective port clocks. The core uses\nthe Port-0 clock for generating the internal mac2 clock.\n1'b0: USB 2.0 free clock does not exist\n1'b1: USB 2.0 free clock exists\nNote: When the core is configured as device-only, do not set this\nbit to 1."
          },
          {
            "name": "RESERVED",
            "bit_range": "29:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LSTRD",
            "bit_range": "24:22",
            "attr": "RW",
            "reset": "0x0",
            "description": "LS Turnaround Time\nThis field indicates the value of the Rx-to-Tx packet gap for LS\ndevices. The encoding is as follows:\n0: 2 bit times\n1: 2.5 bit times\n2: 3 bit times\n3: 3.5 bit times\n4: 4 bit times\n5: 4.5 bit times\n6: 5 bit times\n7: 5.5 bit times\nNote:\nThis field is applicable only in Host mode.\nFor normal operation (to work with most LS devices), set the\ndefault value of this field to 3'h0 (2 bit times).\nThe programmable LS device inter-packet gap and turnaround\ndelays are provided to support some legacy LS devices that might\nrequire different delays than the default/fixed ones. For instance,\nthe Open LS mouse requires 3 bit times of inter-packet gap to\nwork correctly.\nInclude your PHY delays when programming the\nLSIPD/LSTRDTIM values. For example, if your PHY's TxEndDelay\nin LS mode is 30 UTMI/ULPI CLKs, then subtract this delay (~1\nLS bit time) from the device's delay requirement."
          },
          {
            "name": "LSIPD",
            "bit_range": "21:19",
            "attr": "RW",
            "reset": "0x2",
            "description": "LS Inter-Packet Time\nThis field indicates the value of Tx-to-Tx packet gap for LS\ndevices.\nThe encoding is as follows:\n0: 2 bit times\n1: 2.5 bit times\n2: 3 bit times\n3: 3.5 bit times\n4: 4 bit times\n5: 4.5 bit times\n6: 5 bit times\n7: 5.5 bit times\nNote:\nThis field is applicable only in Host mode.\nFor normal operation (to work with most LS devices), set the\ndefault value of this field to 3'h2 (3 bit times).\nThe programmable LS device inter-packet gap and turnaround\ndelays are provided to support some legacy LS devices that might\nrequire different delays than the default/fixed ones. For instance,\nthe AOpen LS mouse requires 3 bit times of inter-packet gap to\nwork correctly.\nInclude your PHY delays when programming the\nLSIPD/LSTRDTIM values. For example, if your PHY's TxEndDelay\nin LS mode is 30 UTMI/ULPI CLKs, then subtract this delay (~1\nLS bit time) from the device's delay requirement."
          },
          {
            "name": "RESERVED",
            "bit_range": "18:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "USBTRDTIM",
            "bit_range": "13:10",
            "attr": "RW",
            "reset": "0x9",
            "description": "USB 2.0 Turnaround Time\nSets the turnaround time in PHY clocks.\nSpecifies the response time for a MAC request to the Packet FIFO\nController (PFC) to fetch data from the DFIFO (SPRAM).\nThe following are the required values for the minimum SoC bus\nfrequency of 60 MHz. USB turnaround time is a critical\ncertification criteria when using long cables and five hub levels.\nThe required values for this field:\n4'h5: When the MAC interface is 16-bit UTMI+.\n4'h9: When the MAC interface is 8-bit UTMI+/ULPI.\nIf SoC bus clock is less than 60 MHz, and USB turnaround time is\nnot critical, this field can be set to a larger value.\nNote: This field is valid only in device mode."
          },
          {
            "name": "XCVRDLY",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transceiver Delay\nEnables a delay between the assertion of the UTMI/ULPI\nTransceiver Select signal (for HS) and the assertion of the TxValid\nsignal during a HS Chirp.\nWhen this bit is set to 1, a delay (of approximately 2.5 us) is\nintroduced from the time when the Transceiver Select is set to\n2'b00 (HS) to the time the TxValid is driven to 0 for sending the\nchirp-K.\nThis delay is required for some UTMI/ULPI PHYs.\nNote:\nIf you enable the hibernation feature when the device core comes\nout of power-off, you must re-initialize this bit with the\nappropriate value because the core does not save and restore\nthis bit value during hibernation.\nThis bit is valid only in device mode."
          },
          {
            "name": "ENBLSLPM",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable utmi_sleep_n and utmi_l1_suspend_n\nThe application uses this bit to control utmi_sleep_n and\nutmi_l1_suspend_n assertion to the PHY in the L1 state.\n1'b0: utmi_sleep_n and utmi_l1_suspend_n assertion from the\ncore is not transferred to the external PHY.\n1'b1: utmi_sleep_n and utmi_l1_suspend_n assertion from the\ncore is transferred to the external PHY.\nNote:\nIn Device mode - Before issuing any device endpoint command\nwhen operating in 2.0 speeds, disable this bit and enable it after\nthe command completes. Without disabling this bit, if a command\nis issued when the device is in L1 state and if mac2_clk\n(utmi_clk/ulpi_clk) is gated off, the command will not get\ncompleted."
          },
          {
            "name": "PHYSEL",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "USB 2.0 High-Speed PHY or USB 1.1 Full-Speed\n1'b0: USB 2.0 high-speed UTMI+ or ULPI PHY.\n1'b1: USB 1.1 full-speed serial transceiver."
          },
          {
            "name": "SUSPENDUSB20",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Suspend USB2.0 HS/FS/LS PHY\nWhen set, USB2.0 PHY enters Suspend mode if Suspend\nconditions are valid.\nFor DRD/OTG configurations, it is recommended that this bit is\nset to 0 during coreConsultant configuration. If it is set to 1, then\nthe application must clear this bit after power-on reset.\nApplication needs to set it to 1 after the core initialization\ncompletes.\nFor all other configurations, this bit can be set to 1 during core\nconfiguration.\nNote:\nIn host mode, on reset, this bit is set to 1. Software can override\nthis bit after reset.\nIn device mode, before issuing any device endpoint command\nwhen operating in 2.0 speeds, disable this bit and enable it after\nthe command completes. If you issue a command without\ndisabling this bit when the device is in L2 state and if mac2_clk\n(utmi_clk/ulpi_clk) is gated off, the command will not get\ncompleted."
          },
          {
            "name": "RESERVED",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ULPI_UTMI_SEL",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "ULPI or UTMI+ Select\n1'b0: UTMI+ Interface\n1'b1: ULPI Interface"
          },
          {
            "name": "PHYIF",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "PHY Interface\nIf UTMI+ is selected, the application uses this bit to configure the\ncore to support a UTMI+ PHY with an 8- or 16-bit interface.\n1'b0: 8 bits\n1'b1: 16 bits"
          },
          {
            "name": "TOUTCAL",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "HS/FS Timeout Calibration\nThe number of PHY clocks, as indicated by the application in this\nfield, is multiplied by a bit-time factor; this factor is added to the\nhigh-speed/full-speed interpacket timeout duration in the core to\naccount for additional delays introduced by the PHY. This may be\nrequired, since the delay introduced by the PHY in generating the\nlinestate condition may vary among PHYs.\nThe USB standard timeout value for high-speed operation is 736\nto 816 (inclusive) bit times. The USB standard timeout value for\nfull-speed operation is 16 to 18 (inclusive) bit times. The\napplication must program this field based on the speed of\nconnection. The number of bit times added per PHY clock are:\nHigh-speed operation:\nOne 30-MHz PHY clock = 16 bit times\nOne 60-MHz PHY clock = 8 bit times\nFull-speed operation:\nOne 30-MHz PHY clock = 0.4 bit times\nOne 60-MHz PHY clock = 0.2 bit times"
          }
        ],
        "description": "Global USB2 PHY Configuration Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GUSB3PIPECTL0",
        "offset": "0xc2c0",
        "size": "W",
        "reset": "0x010c0002",
        "bit_ranges": [
          {
            "name": "PHYSOFTRST",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB3 PHY Soft Reset\nAfter setting this bit to 1, the software needs to clear this bit."
          },
          {
            "name": "HSTPRTCMPL",
            "bit_range": "30",
            "attr": "RW",
            "reset": "0x0",
            "description": "HstPrtCmpl\nThis feature tests the PIPE PHY compliance patterns without\nhaving to have a test fixture on the USB 3.0 cable.\nThis bit enables placing the SS port link into a compliance state.\nBy default, this bit must be set to 1'b0.\nIn compliance lab testing, the SS port link enters compliance\nafter failing the first polling sequence after power on. Set this bit\nto 0, when you run compliance tests.\nThe sequence for using this functionality is as follows:\n1. Disconnect any plugged in devices.\n2. Perform USBCMD.HCRST or power-on-chip reset.\n3. Set PORTSC.PP=0.\n4. Set GUSB3PIPECTL. HstPrtCmpl=1. This places the link into\ncompliance state.\nTo advance the compliance pattern, follow this sequence (toggle\nthe set GUSB3PIPECTL. HstPrtCmpl):\n1. Set GUSB3PIPECTL.HstPrtCmpl=0.\n2. Set GUSB3PIPECTL.HstPrtCmpl=1. This advances the link to\nthe next compliance pattern.\nTo exit from the compliance state perform USBCMD.HCRST or\npower-on-chip reset."
          },
          {
            "name": "U2SSINACTP3OK",
            "bit_range": "29",
            "attr": "RW",
            "reset": "0x0",
            "description": "P3 OK for U2/SSInactive\n0: During link state U2/SS.Inactive, put PHY in P2 (Default)\n1: During link state U2/SS.Inactive, put PHY in P3.\nNote: For a port, if GUSB3PIPECTL[7]=1 and\nGUSB3PIPECTL[29]=1, set GUSB3PIPECTL[11] to 1."
          },
          {
            "name": "DISRXDETP3",
            "bit_range": "28",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disabled receiver detection in P3\n0: If PHY is in P3 and Core needs to perform receiver detection,\nThe core performs receiver detection in P3. (Default)\n1: If PHY is in P3 and Core needs to perform receiver detection,\nThe core changes the PHY power state to P2 and then performs\nreceiver detection. After receiver detection, the cores changes\nPHY power state to P3."
          },
          {
            "name": "UX_EXIT_IN_PX",
            "bit_range": "27",
            "attr": "RW",
            "reset": "0x0",
            "description": "Ux Exit in Px\n0: The core does U1/U2/U3 exit in PHY power state P0 (default\nbehavior).\n1: The core does U1/U2/U3 exit in PHY power state P1/P2/P3\nrespectively.\nThis bit is added for SS PHY workaround where SS PHY injects a\nglitch on pipe3_RxElecIdle while receiving Ux exit LFPS, and\npipe3_PowerDown change is in progress."
          },
          {
            "name": "PING_ENHANCEMENT_EN",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "Ping Enhancement Enable\nWhen set, the Downstream port U1 ping receive timeout becomes\n500 ms instead of 300 ms. Minimum Ping.LFPS receive duration\nis 8 ns (one mac3_clk). This field is valid for the downstream port\nonly."
          },
          {
            "name": "U1U2EXITFAIL_TO_RECOV",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "U1U2exitfail to Recovery\nWhen set, and U1/U2 LFPS handshake fails, the LTSSM\ntransitions from U1/U2 to Recovery instead of SS Inactive. If\nRecovery fails, then the LTSSM can enter SS.Inactive. This is an\nenhancement only. It prevents interoperability issue if the remote\nlink does not do proper handshake."
          },
          {
            "name": "REQUEST_P1P2P3",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x1",
            "description": "Always Request P1/P2/P3 for U1/U2/U3\nWhen set, the core always requests PHY power change from P0 to\nP1/P2/P3 during U0 to U1/U2/U3 transition.\nIf this bit is 0, and immediate Ux exit (remotely initiated, or\nlocally initiated) happens, the core does not request P1/P2/P3\npower state change.\nNote: This bit must be set to 1 for Synopsys PHY. For third-party\nSS PHY, check with your PHY vendor."
          },
          {
            "name": "STARTRXDETU3RXDET",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "Start Receiver Detection in U3/Rx.Detect\nIf DWC_USB3_GUSB3PIPECTL_INIT[22] is set, and the link is in\neither U3 or Rx.Detect state, the core starts receiver detection on\nthe rising edge of this bit. This can only be used for Downstream\nports. This bit must be set to 0 for Upstream ports."
          },
          {
            "name": "DISRXDETU3RXDET",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Receiver Detection in U3/Rx.Det\nWhen set, the core does not handle receiver detection in either\nU3 or Rx.Detect states. DWC_USB3_GUSB3PIPECTL_INIT[23]\nmust be used to start receiver detection manually. This bit can\nonly be used for the downstream port. This bit must be set to 0\nfor Upstream ports."
          },
          {
            "name": "DELAYP1P2P3",
            "bit_range": "21:19",
            "attr": "RW",
            "reset": "0x1",
            "description": "Delay P1P2P3\nDelay P0 to P1/P2/P3 request when entering U1/U2/U3 until\n(DWC_USB3_GUSB3PIPECTL_INIT[21:19]*8) 8B10B error\noccurs, or Pipe3_RxValid drops to 0.\nDWC_USB3_GUSB3PIPECTL_INIT[18] must be 1 to enable this\nfunctionality."
          },
          {
            "name": "DELAYP1TRANS",
            "bit_range": "18",
            "attr": "RW",
            "reset": "0x1",
            "description": "DELAYP1TRANS\nDelay PHY power change from P0 to P1/P2/P3 when link state\nchanging from U0 to U1/U2/U3 respectively.\n1'b1: When entering U1/U2/U3, delay the transition to P1/P2/P3\nuntil the pipe3 signals, Pipe3_RxElecIlde is 1 and pipe3_RxValid is\n0\n1'b0: When entering U1/U2/U3, transition to P1/P2/P3 without\nchecking for Pipe3_RxElecIlde and pipe3_RxValid."
          },
          {
            "name": "SUSPENDENABLE",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Suspend USB3.0 SS PHY\nWhen set, and if Suspend conditions are valid, the USB 3.0 PHY\nenters Suspend mode.\nFor DRD/OTG configurations, it is recommended that this bit is\nset to '0' during coreConsultant configuration. If it is set to '1',\nthen the application must clear this bit after power-on reset.\nApplication needs to set it to '1' after the core initialization is\ncompleted.\nFor all other configurations, this bit can be set to '1' during core\nconfiguration."
          },
          {
            "name": "DATWIDTH",
            "bit_range": "16:15",
            "attr": "RW",
            "reset": "0x0",
            "description": "PIPE Data Width\n2'b00: 32 bits\n2'b01: 16 bits\n2'b10: 8 bits\nNote: USB3 controller only support 32-bit width pipe interface."
          },
          {
            "name": "ABORTRXDETINU2",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Abort Rx Detect in U2\nWhen set and the link state is U2, then the core will abort\nreceiver detection if it receives U2 exit LFPS from the remote link\npartner. This bit is for the downstream port only."
          },
          {
            "name": "SKIPRXDET",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Skip Rx Detect\nWhen set, the core skips Rx Detection if pipe3_RxElecIdle is low.\nSkip is defined as waiting for the appropriate timeout, then\nrepeating the operation."
          },
          {
            "name": "LFPSP0ALGN",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "LFPS P0 Align\nWhen set:\n1. The core deasserts LFPS transmission on the clock edge that it\nrequests Phy power state 0 when exiting U1, U2, or U3 low power\nstates. Otherwise, LFPS transmission is asserted one clock\nearlier.\n2. The core requests symbol transmission two pipe3_rx_pclks\nperiods after the PHY asserts PhyStatus as a result of the PHY\nswitching from P1 or P2 state to P0 state."
          },
          {
            "name": "P3P2TRANOK",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "P3 P2 Transitions OK\nWhen set, the core transitions directly from Phy power state P2 to\nP3 or from state P3 to P2. When not set, P0 is always entered as\nan intermediate state during transitions between P2 and P3, as\ndefined in the PIPE3 Specification.\nAccording to the PIPE3 Specification, any direct transition\nbetween P3 and P2 is illegal."
          },
          {
            "name": "P3EXSIGP2",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "P3 Exit Signal in P2\nWhen this bit is set, the core always changes the PHY power state\nto P2, before attempting a U3 exit handshake."
          },
          {
            "name": "LFPSFILTER",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "LFPS Filter\nWhen set, filter LFPS reception with pipe3_RxValid in PHY power\nstate P0, that is, ignore LFPS reception from the PHY unless both\npipe3_Rxelecidle and pipe3_RxValid are deasserted."
          },
          {
            "name": "RX_DETECT_TO_POLLING_L",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX_DETECT to Polling.LFPS Control\n1'b0 (Default): Enables a 400us delay to start Polling LFPS after\nRX_DETECT. This allows VCM offset to settle to a proper level.\n1'b1: Disables the 400us delay to start Polling LFPS after\nRX_DETECT.\nDuring controller certification with third party PHY it is observed\nthat the PHY is not able to meet the Tx AC common mode voltage\nactive (VTX-CM-ACPP_ACTIVE <100mv) if the link starts polling\nwithin 80us from the time rx.detect is performed.\nTo meet this VTX-CM-ACPP_ACTIVE specification, the polling\nmust be delayed further. If the PHY does not have issue then\nthey can set this bit to 1 which allows polling to start within 80us."
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TX_SWING",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Tx Swing\nDrive the setting value to the pipe interface of PHY."
          },
          {
            "name": "TX_MARGIN",
            "bit_range": "5:3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Tx Margin[2:0]\nDrive the setting value to the pipe interface of PHY."
          },
          {
            "name": "TX_DE_EPPHASIS",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x1",
            "description": "Tx Deemphasis\nThe value driven to the PHY is controlled by the LTSSM during\nUSB3 Compliance mode."
          },
          {
            "name": "ELASTIC_BUFFER_MODE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Elastic Buffer Mode\nDrive the setting value to the pipe interface of PHY."
          }
        ],
        "description": "Global USB3 PIPE Control Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GTXFIFOSIZ0~6",
        "offset": "0xc300~\n0xc318",
        "size": "W",
        "reset": "0x00000042",
        "bit_ranges": [
          {
            "name": "TXFSTADDR_N",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Transmit FIFOn RAM Start Address\nThis field contains the memory start address for TxFIFOn in 64-\nbit words."
          },
          {
            "name": "TXFDEP_N",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0042",
            "description": "TxFIFO Depth\nThis field contains the depth of TxFIFOn in 64-bit words.\nMinimum value: 32; Maximum value: 32,768"
          }
        ],
        "description": "Global Transmit FIFO Size Register n"
      },
      {
        "type": "register",
        "name": "USB3_GRXFIFOSIZ0~2",
        "offset": "0xc380~\n0xC388",
        "size": "W",
        "reset": "0x00000285",
        "bit_ranges": [
          {
            "name": "RXFSTADDR_N",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "RxFIFOn RAM Start Address\nThis field contains the memory start address for RxFIFOn in 64-\nbit words."
          },
          {
            "name": "RXFDEP_N",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0285",
            "description": "RxFIFO Depth\nThis field contains the depth of RxFIFOn in 64-bit words.\nMinimum value: 32; Maximum value: 16,384"
          }
        ],
        "description": "Global Receive FIFO Size Register n"
      },
      {
        "type": "register",
        "name": "USB3_GEVNTADRLO0",
        "offset": "0xc400",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "EVNTADRLO",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Event Buffer Address\nHolds the lower 32 bits of start address of the external memory\nfor the Event Buffer. During operation, hardware does not update\nthis address."
          }
        ],
        "description": "Global Event Buffer Address (Low) Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GEVNTADRHI0",
        "offset": "0xc404",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "EVNTADRHI",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Event Buffer Address\nHolds the higher 32 bits of start address of the external memory\nfor the Event Buffer. During operation, hardware does not update\nthis address."
          }
        ],
        "description": "Global Event Buffer Address (High) Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GEVNTSIZ0",
        "offset": "0xc408",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "EVNTINTRPTMASK",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Event Interrupt Mask\nWhen set to '1', this prevents the interrupt from being generated.\nHowever, even when the mask is set, the events are queued."
          },
          {
            "name": "RESERVED",
            "bit_range": "30:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "EVENTSIZ",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Event Buffer Size in bytes\nHolds the size of the Event Buffer in bytes; must be a multiple of\nfour. This is programmed by software once during initialization.\nThe minimum size of the event buffer is 32 bytes."
          }
        ],
        "description": "Global Event Buffer Size Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GEVNTCOUNT0",
        "offset": "0xc40c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "EVNTCOUNT",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Event Count\nWhen read, returns the number of valid events in the Event\nBuffer (in bytes).\nWhen written, hardware decrements the count by the value\nwritten. The interrupt line remains high when count is not 0."
          }
        ],
        "description": "Global Event Buffer Count Register 0"
      },
      {
        "type": "register",
        "name": "USB3_GHWPARAMS8",
        "offset": "0xc600",
        "size": "W",
        "reset": "0x0000077c",
        "bit_ranges": [
          {
            "name": "GHWPARAMS8_32_0",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x0000077c",
            "description": "ghwparams8_32_0\nghwparams8_32_0"
          }
        ],
        "description": "Global Hardware Parameters Register 8"
      },
      {
        "type": "register",
        "name": "USB3_GTXFIFOPRIDEV",
        "offset": "0xc610",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GTXFIFOPRIDEV",
            "bit_range": "6:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Device TxFIFO priority\nThis register specifies the relative DMA priority level among the\nDevice TXFIFOs (one per IN endpoint). Each register bit[n]\ncontrols the priority (1: high, 0: low) of each TXFIFO[n]. When\nmultiple TXFIFOs compete for DMA service at a given time (that\nis, multiple TXQs contain TX DMA requests and their\ncorresponding TXFIFOs have space available), the TX DMA arbiter\ngrants access on a packet-basis in the following manner:\n1. High-priority TXFIFOs are granted access using round-robin\narbitration\n2. Low-priority TXFIFOs are granted access using round-robin\narbitration only after the high-priority TXFIFOs have no further\nprocessing to do (that is, either the TXQs are empty or the\ncorresponding TXFIFOs are full).\nFor scatter-gather packets, the arbiter grants successive DMA\nrequests to the same FIFO until the entire packet is completed.\nWhen configuring periodic IN endpoints, software must set\nregister bit[n]=1, where n is the TXFIFO assignment. This\nensures that the DMA for isochronous or interrupt IN endpoints\nare prioritized over bulk or control IN endpoints.\nThis register is present only when the core is configured to\noperate in the device mode. The register size corresponds to the\nnumber of Device IN endpoints."
          }
        ],
        "description": "Global Device TX FIFO DMA Priority Register"
      },
      {
        "type": "register",
        "name": "USB3_GTXFIFOPRIHST",
        "offset": "0xc618",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GTXFIFOPRIHST",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host TxFIFO priority\nThis register specifies the relative DMA priority level among the\nHost TXFIFOs (one per USB bus instance) within the associated\nspeed group (SS or HS/FSLS). Each register bit[n] controls the\npriority (1: high, 0: low) of TXFIFO[n] within a speed group.\nWhen multiple TXFIFOs compete for DMA service at a given time\n(i.e., multiple TXQs contain TX DMA requests and their\ncorresponding TXFIFOs have space available), the TX DMA arbiter\ngrants access on a packet-basis in the following manner:\n1. Among the FIFOs in the same speed group (SS or HS/FSLS):\na. High-priority TXFIFOs are granted access using round-robin\narbitration\nb. Low-priority TXFIFOs are granted access using round-robin\narbitration only after the high-priority TXFIFOs have no further\nprocessing to do (that is, either the TXQs are empty or the\ncorresponding TXFIFOs are full).\n2. The TX DMA arbiter prioritizes the SS speed group or HS/FSLS\nspeed group according to the ratio programmed in the\nGDMAHLRATIO register.\nFor scatter-gather packets, the arbiter grants successive DMA\nrequests to the same FIFO until the entire packet is completed.\nThis register is present only when the core is configured to\noperate in the host mode (includes DRD and OTG modes). The\nregister size corresponds to the number of configured USB bus\ninstances; for example, in the default configuration, there are 3\nUSB bus instances (1 SS, 1 HS, and 1 FSLS)."
          }
        ],
        "description": "Global Host TX FIFO DMA Priority Register"
      },
      {
        "type": "register",
        "name": "USB3_GRXFIFOPRIHST",
        "offset": "0xc61c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GRXFIFOPRIHST",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host RxFIFO priority\nThis register specifies the relative DMA priority level among the\nHost RXFIFOs (one per USB bus instance) within the associated\nspeed group (SS or HS/FSLS). Each register bit[n] controls the\npriority (1: high, 0: low) of RXFIFO[n] within a speed group.\nWhen multiple RXFIFOs compete for DMA service at a given time\n(i.e., multiple RXQs contain RX DMA requests and their\ncorresponding RXFIFOs have data available), the RX DMA arbiter\ngrants access on a packet-basis in the following manner:\n1. Among the FIFOs in the same speed group (SS or HS/FSLS):\na. High-priority RXFIFOs are granted access using round-robin\narbitration\nb. Low-priority RXFIFOs are granted access using round-robin\narbitration only after high-priority RXFIFOs have no further\nprocessing to do (that is, either the RXQs are empty or the\ncorresponding RXFIFOs do not have the required data).\n2. The RX DMA arbiter prioritizes the SS speed group or HS/FSLS\nspeed group according to the ratio programmed in the\nGDMAHLRATIO register.\nFor scatter-gather packets, the arbiter grants successive DMA\nrequests to the same FIFO until the entire packet is completed.\nThis register is present only when the core is configured to\noperate in the host mode (includes DRD and OTG modes). The\nregister size corresponds to the number of configured USB bus\ninstances; for example, in the default configuration, there are 3\nUSB bus instances (1 SS, 1 HS, and 1 FSLS)."
          }
        ],
        "description": "Global Host RX FIFO DMA Priority Register"
      },
      {
        "type": "register",
        "name": "USB3_GFIFOPRIDBC",
        "offset": "0xc620",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GFIFOPRIDBC",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host DbC DMA priority\nThis register specifies the relative priority of the RXFIFOs and\nTXFIFOs associated with the DbC mode. It overrides the priority\nassigned in the corresponding indexes of the Host RXFIFO and\nTXFIFO DMA priority registers, when the DbC mode is enabled.\nPriority settings are specified in relation to the low-priority SS\nspeed group:\n1. Normal priority indicates that the DbC FIFOs are considered\nidentical to the Host SS low-priority FIFOs.\n2. Low priority indicates that the DbC FIFOs are considered to\nhave lower priority than all Host SS FIFOs.\n3. High priority indicates that the DbC FIFOs are considered\nhigher priority than the Host SS low-priority FIFOs but lower\npriority than the Host SS high-priority FIFOs.\nThis register is present only when the core is configured to\noperate in Host Debug Capability (DbC) mode."
          }
        ],
        "description": "Global Host Debug Capability DMA Priority Register"
      },
      {
        "type": "register",
        "name": "USB3_GDMAHLRATIO",
        "offset": "0xc624",
        "size": "W",
        "reset": "0x00000008",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HSTRXFIFO",
            "bit_range": "12:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Host RXFIFO DMA High-Low Priority\nThis register specifies the relative priority of the SS FIFOs with\nrespect to the HS/FSLS FIFOs. The DMA arbiter prioritizes the\nHS/FSLS round-robin arbiter group every DMA High-Low Priority\nRatio grants as indicated in the register separately for TX and RX.\nTo illustrate, consider that all FIFOs are requesting access\nsimultaneously, and the ratio is 4. SS gets priority for 4 packets,\nHS/FSLS gets priority for 1 packet, SS gets priority for 4 packets,\nHS/FSLS gets priority for 1 packet, and so on.\nIf FIFOs from both speed groups are not requesting access\nsimultaneously then,\n1. if SS got grants 4 out of the last 4 times, then HS/FSLS get the\npriority on any future request.\n2. if HS/FSLS got the grant last time, SS gets the priority on the\nnext request.\n3. if there is a valid request on either SS or HS/FSLS, a grant is\nalways awarded; there is no idle.\nThis register is present if the core is configured to operate in host\nmode."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HSTTXFIFO",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x08",
            "description": "Host TXFIFO DMA High-Low Priority\nThis register specifies the relative priority of the SS FIFOs with\nrespect to the HS/FSLS FIFOs. The DMA arbiter prioritizes the\nHS/FSLS round-robin arbiter group every DMA High-Low Priority\nRatio grants as indicated in the register separately for TX and RX.\nTo illustrate, consider that all FIFOs are requesting access\nsimultaneously, and the ratio is 4. SS gets priority for 4 packets,\nHS/FSLS gets priority for 1 packet, SS gets priority for 4 packets,\nHS/FSLS gets priority for 1 packet, and so on.\nIf FIFOs from both speed groups are not requesting access\nsimultaneously then,\n1. if SS got grants 4 out of the last 4 times, then HS/FSLS get the\npriority on any future request.\n2. if HS/FSLS got the grant last time, SS gets the priority on the\nnext request.\n3. if there is a valid request on either SS or HS/FSLS, a grant is\nalways awarded; there is no idle.\nThis register is present if the core is configured to operate in host\nmode."
          }
        ],
        "description": "Global Host FIFO DMA High-Low Priority Ratio Register"
      },
      {
        "type": "register",
        "name": "USB3_GFLADJ",
        "offset": "0xc630",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GFLADJ_REFCLK_240MHZDECR_PLS1",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "GFLADJ_REFCLK_240MHZDECR_PLS1\nThis field indicates that the decrement value that the controller\napplies for each ref_clk must be GFLADJ_REFCLK_240MHZ_DECR\nand GFLADJ_REFCLK_240MHZ_DECR +1 alternatively on each\nref_clk.\nSet this bit to a 1 only if GFLADJ_REFCLK_LPM_SEL is set to 1\nand the fractional component of 240/ref_frequency is greater\nthan or equal to 0.5.\nExamples:\nIf the ref_clk is 24 MHz then\n1. GUCTL.REF_CLK_PERIOD = 41\n2. GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10\n3. GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 0"
          },
          {
            "name": "GFLADJ_REFCLK_240MHZ_DECR",
            "bit_range": "30:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "GFLADJ_REFCLK_240MHZ_DECR\nThis field indicates the decrement value that the controller applies\nfor each ref_clk in order to derive a frame timer in terms of a\n240-MHz clock.\nThis field must be programmed to a non-zero value only if\nGFLADJ_REFCLK_LPM_SEL is set to 1.\nThe value is derived as follows:\nGFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency\nExamples: If the ref_clk is 24 MHz then\n1. GUCTL.REF_CLK_PERIOD = 41\n2. GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10"
          },
          {
            "name": "GFLADJ_REFCLK_LPM_SEL",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "GFLADJ_REFCLK_LPM_SEL\nThis bit enables the functionality of running SOF/ITP counters on\nthe ref_clk. This bit must not be set to 1 if GCTL.SOFITPSYNC bit\nis set to 1. Similarly, if GFLADJ_REFCLK_LPM_SEL set to 1,\nGCTL.SOFITPSYNC must not be set to 1.\nWhen GFLADJ_REFCLK_LPM_SEL is set to 1 the overloading of\nthe suspend control of the USB 2.0 first port PHY (UTMI/ULPI)\nwith USB 3.0 port states is removed.\nNote that the ref_clk frequencies supported in this mode are\n16/17/19.2/20/24/39.7/40 MHz. The utmi_clk[0] signal of the\ncore must be connected to the FREECLK of the PHY.\nNote: If you set this bit to 1, the\nGUSB2PHYCFG.U2_FREECLK_EXISTS bit must be set to 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GFLADJ_REFCLK_FLADJ",
            "bit_range": "21:8",
            "attr": "RW",
            "reset": "0x0000",
            "description": "GFLADJ_REFCLK_FLADJ\nThis field indicates the frame length adjustment to be applied\nwhen SOF/ITP counter is running on the ref_clk.\nThis register value is used to adjust the ITP interval when\nGCTL[SOFITPSYNC] is set to 1; SOF and ITP interval when\nGLADJ.GFLADJ_REFCLK_LPM_SEL is set to 1.\nThis field must be programmed to a non-zero value only if\nGFLADJ_REFCLK_LPM_SEL is set to 1 or GCTL.SOFITPSYNC is set\nto 1.\nThe value is derived as follows:\nFLADJ_REF_CLK_FLADJ=((125000/ref_clk_period_integer)-\n(125000/ref_clk_period)) * ref_clk_period where:\n1. The ref_clk_period_integer is the integer value of the ref_clk\nperiod got by truncating the decimal (fractional) value that is\nprogrammed in the GUCTL.REF_CLK_PERIOD field.\n2. The ref_clk_period is the ref_clk period including the fractional\nvalue.\nExamples: If the ref_clk is 24 MHz then\n1. GUCTL.REF_CLK_PERIOD = 41\n2. GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/41)-\n(125000/41.6666))*41.6666 = 2032 (ignoring the fractional\nvalue)"
          },
          {
            "name": "GFLADJ_30MHZ_SDBND_SEL",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "GFLADJ_30MHZ_SDBND_SEL\nThis field selects whether to use the input signal fladj_30mhz_reg\nor the GFLADJ.GFLADJ_30MHZ to adjust the frame length for the\nSOF/ITP. When this bit is set to:\n1, the controller uses the register field GFLADJ.GFLADJ_30MHZ\nvalue\n0, the controller uses the input signal fladj_30mhz_reg value"
          },
          {
            "name": "RESERVED",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GFLADJ_30MHZ",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "GFLADJ_30MHZ\nThis field indicates the value that is used for frame length\nadjustment instead of considering from the sideband input signal\nfladj_30mhz_reg.\nThis enables post-silicon frame length adjustment in case the\ninput signal fladj_30mhz_reg is connected to a wrong value or is\nnot valid.\nFor details on how to set this value, refer to section 5.2.4,\n\"Frame Length Adjustment Register (FLADJ),\" of the xHCI\nSpecification."
          }
        ],
        "description": "Global Frame Length Adjustment Register"
      },
      {
        "type": "register",
        "name": "USB3_DCFG",
        "offset": "0xc700",
        "size": "W",
        "reset": "0x00080004",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "IGNSTRMPP",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "IgnoreStreamPP\nThis bit only affects stream-capable bulk endpoints.\nWhen this bit is set to 0 and the controller receives a Data Packet\nwith the Packet Pending (PP) bit set to 0 for OUT endpoints, or it\nreceives an ACK with the NumP field set to 0 and PP set to 0 for\nIN endpoints, the core attempts to search for another stream\n(CStream) to initiate to the host. However, there are two\nsituations where this behavior is not optimal:\n1. When the host is setting PP=0 even though it has not finished\nthe stream, or\n2. When the endpoint on the device is configured with one\ntransfer resource and therefore does not have any other streams\nto initiate to the host.\nWhen this bit is set to 1, the core ignores the Packet Pending bit\nfor the purposes of stream selection and does not search for\nanother stream when it receives DP(PP=0) or ACK(NumP=0,\nPP=0). This can enhance the performance when the device\nsystem bus bandwidth is low or the host responds to the core's\nERDY transmission very quickly."
          },
          {
            "name": "LPMCAP",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "LPM Capable\nThe application uses this bit to control the DWC_usb3 core LPM\ncapabilities. If the core operates as a non-LPM-capable device, it\ncannot respond to LPM transactions.\n1'b0: LPM capability is not enabled.\n1'b1: LPM capability is enabled."
          },
          {
            "name": "NUMP",
            "bit_range": "21:17",
            "attr": "RW",
            "reset": "0x04",
            "description": "Number of Receive Buffers.\nThis bit indicates the number of receive buffers to be reported in\nthe ACK TP.\nThe DWC_usb3 controller uses this field if\nGRXTHRCFG.USBRxPktCntSel is set to 0. The application can\nprogram this value based on RxFIFO size, buffer sizes\nprogrammed in descriptors, and system latency.\nFor an OUT endpoint, this field controls the number of receive\nbuffers reported in the NumP field of the ACK TP transmitted by\nthe core.\nNote: This bit is used in host mode when Debug Capability is\nenabled."
          },
          {
            "name": "INTRNUM",
            "bit_range": "16:12",
            "attr": "RW",
            "reset": "0x00",
            "description": "Interrupt number\nIndicates interrupt/EventQ number on which non-endpoint-\nspecific device-related interrupts (see DEVT) are generated."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DEVADDR",
            "bit_range": "9:3",
            "attr": "RW",
            "reset": "0x00",
            "description": "Device Address.\nThe application must perform the following:\n1. Program this field after every SetAddress request.\n2. Reset this field to zero after USB reset."
          },
          {
            "name": "DEVSPD",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x4",
            "description": "Device Speed\nIndicates the speed at which the application requires the core to\nconnect, or the maximum speed the application can support.\nHowever, the actual bus speed is determined only after the chirp\nsequence is completed, and is based on the speed of the USB\nhost to which the core is connected.\n3'b100: SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz)\n3'b000: High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)\n3'b001: Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)"
          }
        ],
        "description": "Device Configuration Register"
      },
      {
        "type": "register",
        "name": "USB3_DCTL",
        "offset": "0xc704",
        "size": "W",
        "reset": "0x00f00000",
        "bit_ranges": [
          {
            "name": "RUN_STOP",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Run/Stop\nThe software writes 1 to this bit to start the device controller\noperation.\nTo stop the device controller operation, the software must\nremove any active transfers and write 0 to this bit. When the\ncontroller is stopped, it sets the DSTS.DevCtrlHlt bit when the\ncore is idle and the lower layer finishes the disconnect process.\nThe Run/Stop bit must be used in following cases as specified:\n1. After power-on reset and CSR initialization, the software must\nwrite 1 to this bit to start the device controller. The controller\ndoes not signal connect to the host until this bit is set.\n2. The software uses this bit to control the device controller to\nperform a soft disconnect. When the software writes 0 to this bit,\nthe host does not see that the device is connected. The device\ncontroller stays in the disconnected state until the software writes\n1 to this bit.\nThe minimum duration of keeping this bit cleared is specified in\nthe Note below. If the software attempts a connect after the soft\ndisconnect or detects a disconnect event, it must set DCTL[8:5]\nto 5 before reasserting the Run/Stop bit.\n3. When the USB or Link is in a lower power state and the Two\nPower Rails configuration is selected, software writes 0 to this bit\nto indicate that it is going to turn off the Core Power Rail. After\nthe software turns on the Core Power Rail again and re-initializes\nthe device controller, it must set this bit to start the device\ncontroller.\nNote: The following is the minimum duration under various\nconditions for which the soft disconnect (SftDiscon) bit must be\nset for the USB host to detect a device disconnect:\n30ms: For SuperSpeed, when the device state is Suspended,\nIdle, Transmit, or Receive.\n10ms: For high-speed, when the device state is Suspended, Idle,\nor not Idle/Suspended (performing transactions); For full-\nspeed/low-speed, when the device state is Suspended, Idle, or\nnot Idle/Supended (performing transactions)\nTo accommodate clock jitter, it is recommended that the\napplication add extra delay to the specified minimum duration."
          },
          {
            "name": "CSFTRST",
            "bit_range": "30",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Core Soft Reset\nReset all clock domains as follows:\n1. This bit clears the interrupts and all the CSRs except GSTS,\nGSNPSID, GGPIO, GUID, GUSB2PHYCFGn registers,\nGUSB3PIPECTLn registers, DCFG, DCTL, DEVTEN, and DSTS\nregisters.\n2. All module state machines (except the SoC Bus Slave Unit) are\nreset to the IDLE state, and all the TxFIFOs and the RxFIFO are\nflushed.\n3. Any transactions on the SoC bus Master are terminated as\nsoon as possible, after gracefully completing the last data phase\nof a SoC bus transfer. Any transactions on the USB are\nterminated immediately.\nThe application can write this bit at any time to reset the core.\nThis is a self-clearing bit; the core clears this bit after all\nnecessary logic is reset in the core, which may take several\nclocks depending on the core's current state. Once this bit is\ncleared, the software must wait at least 3 PHY clocks before\naccessing the PHY domain (synchronization delay).\nTypically, software reset is used during software development\nand also when you dynamically change the PHY selection bits in\nthe USB configuration registers listed above. When you change\nthe PHY, the corresponding clock for the PHY is selected and used\nin the PHY domain. Once a new clock is selected, the PHY domain\nmust be reset for proper operation."
          },
          {
            "name": "RESERVED",
            "bit_range": "29",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HIRDTHRES",
            "bit_range": "28:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "HIRD Threshold\nThe core asserts output signals utmi_l1_suspend_n and\nutmi_sleep_n on the basis of this signal:\nThe core asserts utmi_l1_suspend_n to put the PHY into Deep\nLow-Power mode in L1 when both of the following are true:\n1. HIRD value is greater than or equal to the value in\nDCTL.HIRD_Thres[3:0]\n2. HIRD_Thres[4] is set to 1'b1.\nThe core asserts utmi_sleep_n on L1 when one of the following is\ntrue:\n1. If the HIRD value is less than HIRD_Thres[3:0] or\n2. HIRD_Thres[4] is set to 1'b0.\nNote: This field must be set to '0' during SuperSpeed mode of\noperation."
          },
          {
            "name": "LPM_NYET_THRES",
            "bit_range": "23:20",
            "attr": "RW",
            "reset": "0xf",
            "description": "LPM NYET Threshold\nHandshake response to LPM token specified by device application.\nResponse depends on DCFG.LPMCap.\nDCFG.LPMCap is 1'b0 - The core always responds with Timeout\n(that is, no response).\nDCFG.LPMCap is 1'b1 - The core responds with an ACK on\nsuccessful LPM transaction, which requires that all of the\nfollowing are satisfied:\n1. There are no PID or CRC5 errors in both the EXT token and the\nLPM token (if not true, inactivity results in a timeout ERROR).\n2. No data is pending in the Transmit FIFO and OUT endpoints\nnot in flow controlled state (else NYET).\n3. The BESL value in the LPM token is less than or equal to\nLPM_NYET_thres[3:0]"
          },
          {
            "name": "KEEPCONNECT",
            "bit_range": "19",
            "attr": "RW",
            "reset": "0x0",
            "description": "KeepConnect\nWhen 1, this bit enables the save and restore programming\nmodel by preventing the core from disconnecting from the host\nwhen DCTL.RunStop is set to 0. It also enables the Hibernation\nRequest Event to be generated when the link goes to U3 or L2.\nThe device core disconnects from the host when DCTL.RunStop is\nset to 0.\nThis bit indicates whether to preserve this behavior (0), or if the\ncore must not disconnect when RunStop is set to 0 (1).\nThis bit also prevents the LTSSM from automatically going to\nU0/L0 when the host requests resume from U3/L2."
          },
          {
            "name": "L1HIBERNATIONEN",
            "bit_range": "18",
            "attr": "RW",
            "reset": "0x0",
            "description": "L1HibernationEn\nWhen this bit is set along with KeepConnect, the device core\ngenerates a Hibernation Request Event if L1 is enabled and the\nHIRD value in the LPM token is larger than the threshold\nprogrammed in DCTL.HIRD_Thres.\nThe core does not exit the LPM L1 state until software writes\nRecovery into the DCTL.ULStChngReq field.\nThis prevents corner cases where the device is entering\nhibernation at the same time the host is attempting to exit L1."
          },
          {
            "name": "CRS",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Controller Restore State\nThis command is similar to the USBCMD.CRS bit in host mode\nand initiates the restore process. When software sets this bit to 1,\nthe controller immediately sets DSTS.RSS to 1. When the\ncontroller has finished the restore process, it sets DSTS.RSS to 0.\nNote: When read, this field always returns 0."
          },
          {
            "name": "CSS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Controller Save State\nThis command is similar to the USBCMD.CSS bit in host mode\nand initiates the save process. When software sets this bit to 1,\nthe controller immediately sets DSTS.SSS to 1. When the\ncontroller has finished the save process, it sets DSTS.SSS to 0.\nNote: When read, this field always returns 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INITU2ENA",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Initiate U2 Enable\n1'b0: May not initiate U2 (default)\n1'b1: May initiate U2\nOn USB reset, hardware clears this bit to 0. Software sets this bit\nafter receiving SetFeature(U2_ENABLE), and clears this bit when\nClearFeature(U2_ENABLE) is received.\nIf DCTL[11] (AcceptU2Ena) is 0, the link immediately exits U2\nstate."
          },
          {
            "name": "ACCEPTU2ENA",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Accept U2 Enable\n1'b0: Reject U2 except when Force_LinkPM_Accept bit is set\n(default)\n1'b1: Core accepts transition to U2 state if nothing is pending on\nthe application side.\nOn USB reset, hardware clears this bit to 0. Software sets this bit\nafter receiving a SetConfiguration command."
          },
          {
            "name": "INITU1ENA",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Initiate U1 Enable\n1'b0: May not initiate U1 (default);\n1'b1: May initiate U1.\nOn USB reset, hardware clears this bit to 0. Software sets this bit\nafter receiving SetFeature(U1_ENABLE), and clears this bit when\nClearFeature(U1_ENABLE) is received.\nIf DCTL[9] (AcceptU1Ena) is 0, the link immediately exits U1\nstate."
          },
          {
            "name": "ACCEPTU1ENA",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Accept U1 Enable\n1'b0: Core rejects U1 except when Force_LinkPM_Accept bit is set\n(default)\n1'b1: Core accepts transition to U1 state if nothing is pending on\nthe application side.\nOn USB reset, hardware clears this bit to 0. Software sets this bit\nafter receiving a SetConfiguration command."
          },
          {
            "name": "ULSTCHNGREQ",
            "bit_range": "8:5",
            "attr": "RW",
            "reset": "0x0",
            "description": "ULSTCHNGREQ\nSoftware writes this field to issue a USB/Link state change\nrequest. A change in this field indicates a new request to the\ncore.\nIf software wants to issue the same request back-to-back, it must\nwrite a 0 to this field between the two requests. The result of the\nstate change request is reflected in the USB/Link State in DSTS.\nThese bits are self-cleared on the MAC Layer exiting suspended\nstate.\nIf software is updating other fields of the DCTL register and not\nintending to force any link state change, then it must write a 0 to\nthis field.\nSS Compliance mode is normally entered and controlled by the\nremote link partner. Refer to the USB 3.0 specification.\nAlternatively, you can force the local link directly into compliance\nmode, by resetting the SS link with the RUN/STOP bit set to zero.\nIf you then write 10 to the USB/Link State Change field and 1 to\nRUN/STOP, the link goes to compliance mode.\nOnce you are in compliance, you may alternately write zero and\n10 to this field to advance the compliance pattern.\nIn SS mode:\nValue: Requested Link State Transition/Action\n0: No Action\n4: SS.Disabled\n5: Rx.Detect\n6: SS.Inactive\n8: Recovery\n10: Compliance\nOthers: Reserved\nIn HS/FS/LS mode:\nValue:Requested USB state transition\n8: Remote wakeup request\nOthers: Reserved\nThe Remote wakeup request must be issued 2us after the device\ngoes into suspend state (DSTS[21:18] is 3 ).\nNote: After coming out of hibernation, software must write 8\n(Recovery) into this field to confirm exit from the suspended\nstate."
          },
          {
            "name": "TSTCTL",
            "bit_range": "4:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Test Control\n4'b000: Test mode disabled\n4'b001: Test_J mode\n4'b010: Test_K mode\n4'b011: Test_SE0_NAK mode\n4'b100: Test_Packet mode\n4'b101: Test_Force_Enable\nOthers: Reserved"
          },
          {
            "name": "RESERVED",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Device Control Register"
      },
      {
        "type": "register",
        "name": "USB3_DEVTEN",
        "offset": "0xc708",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VENDEVTSTRCVDEN",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Vendor Device Test LMP Received Event\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ERRTICERREVTEN",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Erratic Error Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "RESERVED",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SOFTEVTEN",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Start of (u)frame Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "U3L2L1SUSPEN",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "U3/L2-L1 Suspend Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "HIBERNATIONREQEVTEN",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hibernation Request Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "WKUPEVTEN",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Resume/Remote Wakeup Detected Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "ULSTCNGEN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB/Link State Change Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "CONNECTDONEEVTEN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Connection Done Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "USBRSTEVTEN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "USB Reset Event Enable\n1: Enable this event\n0: Disable this event"
          },
          {
            "name": "DISSCONNEVTEN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disconnect Detected Event Enable\n1: Enable this event\n0: Disable this event"
          }
        ],
        "description": "Device Event Enable Register"
      },
      {
        "type": "register",
        "name": "USB3_DSTS",
        "offset": "0xc70c",
        "size": "W",
        "reset": "0x00500004",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DCNRD",
            "bit_range": "29",
            "attr": "RO",
            "reset": "0x0",
            "description": "Device Controller Not Ready\nThe bit indicates that the core is in the process of completing the\nstate transitions after exiting from hibernation.\nTo complete the state transitions, it takes 256 bus clock cycles\nfrom the time DCTL[31].Run/Stop is set. During hibernation, if\nthe UTMI/ULPI PHY is in suspended state, then the 256-bus clock\ncycle delay starts after the PHY exited suspended state. Software\nmust set DCTL[31].Run/Stop to 1 and wait for this bit to be de-\nasserted to zero before processing DSTS.USBLnkSt."
          },
          {
            "name": "RESERVED",
            "bit_range": "28:26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RSS",
            "bit_range": "25",
            "attr": "RO",
            "reset": "0x0",
            "description": "RSS Restore State Status\nThis bit is similar to the USBSTS.RSS in host mode.\nWhen the controller finishes the restore process, it completes the\ncommand by setting DSTS.RSS to 0."
          },
          {
            "name": "SSS",
            "bit_range": "24",
            "attr": "RO",
            "reset": "0x0",
            "description": "SSS Save State Status\nThis bit is similar to the USBSTS.SSS in host mode.\nWhen the controller has finished the save process, it completes\nthe command by setting DSTS.SSS to 0."
          },
          {
            "name": "COREIDLE",
            "bit_range": "23",
            "attr": "RO",
            "reset": "0x0",
            "description": "Core Idle\nThe bit indicates that the core finished transferring all RxFIFO\ndata to system memory, writing out all completed descriptors,\nand all Event Counts are zero.\nNote: While testing for Reset values, mask out the read value.\nThis bit represents the changing state of the core and does not\nhold a static value."
          },
          {
            "name": "DEVCTRLHLT",
            "bit_range": "22",
            "attr": "RO",
            "reset": "0x1",
            "description": "Device Controller Halted\nThis bit is set to 0 when the Run/Stop bit in the DCTL register is\nset to 1.\nThe core sets this bit to 1 when, after SW sets Run/Stop to 0, the\ncore is idle and the lower layer finishes the disconnect process.\nWhen Halted=1, the core does not generate Device events.\nNote: The core does not set this bit to 1 if GEVNTCOUNTn has\nsome valid value. Software needs to acknowledge the events that\nare generated (by writing to GEVNTCOUNTn) while it is waiting\nfor this bit to be set to 1."
          },
          {
            "name": "USBLNKST",
            "bit_range": "21:18",
            "attr": "RO",
            "reset": "0x4",
            "description": "USBLNKST\nSS mode: LTSSM State\n4'h0: U0\n4'h1: U1\n4'h2: U2\n4'h3: U3\n4'h5: RX_DET\n4'h6: SS_INACT\n4'h7: POLL\n4'h8: RECOV\n4'h9: HRESET\n4'ha: CMPLY\n4'hb: LPBK\n4'hf: Resume/Reset\nIn HS/FS/LS mode:\n4'h0: On state\n4'h2: Sleep (L1) state\n4'h3: Suspend (L2) state\n4'h4: Disconnected state (Default state)\n4'h5: Early Suspend state (valid only when Hibernation is\ndisabled, GCTL[1].GblHibernationEn = 0)\n4'he: Reset (valid only when Hibernation is enabled,\nGCTL[1].GblHibernationEn = 1)\n4'hf: Resume (valid only when Hibernation is enabled,\nGCTL[1].GblHibernationEn = 1)\nThe link state Resume/Reset indicates that the core received a\nresume or USB reset request from the host while the link was in\nhibernation. Software must write 8 (Recovery) to the\nDCTL.ULStChngReq field to acknowledge the resume/reset\nrequest.\nWhen Hibernation is enabled, GCTL[1].GblHibernationEn = 1, this\nfield USBLnkSt is valid only when DCTL[31].Run/Stop set to 1\nand DSTS[29].DCNRD = 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "17:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CONNECTSPD",
            "bit_range": "2:0",
            "attr": "RU",
            "reset": "0x4",
            "description": "Connected Speed\nIndicates the speed at which the DWC_usb3 core has come up\nafter speed detection through a chirp sequence.\n3'b100: SuperSpeed (PHY clock is running at 125 or 250 MHz)\n3'b000: High-speed (PHY clock is running at 30 or 60 MHz)\n3'b001: Full-speed (PHY clock is running at 30 or 60 MHz)"
          }
        ],
        "description": "Device Status Register"
      },
      {
        "type": "register",
        "name": "USB3_DGCMDPAR",
        "offset": "0xc710",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PARAMETER",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "PARAMETER\nThis register indicates the device command parameter. This must\nbe programmed before or along with the device command. The\navailable device commands are listed in DGCMD register."
          }
        ],
        "description": "Device Generic Command Parameter Register"
      },
      {
        "type": "register",
        "name": "USB3_DGCMD",
        "offset": "0xc714",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDSTATUS",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "Command Status\n1: CmdErr: Indicates that the device controller encountered an\nerror while processing the command.\n0: Indicates command success"
          },
          {
            "name": "RESERVED",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDACT",
            "bit_range": "10",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Command Active\nThe software sets this bit to 1 to enable the device controller to\nexecute the generic command.\nThe device controller sets this bit to 0 after executing the\ncommand."
          },
          {
            "name": "RESERVED",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDIOC",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Interrupt on Complete\nWhen this bit is set, the device controller issues a Generic\nCommand Completion event after executing the command.\nNote that this interrupt is mapped to DCFG.IntrNum.\nNote: This field must not set to 1 if the DCTL.RunStop field is 0."
          },
          {
            "name": "CMDTYP",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Command Type\nSpecifies the type of command the software driver is requesting\nthe core to perform.\n00h: Reserved\n01h: Set Endpoint Configuration - 64 or 96-bit Parameter\n02h: Set Endpoint Transfer Resource Configuration - 32-bit\nParameter\n03h: Get Endpoint State - No Parameter Needed\n05h: Clear Stall (see Set Stall) - No Parameter Needed\n06h: Start Transfer - 64-bit Parameter\n07h: Update Transfer - No Parameter Needed\n08h: End Transfer - No Parameter Needed\n09h: Start New Configuration - No Parameter Needed"
          }
        ],
        "description": "Device Generic Command Register"
      },
      {
        "type": "register",
        "name": "USB3_DALEPENA",
        "offset": "0xc720",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "USBACTEP",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "USB Active Endpoints\nThis field indicates if a USB endpoint is active in the current\nconfiguration and interface. It applies to USB IN endpoints 0~15\nand OUT endpoints 0~15, with one bit for each of the 32 possible\nendpoints. Even numbers are for USB OUT endpoints, and odd\nnumbers are for USB IN endpoints, as follows:\nBit[0]: USB EP0-OUT\nBit[1]: USB EP0-IN\nBit[2]: USB EP1-OUT\nBit[3]: USB EP1-IN\n...\nThe entity programming this register must set bits 0 and 1\nbecause they enable control endpoints that map to physical\nendpoints (resources) after USBReset.\nHardware clears these bits for all endpoints (other than EP0-OUT\nand EP0-IN) after detecting a USB reset event. After receiving\nSetConfiguration and SetInterface requests, the application must\nprogram endpoint registers accordingly and set these bits.\nFor more information, Pls see \"Flexible Endpoint Mapping\"\nsection."
          }
        ],
        "description": "Device Active USB Endpoint Enable Register"
      },
      {
        "type": "register",
        "name": "USB3_DEPnCMDPAR2",
        "offset": "0xc800~\n0xc8c0",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PARAMETER",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "PARAMETER\nThis register indicates the physical endpoint command Parameter\n2. It must be programmed before issuing the command."
          }
        ],
        "description": "Device Physical Endpoint-n Command Parameter 2 Register"
      },
      {
        "type": "register",
        "name": "USB3_DEPnCMDPAR1",
        "offset": "0xc804~\n0xc8c4",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PARAMETER",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "PARAMETER\nThis register indicates the physical endpoint command Parameter\n1. It must be programmed before issuing the command."
          }
        ],
        "description": "Device Physical Endpoint-n Command Parameter 1 Register"
      },
      {
        "type": "register",
        "name": "USB3_DEPnCMDPAR0",
        "offset": "0xc808~\n0xc8c8",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PARAMETER",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "PARAMETER\nThis register indicates the physical endpoint command Parameter\n0. It must be programmed before issuing the command."
          }
        ],
        "description": "Device Physical Endpoint-n Command Parameter 0 Register"
      },
      {
        "type": "register",
        "name": "USB3_DEPnCMD",
        "offset": "0xc80c~\n0xc8cc",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "COMMANDPARAM",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Command Parameters or Event Parameters\nwhen this register is written:\nFor Start Transfer command: The 16-bit StreamID assigned to\nthis transfer\nFor Start Transfer command applied to an isochronous endpoint:\nStartMicroFramNum, Indicates the (micro)frame number to which\nthe first TRB applies.\nFor Update Transfer, End Transfer, and Start New Configuration\ncommands: [22:16]: Transfer Resource Index (XferRscIdx). The\nhardware-assigned transfer resource index for the transfer, which\nwas returned in response to the Start Transfer command. The\napplication software-assigned transfer resource index for a Start\nNew Configuration command.\nEvent Parameters (EventParam), when this register is read.\nPlease see bits [31:16] in the \"Device Endpoint-n Events:\nDEPEVT\" of the Databook."
          },
          {
            "name": "CMDSTATUS",
            "bit_range": "15:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Completion Status\nThe information is in the same format as bits 15:12 of the\nEndpoint Command Complete event, Please see \"Device\nEndpoint-n Events: DEPEVT\" in the Databook."
          },
          {
            "name": "HIPRI_FORCERM",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "HighPriority/ForceRM\nHighPriority: Only valid for Start Transfer command\nForceRM: Only valid for End Transfer command\nClearPendIN: Only valid for Clear Stall command . Software sets\nthis bit to clear any pending IN transaction (on that endpoint)\nstuck at the lower layers when a Clear Stall command is issued."
          },
          {
            "name": "CMDACT",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Active\nSoftware sets this bit to 1 to enable the device endpoint\ncontroller to execute the generic command.\nThe device controller sets this bit to 0 when the CmdStatus field\nis valid and the endpoint is ready to accept another command.\nThis does not imply that all the effects of the previously-issued\ncommand have taken place."
          },
          {
            "name": "RESERVED",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDIOC",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Interrupt on Complete\nWhen this bit is set, the device controller issues a generic\nEndpoint Command Complete event after executing the\ncommand.\nNote that this interrupt is mapped to DEPCFG.IntrNum.\nWhen the DEPCFG command is executed, the command interrupt\non completion goes to the interrupt pointed by the\nDEPCFG.IntrNum in the current command.\nNote: This field must not set to 1 if the DCTL.RunStop field is 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDTYP",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Type\nSpecifies the type of command the software driver is requesting\nthe core to perform.\n00h: Reserved\n01h: Set Endpoint Configuration - -64 or 96-bit Parameter\n02h: Set Endpoint Transfer Resource Configuration - 32-\nbitparameter\n03h: Get Endpoint State - No Parameter Needed\n04h: Set Stall - No Parameter Needed\n05h: Clear Stall (see Set Stall) - No Parameter Needed\n06h: Start Transfer - 64-bit Parameter\n07h: Update Transfer - No Parameter Needed\n08h: End Transfer - No Parameter Needed\n09h: Start New Configuration - No Parameter Needed"
          }
        ],
        "description": "Device Physical Endpoint-n Command Register"
      }
    ],
    "name": "USB3",
    "summary": [
      {
        "name": "USB3_GSBUSCFG0",
        "offset": "0xc100",
        "size": "W",
        "reset": "0x00000001",
        "description": "Global SoC Bus Configuration Register 0"
      },
      {
        "name": "USB3_GSBUSCFG1",
        "offset": "0xc104",
        "size": "W",
        "reset": "0x00000300",
        "description": "Global SoC Bus Configuration Register 1"
      },
      {
        "name": "USB3_GTXTHRCFG",
        "offset": "0xc108",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Tx Threshold Control Register"
      },
      {
        "name": "USB3_GRXTHRCFG",
        "offset": "0xc10c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Rx Threshold Control Register"
      },
      {
        "name": "USB3_GCTL",
        "offset": "0xc110",
        "size": "W",
        "reset": "0x30c12004",
        "description": "Global Core Control Register"
      },
      {
        "name": "USB3_GPMSTS",
        "offset": "0xc114",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Power Management Status Register"
      },
      {
        "name": "USB3_GSTS",
        "offset": "0xc118",
        "size": "W",
        "reset": "0x7e800000",
        "description": "Global Status Register"
      },
      {
        "name": "USB3_GUCTL1",
        "offset": "0xc11c",
        "size": "W",
        "reset": "0x0004018a",
        "description": "Global User Control Register 1"
      },
      {
        "name": "USB3_GSNPSID",
        "offset": "0xc120",
        "size": "W",
        "reset": "0x5533290a",
        "description": "Global SNPS ID Register"
      },
      {
        "name": "USB3_GGPIO",
        "offset": "0xc124",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global General Purpose Input/Output Register"
      },
      {
        "name": "USB3_GUID",
        "offset": "0xc128",
        "size": "W",
        "reset": "0x12345678",
        "description": "Global User ID Register"
      },
      {
        "name": "USB3_GUCTL",
        "offset": "0xc12c",
        "size": "W",
        "reset": "0x02008010",
        "description": "Global User Control Register"
      },
      {
        "name": "USB3_GBUSERRADDRLO",
        "offset": "0xc130",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global SoC Bus Error Address Register - Low"
      },
      {
        "name": "USB3_GBUSERRADDRHI",
        "offset": "0xc134",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global SoC Bus Error Address Register - High"
      },
      {
        "name": "USB3_GPRTBIMAPLO",
        "offset": "0xc138",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global SS Port to Bus Instance Mapping Register - Low"
      },
      {
        "name": "USB3_GHWPARAMS0",
        "offset": "0xc140",
        "size": "W",
        "reset": "0x2020400a",
        "description": "Global Hardware Parameters Register 0"
      },
      {
        "name": "USB3_GHWPARAMS1",
        "offset": "0xc144",
        "size": "W",
        "reset": "0x0160c93b",
        "description": "Global Hardware Parameters Register 1"
      },
      {
        "name": "USB3_GHWPARAMS2",
        "offset": "0xc148",
        "size": "W",
        "reset": "0x12345678",
        "description": "Global Hardware Parameters Register 2"
      },
      {
        "name": "USB3_GHWPARAMS3",
        "offset": "0xc14c",
        "size": "W",
        "reset": "0x069cd085",
        "description": "Global Hardware Parameters Register 3"
      },
      {
        "name": "USB3_GHWPARAMS4",
        "offset": "0xc150",
        "size": "W",
        "reset": "0x47822008",
        "description": "Global Hardware Parameters Register 4"
      },
      {
        "name": "USB3_GHWPARAMS5",
        "offset": "0xc154",
        "size": "W",
        "reset": "0x04202088",
        "description": "Global Hardware Parameters Register 5"
      },
      {
        "name": "USB3_GHWPARAMS6",
        "offset": "0xc158",
        "size": "W",
        "reset": "0x077c8020",
        "description": "Global Hardware Parameters Register 6"
      },
      {
        "name": "USB3_GHWPARAMS7",
        "offset": "0xc15c",
        "size": "W",
        "reset": "0x03080756",
        "description": "Global Hardware Parameters Register 7"
      },
      {
        "name": "USB3_GDBGFIFOSPACE",
        "offset": "0xc160",
        "size": "W",
        "reset": "0x00420000",
        "description": "Global Debug Queue/FIFO Space Available Register"
      },
      {
        "name": "USB3_GDBGLTSSM",
        "offset": "0xc164",
        "size": "W",
        "reset": "0x41010440",
        "description": "Global Debug LTSSM Register"
      },
      {
        "name": "USB3_GDBGLNMCC",
        "offset": "0xc168",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Debug LNMCC Register"
      },
      {
        "name": "USB3_GDBGBMU",
        "offset": "0xc16c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Debug BMU Register"
      },
      {
        "name": "USB3_GDBGLSPMUX",
        "offset": "0xc170",
        "size": "W",
        "reset": "0x003f0000",
        "description": "Global Debug LSP MUX Register - Device"
      },
      {
        "name": "USB3_GDBGLSP",
        "offset": "0xc174",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Debug LSP Register"
      },
      {
        "name": "USB3_GDBGEPINFO0",
        "offset": "0xc178",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Debug Endpoint Information Register 0"
      },
      {
        "name": "USB3_GDBGEPINFO1",
        "offset": "0xc17c",
        "size": "W",
        "reset": "0x00800000",
        "description": "Global Debug Endpoint Information Register 1"
      },
      {
        "name": "USB3_GPRTBIMAP_HSLO",
        "offset": "0xc180",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global High-Speed Port to Bus Instance Mapping Register - Low"
      },
      {
        "name": "USB3_GPRTBIMAP_FSLO",
        "offset": "0xc188",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Full-Speed Port to Bus Instance Mapping Register - Low"
      },
      {
        "name": "USB3_GUSB2PHYCFG0",
        "offset": "0xc200",
        "size": "W",
        "reset": "0x40102400",
        "description": "Global USB2 PHY Configuration Register 0"
      },
      {
        "name": "USB3_GUSB3PIPECTL0",
        "offset": "0xc2c0",
        "size": "W",
        "reset": "0x010c0002",
        "description": "Global USB3 PIPE Control Register 0"
      },
      {
        "name": "USB3_GTXFIFOSIZ0~6",
        "offset": "0xc300~\n0xc318",
        "size": "W",
        "reset": "0x00000042",
        "description": "Global Transmit FIFO Size Register n"
      },
      {
        "name": "USB3_GRXFIFOSIZ0~2",
        "offset": "0xc380~\n0xC388",
        "size": "W",
        "reset": "0x00000285",
        "description": "Global Receive FIFO Size Register n"
      },
      {
        "name": "USB3_GEVNTADRLO0",
        "offset": "0xc400",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Event Buffer Address (Low) Register 0"
      },
      {
        "name": "USB3_GEVNTADRHI0",
        "offset": "0xc404",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Event Buffer Address (High) Register 0"
      },
      {
        "name": "USB3_GEVNTSIZ0",
        "offset": "0xc408",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Event Buffer Size Register 0"
      },
      {
        "name": "USB3_GEVNTCOUNT0",
        "offset": "0xc40c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Event Buffer Count Register 0"
      },
      {
        "name": "USB3_GHWPARAMS8",
        "offset": "0xc600",
        "size": "W",
        "reset": "0x0000077c",
        "description": "Global Hardware Parameters Register 8"
      },
      {
        "name": "USB3_GTXFIFOPRIDEV",
        "offset": "0xc610",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Device TX FIFO DMA Priority Register"
      },
      {
        "name": "USB3_GTXFIFOPRIHST",
        "offset": "0xc618",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Host TX FIFO DMA Priority Register"
      },
      {
        "name": "USB3_GRXFIFOPRIHST",
        "offset": "0xc61c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Host RX FIFO DMA Priority Register"
      },
      {
        "name": "USB3_GFIFOPRIDBC",
        "offset": "0xc620",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Host Debug Capability DMA Priority Register"
      },
      {
        "name": "USB3_GDMAHLRATIO",
        "offset": "0xc624",
        "size": "W",
        "reset": "0x00000008",
        "description": "Global Host FIFO DMA High-Low Priority Ratio Register"
      },
      {
        "name": "USB3_GFLADJ",
        "offset": "0xc630",
        "size": "W",
        "reset": "0x00000000",
        "description": "Global Frame Length Adjustment Register"
      },
      {
        "name": "USB3_DCFG",
        "offset": "0xc700",
        "size": "W",
        "reset": "0x00080004",
        "description": "Device Configuration Register"
      },
      {
        "name": "USB3_DCTL",
        "offset": "0xc704",
        "size": "W",
        "reset": "0x00f00000",
        "description": "Device Control Register"
      },
      {
        "name": "USB3_DEVTEN",
        "offset": "0xc708",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Event Enable Register"
      },
      {
        "name": "USB3_DSTS",
        "offset": "0xc70c",
        "size": "W",
        "reset": "0x00500004",
        "description": "Device Status Register"
      },
      {
        "name": "USB3_DGCMDPAR",
        "offset": "0xc710",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Generic Command Parameter Register"
      },
      {
        "name": "USB3_DGCMD",
        "offset": "0xc714",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Generic Command Register"
      },
      {
        "name": "USB3_DALEPENA",
        "offset": "0xc720",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Active USB Endpoint Enable Register"
      },
      {
        "name": "USB3_DEPnCMDPAR2",
        "offset": "0xc800~\n0xc8c0",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Physical Endpoint-n Command Parameter 2 Register"
      },
      {
        "name": "USB3_DEPnCMDPAR1",
        "offset": "0xc804~\n0xc8c4",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Physical Endpoint-n Command Parameter 1 Register"
      },
      {
        "name": "USB3_DEPnCMDPAR0",
        "offset": "0xc808~\n0xc8c8",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Physical Endpoint-n Command Parameter 0 Register"
      },
      {
        "name": "USB3_DEPnCMD",
        "offset": "0xc80c~\n0xc8cc",
        "size": "W",
        "reset": "0x00000000",
        "description": "Device Physical Endpoint-n Command Register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "PWM_PWM0_CNT",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Timer Counter\nThe 32-bit indicates current value of PWM Channel 0 counter. The\ncounter runs at the rate of PWM clock.\nThe value ranges from 0 to (2^32-1)."
          }
        ],
        "description": "PWM Channel 0 Counter Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM0_PERIOD_HPR",
        "offset": "0 x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PERIOD_HPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Period/Input Waveform High Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the period of the output waveform. Note that, if\nthe PWM is operated at the center-aligned mode, the period\nshould be an even one, and therefore only the bit [31:1] is taken\ninto account and bit [0] always considered as 0.\nIf PWM is operated at the capture mode, this value indicates the\neffective high polarity cycles of input waveform. This value is\nbased on the PWM clock.\nThe value ranges from 0 to (2^32-1)."
          }
        ],
        "description": "PWM Channel 0 Period Register/High Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM0_DUTY_LPR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DUTY_LPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the duty cycle of the output waveform. The\nPWM starts the output waveform with duty cycle. Note that, if the\nPWM is operated at the center-aligned mode, the period should\nbe an even one, and therefore only the [31:1] is taken into\naccount.\nIf PWM is operated at the capture mode, this value indicates the\neffective low polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 0 Duty Register/Low Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM0_CTRL",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RPT",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Repeat Counter\nThis field defines the repeated effective periods of output\nwaveform in one-shot mode. The value N means N+1 repeated\neffective periods."
          },
          {
            "name": "SCALE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Scale Factor\nThis field defines the scale factor applied to prescaled clock. The\nvalue N means the clock is divided by 2*N. If N is 0, it means\nthat the clock is divided by 512(2*256)."
          },
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PRESCALE",
            "bit_range": "14:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Prescale Factor\nThis field defines the prescale factor applied to input clock. The\nvalue N means that the input clock is divided by 2^N."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_SEL",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock Source Select\n0: non-scaled clock is selected as PWM clock source. It means\nthat the prescale clock is directly used as the PWM clock source\n1: scaled clock is selected as PWM clock source"
          },
          {
            "name": "LP_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Low Power Mode Enable\n0: disabled\n1: enabled\nWhen PWM channel is inactive state and Low Power Mode is\nenabled, the path to PWM Clock prescale module is blocked to\nreduce power consumption."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "OUTPUT_MODE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Output mode\n0: left aligned mode\n1: center aligned mode"
          },
          {
            "name": "INACTIVE_POL",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Inactive State Output Polarity\nThis defines the output waveform polarity when PWM channel is\nin inactive state. The inactive state means that PWM finishes the\ncomplete waveform in one-shot mode or PWM channel is\ndisabled.\n0: negative\n1: positive"
          },
          {
            "name": "DUTY_POL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Duty Cycle Output Polarity\nThis defines the polarity for duty cycle. PWM starts the output\nwaveform with duty cycle.\n0: negative\n1: positive"
          },
          {
            "name": "PWM_MODE",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Operation Mode\n00: One shot mode.  PWM produces the waveform within the\nrepeated times defined by PWMx_CTRL_rpt.\n01: Continuous mode. PWM produces the waveform continuously\n10: Capture mode. PWM measures the cycles of high/low polarity\nof input waveform.\n11: reserved"
          },
          {
            "name": "PWM_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM channel enable\n0: disabled\n1: enabled. If the PWM is worked in the one-shot mode, this bit\nwill be cleared at the  end of operation"
          }
        ],
        "description": "PWM Channel 0 Control Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM1_CNT",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Timer Counter\nThe 32-bit indicates current value of PWM Channel 1 counter. The\ncounter runs at the rate of PWM clock.\nThe value ranges from 0 to (2^32-1)."
          }
        ],
        "description": "PWM Channel 1 Counter Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM1_PERIOD_HPR",
        "offset": "0 x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PERIOD_HPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Period/Input Waveform High Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the period of the output waveform. Note that, if\nthe PWM is operated at the center-aligned mode, the period\nshould be an even one, and therefore only the bit [31:1] is taken\ninto account and bit [0] always considered as 0.\nIf PWM is operated at the capture mode, this value indicates the\neffective high polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 1 Period Register/High Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM1_DUTY_LPR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DUTY_LPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the duty cycle of the output waveform. The\nPWM starts the output waveform with duty cycle. Note that, if the\nPWM is operated at the center-aligned mode, the period should\nbe an even one, and therefore only the [31:1] is taken into\naccount.\nIf PWM is operated at the capture mode, this value indicates the\neffective low polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 1 Duty Register/Low Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM1_CTRL",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RPT",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Repeat Counter\nThis field defines the repeated effective periods of output\nwaveform in one-shot mode. The value N means N+1 repeated\neffective periods."
          },
          {
            "name": "SCALE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Scale Factor\nThis field defines the scale factor applied to prescaled clock. The\nvalue N means the clock is divided by 2*N. If N is 0, it means\nthat the clock is divided by 512(2*256)."
          },
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PRESCALE",
            "bit_range": "14:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Prescale Factor\nThis field defines the prescale factor applied to input clock. The\nvalue N means that the input clock is divided by 2^N."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_SEL",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock Source Select\n0: non-scaled clock is selected as PWM clock source. It means\nthat the prescale clock is directly used as the PWM clock source\n1: scaled clock is selected as PWM clock source"
          },
          {
            "name": "LP_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Low Power Mode Enable\n0: disabled\n1: enabled\nWhen PWM channel is inactive state and Low Power Mode is\nenabled, the path to PWM Clock prescale module is blocked to\nreduce power consumption."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "OUTPUT_MODE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Output mode\n0: left aligned mode\n1: center aligned mode"
          },
          {
            "name": "INACTIVE_POL",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Inactive State Output Polarity\nThis defines the output waveform polarity when PWM channel is\nin inactive state. The inactive state means that PWM finishes the\ncomplete waveform in one-shot mode or PWM channel is\ndisabled.\n0: negative\n1: positive"
          },
          {
            "name": "DUTY_POL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Duty Cycle Output Polarity\nThis defines the polarity for duty cycle. PWM starts the output\nwaveform with duty cycle.\n0: negative\n1: positive"
          },
          {
            "name": "PWM_MODE",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Operation Mode\n00: One shot mode.  PWM produces the waveform within the\nrepeated times defined by PWMx_CTRL_rpt\n01: Continuous mode. PWM produces the waveform continuously\n10: Capture mode. PWM measures the cycles of high/low polarity\nof input waveform.\n11: reserved"
          },
          {
            "name": "PWM_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM channel enable\n0: disabled\n1: enabled. If the PWM is worked in the one-shot mode, this bit\nwill be cleared at the  end of operation"
          }
        ],
        "description": "PWM Channel 1 Control Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM2_CNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Timer Counter\nThe 32-bit indicates current value of PWM Channel 2 counter. The\ncounter runs at the rate of PWM clock.\nThe value ranges from 0 to (2^32-1)."
          }
        ],
        "description": "PWM Channel 2 Counter Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM2_PERIOD_HPR",
        "offset": "0 x0024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PERIOD_HPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Period/Input Waveform High Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the period of the output waveform. Note that, if\nthe PWM is operated at the center-aligned mode, the period\nshould be an even one, and therefore only the bit [31:1] is taken\ninto account and bit [0] always considered as 0.\nIf PWM is operated at the capture mode, this value indicates the\neffective high polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 2 Period Register/High Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM2_DUTY_LPR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DUTY_LPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the duty cycle of the output waveform. The\nPWM starts the output waveform with duty cycle. Note that, if the\nPWM is operated at the center-aligned mode, the period should\nbe an even one, and therefore only the [31:1] is taken into\naccount.\nIf PWM is operated at the capture mode, this value indicates the\neffective low polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 2 Duty Register/Low Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM2_CTRL",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RPT",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Repeat Counter\nThis field defines the repeated effective periods of output\nwaveform in one-shot mode. The value N means N+1 repeated\neffective periods."
          },
          {
            "name": "SCALE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Scale Factor\nThis field defines the scale factor applied to prescaled clock. The\nvalue N means the clock is divided by 2*N. If N is 0, it means\nthat the clock is divided by 512(2*256)."
          },
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PRESCALE",
            "bit_range": "14:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Prescale Factor\nThis field defines the prescale factor applied to input clock. The\nvalue N means that the input clock is divided by 2^N."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_SEL",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock Source Select\n0: non-scaled clock is selected as PWM clock source. It means\nthat the prescale clock is directly used as the PWM clock source\n1: scaled clock is selected as PWM clock source"
          },
          {
            "name": "LP_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Low Power Mode Enable\n0: disabled\n1: enabled\nWhen PWM channel is inactive state and Low Power Mode is\nenabled, the path to PWM Clock prescale module is blocked to\nreduce power consumption."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "OUTPUT_MODE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Output mode\n0: left aligned mode\n1: center aligned mode"
          },
          {
            "name": "INACTIVE_POL",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Inactive State Output Polarity\nThis defines the output waveform polarity when PWM channel is\nin inactive state. The inactive state means that PWM finishes the\ncomplete waveform in one-shot mode or PWM channel is\ndisabled.\n0: negative\n1: positive"
          },
          {
            "name": "DUTY_POL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Duty Cycle Output Polarity\nThis defines the polarity for duty cycle. PWM starts the output\nwaveform with duty cycle.\n0: negative\n1: positive"
          },
          {
            "name": "PWM_MODE",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Operation Mode\n00: One shot mode.  PWM produces the waveform within the\nrepeated times defined by PWMx_CTRL_rpt.\n01: Continuous mode. PWM produces the waveform continuously\n10: Capture mode. PWM measures the cycles of high/low polarity\nof input waveform.\n11: reserved"
          },
          {
            "name": "PWM_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM channel enable\n0: disabled\n1: enabled. If the PWM is worked in the one-shot mode, this bit\nwill be cleared at the  end of operation"
          }
        ],
        "description": "PWM Channel 2 Control Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM3_CNT",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CNT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Timer Counter\nThe 32-bit indicates current value of PWM Channel 3 counter. The\ncounter runs at the rate of PWM clock.\nThe value ranges from 0 to (2^32-1)."
          }
        ],
        "description": "PWM Channel 3 Counter Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM3_PERIOD_HPR",
        "offset": "0 x0034",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PERIOD_HPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Period/Input Waveform High Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the period of the output waveform. Note that, if\nthe PWM is operated at the center-aligned mode, the period\nshould be an even one, and therefore only the bit [31:1] is taken\ninto account and bit [0] always considered as 0.\nIf PWM is operated at the capture mode, this value indicates the\neffective high polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 3 Period Register/High Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM3_DUTY_LPR",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DUTY_LPR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle\nIf PWM is operated at the continuous mode or one-shot mode,\nthis value defines the duty cycle of the output waveform. The\nPWM starts the output waveform with duty cycle. Note that, if the\nPWM is operated at the center-aligned mode, the period should\nbe an even one, and therefore only the [31:1] is taken into\naccount.\nIf PWM is operated at the capture mode, this value indicates the\neffective low polarity cycles of input waveform.\nThis value is based on the PWM clock. The value ranges from 0 to\n(2^32-1)."
          }
        ],
        "description": "PWM Channel 3 Duty Register/Low Polarity Capture Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM3_CTRL",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RPT",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Repeat Counter\nThis field defines the repeated effective periods of output\nwaveform in one-shot mode. The value N means N+1 repeated\neffective periods."
          },
          {
            "name": "SCALE",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Scale Factor\nThis field defines the scale factor applied to prescaled clock. The\nvalue N means the clock is divided by 2*N. If N is 0, it means\nthat the clock is divided by 512(2*256)."
          },
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PRESCALE",
            "bit_range": "14:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Prescale Factor\nThis field defines the prescale factor applied to input clock. The\nvalue N means that the input clock is divided by 2^N."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLK_SEL",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock Source Select\n0: non-scaled clock is selected as PWM clock source. It means\nthat the prescale clock is directly used as the PWM clock source\n1: scaled clock is selected as PWM clock source"
          },
          {
            "name": "LP_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Low Power Mode Enable\n0: disabled\n1: enabled\nWhen PWM channel is inactive state and Low Power Mode is\nenabled, the path to PWM Clock prescale module is blocked to\nreduce power consumption."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "OUTPUT_MODE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Output mode\n0: left aligned mode\n1: center aligned mode"
          },
          {
            "name": "INACTIVE_POL",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Inactive State Output Polarity\nThis defines the output waveform polarity when PWM channel is\nin inactive state. The inactive state means that PWM finishes the\ncomplete waveform in one-shot mode or PWM channel is\ndisabled.\n0: negative\n1: positive"
          },
          {
            "name": "DUTY_POL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Duty Cycle Output Polarity\nThis defines the polarity for duty cycle. PWM starts the output\nwaveform with duty cycle.\n0: negative\n1: positive"
          },
          {
            "name": "PWM_MODE",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM Operation Mode\n00: One shot mode.  PWM produces the waveform within the\nrepeated times defined by PWMx_CTRL_rpt\n01: Continuous mode. PWM produces the waveform continuously\n10: Capture mode. PWM measures the cycles of high/low polarity\nof input waveform.\n11: reserved"
          },
          {
            "name": "PWM_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "PWM channel enable\n0: disabled\n1: enabled. If the PWM is worked in the one-shot mode, this bit\nwill be cleared at the  end of operation"
          }
        ],
        "description": "PWM Channel 3 Control Register"
      },
      {
        "type": "register",
        "name": "PWM_INTSTS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CH3_POL",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "Channel 3 Interrupt Polarity Flag\nThis bit is used in capture mode in order to identify the transition\nof the input waveform when interrupt is generated. When bit is 1,\nplease refer to PWM3_PERIOD_HPR to know the effective high\ncycle of Channel 3 input waveform. Otherwise, please refer to\nPWM3_PERIOD_LPR to know the effective low cycle of Channel 3\ninput waveform. Write 1 to CH3_IntSts will clear this bit."
          },
          {
            "name": "CH2_POL",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "Channel 2 Interrupt Polarity Flag\nThis bit is used in capture mode in order to identify the transition\nof the input waveform when interrupt is generated. When bit is 1,\nplease refer to PWM2_PERIOD_HPR to know the effective high\ncycle of Channel 2 input waveform. Otherwise, please refer to\nPWM2_PERIOD_LPR to know the effective low cycle of Channel 2\ninput waveform. Write 1 to CH2_IntSts will clear this bit."
          },
          {
            "name": "CH1_POL",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "Channel 1 Interrupt Polarity Flag\nThis bit is used in capture mode in order to identify the transition\nof the input waveform when interrupt is generated. When bit is 1,\nplease refer to PWM1_PERIOD_HPR to know the effective high\ncycle of Channel 1 input waveform. Otherwise, please refer to\nPWM1_PERIOD_LPR to know the effective low cycle of Channel 1\ninput waveform. Write 1 to CH1_IntSts will clear this bit."
          },
          {
            "name": "CH0_POL",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "Channel 0 Interrupt Polarity Flag\nThis bit is used in capture mode in order to identify the transition\nof the input waveform when interrupt is generated. When bit is 1,\nplease refer to PWM0_PERIOD_HPR to know the effective high\ncycle of Channel 0 input waveform. Otherwise, please refer to\nPWM0_PERIOD_LPR to know the effective low cycle of Channel 0\ninput waveform. Write 1 to CH0_IntSts will clear this bit."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CH3_INTSTS",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 3 Interrupt Status\n0: Channel 3 Interrupt not generated\n1: Channel 3 Interrupt generated"
          },
          {
            "name": "CH2_INTSTS",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 2 Interrupt Status\n0: Channel 2 Interrupt not generated\n1: Channel 2 Interrupt generated"
          },
          {
            "name": "CH1_INTSTS",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 1 Interrupt Status\n0: Channel 1 Interrupt not generated\n1: Channel 1 Interrupt generated"
          },
          {
            "name": "CH0_INTSTS",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 0 Raw Interrupt Status\n0: Channel 0 Interrupt not generated\n1: Channel 0 Interrupt generated"
          }
        ],
        "description": "Interrupt Status Register"
      },
      {
        "type": "register",
        "name": "PWM_INT_EN",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CH3_INT_EN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 3 Interrupt Enable\n0: Channel 3 Interrupt disabled\n1: Channel 3 Interrupt enabled"
          },
          {
            "name": "CH2_INT_EN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 2 Interrupt Enable\n0: Channel 2 Interrupt disabled\n1: Channel 2 Interrupt enabled"
          },
          {
            "name": "CH1_INT_EN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 1 Interrupt Enable\n0: Channel 1 Interrupt disabled\n1: Channel 1 Interrupt enabled"
          },
          {
            "name": "CH0_INT_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel 0 Interrupt Enable\n0: Channel 0 Interrupt disabled\n1: Channel 0 Interrupt enabled"
          }
        ],
        "description": "Interrupt Enable Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM_FIFO_CTRL",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TIMEOUT_EN",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "FIFO Timeout Enable"
          },
          {
            "name": "DMA_MODE_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "DMA Mode Enable\n1'b1: enable\n1'b0: disable"
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ALMOST_FULL_WATERMARK",
            "bit_range": "6:4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Almost Full Watermark Level"
          },
          {
            "name": "WATERMARK_INT_EN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Watermark Full Interrupt"
          },
          {
            "name": "OVERFLOW_INT_EN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "FIFO Overflow Interrupt Enable\nWhen high, an interrupt asserts when the channel 3 FIFO is\noverflow."
          },
          {
            "name": "FULL_INT_EN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "FIFO Full Interrupt Enable\nWhen high, an interrupt asserts when the channel 3 FIFO is full."
          },
          {
            "name": "FIFO_MODE_SEL",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "FIFO MODE Sel\nWhen high, PWM FIFO mode is activated"
          }
        ],
        "description": "PWM Channel 3 FIFO Mode Control Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM_FIFO_INTSTS",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_EMPTY_STATUS",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "FIFO Empty Status\nThis bit indicates the FIFO is empty"
          },
          {
            "name": "TIMEOUT_INTSTS",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Timeout Interrupt"
          },
          {
            "name": "FIFO_WATERMARK_FULL_INTSTS",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "FIFO Watermark Full Interrupt Status\nThis bit indicates the FIFO is Watermark Full"
          },
          {
            "name": "FIFO_OVERFLOW_INTSTS",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "FIFO Overflow Interrupt Status\nThis bit indicates the FIFO is overflow"
          },
          {
            "name": "FIFO_FULL_INTSTS",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "FIFO Full Interrupt Status\nThis bit indicates the FIFO is full"
          }
        ],
        "description": "FIFO Interrupts Status Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM_FIFO_TOUTTHR",
        "offset": "0x0058",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:20",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TIMEOUT_THRESHOLD",
            "bit_range": "19:0",
            "attr": "RO",
            "reset": "0x00000",
            "description": "FIFO Timeout Value(unit pwmclk)"
          }
        ],
        "description": "FIFO Timeout Threshold Register"
      },
      {
        "type": "register",
        "name": "PWM_PWM_FIFO",
        "offset": "0x0060\n~0x007C",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "POL",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Polarity\nThis bit indicates the polarity of the lower 31-bit counter.\n0: Low\n1: High"
          },
          {
            "name": "CYCLE_CNT",
            "bit_range": "30:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "High/Low Cycle Counter\nThis 31-bit counter indicates the effective cycles of high/low\nwaveform."
          }
        ],
        "description": "FIFO Register"
      }
    ],
    "name": "PWM",
    "summary": [
      {
        "name": "PWM_PWM0_CNT",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 0 Counter Register"
      },
      {
        "name": "PWM_PWM0_PERIOD_HPR",
        "offset": "0 x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 0 Period Register/High Polarity Capture Register"
      },
      {
        "name": "PWM_PWM0_DUTY_LPR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 0 Duty Register/Low Polarity Capture Register"
      },
      {
        "name": "PWM_PWM0_CTRL",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 0 Control Register"
      },
      {
        "name": "PWM_PWM1_CNT",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 1 Counter Register"
      },
      {
        "name": "PWM_PWM1_PERIOD_HPR",
        "offset": "0 x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 1 Period Register/High Polarity Capture Register"
      },
      {
        "name": "PWM_PWM1_DUTY_LPR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 1 Duty Register/Low Polarity Capture Register"
      },
      {
        "name": "PWM_PWM1_CTRL",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 1 Control Register"
      },
      {
        "name": "PWM_PWM2_CNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 2 Counter Register"
      },
      {
        "name": "PWM_PWM2_PERIOD_HPR",
        "offset": "0 x0024",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 2 Period Register/High Polarity Capture Register"
      },
      {
        "name": "PWM_PWM2_DUTY_LPR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 2 Duty Register/Low Polarity Capture Register"
      },
      {
        "name": "PWM_PWM2_CTRL",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 2 Control Register"
      },
      {
        "name": "PWM_PWM3_CNT",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 3 Counter Register"
      },
      {
        "name": "PWM_PWM3_PERIOD_HPR",
        "offset": "0 x0034",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 3 Period Register/High Polarity Capture Register"
      },
      {
        "name": "PWM_PWM3_DUTY_LPR",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 3 Duty Register/Low Polarity Capture Register"
      },
      {
        "name": "PWM_PWM3_CTRL",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 3 Control Register"
      },
      {
        "name": "PWM_INTSTS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Status Register"
      },
      {
        "name": "PWM_INT_EN",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Enable Register"
      },
      {
        "name": "PWM_PWM_FIFO_CTRL",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "description": "PWM Channel 3 FIFO Mode Control Register"
      },
      {
        "name": "PWM_PWM_FIFO_INTSTS",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO Interrupts Status Register"
      },
      {
        "name": "PWM_PWM_FIFO_TOUTTHR",
        "offset": "0x0058",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO Timeout Threshold Register"
      },
      {
        "name": "PWM_PWM_FIFO",
        "offset": "0x0060\n~0x007C",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO Register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "UART_RBR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_INPUT",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Data byte received on the serial input port (sin) in UART mode, or\nthe serial infrared input (sir_in) in infrared mode. The data in this\nregister is valid only if the Data Ready (DR) bit in the Line Status\nRegister (LCR) is set.\nIf in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are\ndisabled (FCR[0] set to zero), the data in the RBR must be read\nbefore the next data arrives, otherwise it is overwritten, resulting\nin an over-run error.\nIf in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled\n(FCR[0] set to one), this register accesses the head of the receive\nFIFO.\nIf the receive FIFO is full and this register is not read before the\nnext data character arrives, then the data already in the FIFO is\npreserved, but any incoming data are lost and an\nover-run error occurs."
          }
        ],
        "description": "Receive Buffer Register"
      },
      {
        "type": "register",
        "name": "UART_THR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_OUTPUT",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Data to be transmitted on the serial output port (sout) in UART\nmode or the serial infrared output (sir_out_n) in infrared mode.\nData should only be written to the THR when the THR Empty\n(THRE) bit (LSR[5]) is set.\nIf in non-FIFO mode or FIFOs are disabled (FCR[0] = 0) and\nTHRE is set, writing a single character to the THR clears the\nTHRE. Any additional writes to the THR before the THRE is set\nagain causes the THR data to be overwritten.\nIf in FIFO mode and FIFOs are enabled (FCR[0] = 1) and THRE is\nset, x number of characters of data may be written to the THR\nbefore the FIFO is full. The number x (default=16) is determined\nby the value of FIFO Depth that you set during configuration. Any\nattempt to write data when the FIFO is full results in the write\ndata being lost."
          }
        ],
        "description": "Transmit Holding Register"
      },
      {
        "type": "register",
        "name": "UART_DLL",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BAUD_RATE_DIVISOR_L",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Lower 8-bits of a 16-bit, read/write, Divisor Latch register that\ncontains the baud rate divisor for the UART. This register may\nonly be accessed when the DLAB bit (LCR[7]) is set and the UART\nis not busy (USR[0] is zero). The output baud rate is equal to the\nserial clock (sclk) frequency divided by sixteen times the value of\nthe baud rate divisor, as follows: baud rate = (serial clock freq) /\n(16 * divisor).\nNote that with the Divisor Latch Registers (DLL and DLH) set to\nzero, the baud clock is disabled and no serial communications\noccur. Also, once the DLH is set, at least 8 clock cycles of the\nslowest UART clock should be allowed to pass before transmitting\nor receiving data."
          }
        ],
        "description": "Divisor Latch (Low)"
      },
      {
        "type": "register",
        "name": "UART_DLH",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BAUD_RATE_DIVISOR_H",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Upper 8 bits of a 16-bit, read/write, Divisor Latch register that\ncontains the baud rate divisor for the UART."
          }
        ],
        "description": "Divisor Latch (High)"
      },
      {
        "type": "register",
        "name": "UART_IER",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PROG_THRE_INT_EN",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Programmable THRE Interrupt Mode Enable\nThis is used to enable/disable the generation of THRE Interrupt.\n0 = disabled\n1 = enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "6:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MODEM_STATUS_INT_EN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Modem Status Interrupt.\nThis is used to enable/disable the generation of Modem Status\nInterrupt. This is the fourth highest priority interrupt.\n0 = disabled\n1 = enabled"
          },
          {
            "name": "RECEIVE_LINE_STATUS_INT_EN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Receiver Line Status Interrupt.\nThis is used to enable/disable the generation of Receiver Line\nStatus Interrupt. This is the highest priority interrupt.\n0 = disabled\n1 = enabled"
          },
          {
            "name": "TRANS_HOLD_EMPTY_INT_EN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Transmit Holding Register Empty Interrupt."
          },
          {
            "name": "RECEIVE_DATA_AVAILABLE_INT_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable Received Data Available Interrupt.\nThis is used to enable/disable the generation of Received Data\nAvailable Interrupt and the Character Timeout Interrupt (if in\nFIFO mode and FIFOs enabled). These are the second highest\npriority interrupts.\n0 = disabled\n1 = enabled"
          }
        ],
        "description": "Interrupt Enable Register"
      },
      {
        "type": "register",
        "name": "UART_IIR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFOS_EN",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "FIFOs Enabled.\nThis is used to indicate whether the FIFOs are enabled or\ndisabled.\n00 = disabled\n11 = enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "5:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT_ID",
            "bit_range": "3:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Interrupt ID\nThis indicates the highest priority pending interrupt which can be\none of the following types:\n0000 = modem status\n0001 = no interrupt pending\n0010 = THR empty\n0100 = received data available\n0110 = receiver line status\n0111 = busy detect\n1100 = character timeout"
          }
        ],
        "description": "Interrupt Identification Register"
      },
      {
        "type": "register",
        "name": "UART_FCR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RCVR_TRIGGER",
            "bit_range": "7:6",
            "attr": "WO",
            "reset": "0x0",
            "description": "RCVR Trigger.\nThis is used to select the trigger level in the receiver FIFO at\nwhich the Received Data Available Interrupt is generated. In auto\nflow control mode it is used to determine when the rts_n signal is\nde-asserted. It also determines when the dma_rx_req_n signal is\nasserted in certain modes of operation. The following trigger\nlevels are supported:\n00 = 1 character in the FIFO\n01 = FIFO 1/4 full\n10 = FIFO 1/2 full\n11 = FIFO 2 less than ful"
          },
          {
            "name": "TX_EMPTY_TRIGGER",
            "bit_range": "5:4",
            "attr": "WO",
            "reset": "0x0",
            "description": "TX Empty Trigger.\nThis is used to select the empty threshold level at which the THRE\nInterrupts are generated when the mode is active. It also\ndetermines when the dma_tx_req_n signal is asserted when in\ncertain modes of operation. The following trigger levels are\nsupported:\n00 = FIFO empty\n01 = 2 characters in the FIFO\n10 = FIFO 1/4 full\n11 = FIFO 1/2 full"
          },
          {
            "name": "DMA_MODE",
            "bit_range": "3",
            "attr": "WO",
            "reset": "0x0",
            "description": "DMA Mode\nThis determines the DMA signalling mode used for the\ndma_tx_req_n and dma_rx_req_n output signals when additional\nDMA handshaking signals are not selected .\n0 = mode 0\n1 = mode 11100 = character timeout."
          },
          {
            "name": "XMIT_FIFO_RESET",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "XMIT FIFO Reset.\nThis resets the control portion of the transmit FIFO and treats the\nFIFO as empty. This also de-asserts the DMA TX request and\nsingle signals when additional DMA handshaking signals are\nselected . Note that this bit is 'self-clearing'. It is not necessary to\nclear this bit."
          },
          {
            "name": "RCVR_FIFO_RESET",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "RCVR FIFO Reset.\nThis resets the control portion of the receive FIFO and treats the\nFIFO as empty. This also de-asserts the DMA RX request and\nsingle signals when additional DMA handshaking signals are\nselected. Note that this bit is 'self-clearing'. It is not necessary to\nclear this bit."
          },
          {
            "name": "FIFO_EN",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "FIFO Enable.\nFIFO Enable. This enables/disables the transmit (XMIT) and\nreceive (RCVR) FIFOs. Whenever the value of this bit is changed\nboth the XMIT and RCVR controller portion of FIFOs is reset."
          }
        ],
        "description": "FIFO Control Register"
      },
      {
        "type": "register",
        "name": "UART_LCR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DIV_LAT_ACCESS",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Divisor Latch Access Bit.\nWriteable only when UART is not busy (USR[0] is zero), always\nreadable. This bit is used to enable reading and writing of the\nDivisor Latch register (DLL and DLH) to set the baud rate of the\nUART. This bit must be cleared after initial baud rate setup in\norder to access other registers."
          },
          {
            "name": "BREAK_CTRL",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Break Control Bit.\nThis is used to cause a break condition to be transmitted to the\nreceiving device. If set to one the serial output is forced to the\nspacing (logic 0) state. When not in Loopback Mode, as\ndetermined by MCR[4], the sout line is forced low until the Break\nbit is cleared. If MCR[6] set to one, the sir_out_n line is\ncontinuously pulsed. When in Loopback Mode, the break condition\nis internally looped back to the\nreceiver and the sir_out_n line is forced low."
          },
          {
            "name": "RESERVED",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "EVEN_PARITY_SEL",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Even Parity Select.\nWriteable only when UART is not busy (USR[0] is zero), always\nreadable. This is used to select between even and odd parity,\nwhen parity is enabled (PEN set to one). If set to one, an even\nnumber of logic 1s is transmitted or checked. If set to zero, an\nodd number of logic 1s is transmitted or checked."
          },
          {
            "name": "PARITY_EN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Parity Enable.\nWriteable only when UART is not busy (USR[0] is zero), always\nreadable. This bit is used to enable and disable parity generation\nand detection in transmitted and received serial character\nrespectively.\n0 = parity disabled\n1 = parity enabled"
          },
          {
            "name": "STOP_BITS_NUM",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Number of stop bits.\nWriteable only when UART is not busy (USR[0] is zero), always\nreadable. This is used to select the number of stop bits per\ncharacter that the peripheral transmits and receives. If set to\nzero, one stop bit is transmitted in the serial data. If set to one\nand the data bits are set to 5 (LCR[1:0] set to zero) one and a\nhalf stop bits is transmitted. Otherwise, two stop bits are\ntransmitted. Note that regardless of the number of stop bits\nselected, the receiver checks only the first stop bit.\n0 = 1 stop bit\n1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit."
          },
          {
            "name": "DATA_LENGTH_SEL",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Data Length Select.\nWriteable only when UART is not busy (USR[0] is zero), always\nreadable. This is used to select the number of data bits per\ncharacter that the peripheral transmits and receives. The number\nof bit that may be selected areas follows:\n00 = 5 bits\n01 = 6 bits\n10 = 7 bits\n11 = 8 bits"
          }
        ],
        "description": "Line Control Register"
      },
      {
        "type": "register",
        "name": "UART_MCR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SIR_MODE_EN",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "SIR Mode Enable.\nSIR Mode Enable.\nThis is used to enable/disable the IrDA SIR Mode .\n0 = IrDA SIR Mode disabled\n1 = IrDA SIR Mode enabled"
          },
          {
            "name": "AUTO_FLOW_CTRL_EN",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Auto Flow Control Enable.\n0 = Auto Flow Control Mode disabled\n1 = Auto Flow Control Mode enabled"
          },
          {
            "name": "LOOPBACK",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "LoopBack Bit.\nThis is used to put the UART into a diagnostic mode for test\npurposes."
          },
          {
            "name": "OUT2",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "OUT2.\nThis is used to directly control the user-designated Output2\n(out2_n) output. The value written to this location is inverted and\ndriven out on out2_n, that is:\n0 = out2_n de-asserted (logic 1)\n1 = out2_n asserted (logic 0)"
          },
          {
            "name": "OUT1",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "OUT1\nThis is used to directly control the user-designated Output2\n(out2_n) output. The value written to this location is inverted and\ndriven out on out2_n, that is:\n1\u2019b0: out2_n de-asserted (logic 1)\n1\u2019b1: out2_n asserted (logic 0)"
          },
          {
            "name": "REQ_TO_SEND",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Request to Send.\n\nThis is used to directly control the Request to Send (rts_n)\noutput. The Request To Send (rts_n) output is used to inform the\nmodem or data set that the UART is ready to exchange data."
          },
          {
            "name": "DATA_TERMINAL_READY",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Data Terminal Ready.\nThis is used to directly control the Data Terminal Ready (dtr_n)\noutput. The value written to this location is inverted and driven\nout on dtr_n, that is:\n0 = dtr_n de-asserted (logic 1)\n1 = dtr_n asserted (logic 0)"
          }
        ],
        "description": "Modem Control Register"
      },
      {
        "type": "register",
        "name": "UART_LSR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RECEIVER_FIFO_ERROR",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receiver FIFO Error bit.\nThis bit is relevant FIFOs are enabled (FCR[0] set to one). This is\nused to indicate if there is at least one parity error, framing error,\nor break indication in the FIFO.\n0 = no error in RX FIFO\n1 = error in RX FIFO"
          },
          {
            "name": "TRANS_EMPTY",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmitter Empty bit.\nTransmitter Empty bit. If FIFOs enabled (FCR[0] set to one), this\nbit is set whenever the Transmitter Shift Register and the FIFO\nare both empty. If FIFOs are disabled, this bit is set whenever the\nTransmitter Holding Register and the Transmitter Shift Register\nare both empty."
          },
          {
            "name": "TRANS_HOLD_REG_EMPTY",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit Holding Register Empty bit.\nIf THRE mode is disabled (IER[7] set to zero) and regardless of\nFIFO's being implemented/enabled or not, this bit indicates that\nthe THR or TX FIFO is empty.\nThis bit is set whenever data is transferred from the THR or TX\nFIFO to the transmitter shift register and no new data has been\nwritten to the THR or TX FIFO. This also causes a THRE Interrupt\nto occur, if the THRE Interrupt is enabled. If IER[7] set to one\nand FCR[0] set to one respectively, the functionality is switched\nto indicate the transmitter FIFO is full, and no longer controls\nTHRE interrupts, which are then controlled by the FCR[5:4]\nthreshold setting."
          },
          {
            "name": "BREAK_INT",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Break Interrupt bit.\nThis is used to indicate the detection of a break sequence on the\nserial input data."
          },
          {
            "name": "FRAMING_ERROR",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Framing Error bit.\nThis is used to indicate the occurrence of a framing error in the\nreceiver. A framing error occurs when the receiver does not\ndetect a valid STOP bit in the received data."
          },
          {
            "name": "PARITY_EROR",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Parity Error bit.\nThis is used to indicate the occurrence of a parity error in the\nreceiver if the Parity Enable (PEN) bit (LCR[3]) is set."
          },
          {
            "name": "OVERRUN_ERROR",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Overrun error bit.\nThis is used to indicate the occurrence of an overrun error. This\noccurs if a new data character was received before the previous\ndata was read."
          },
          {
            "name": "DATA_READY",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Data Ready bit.\nThis is used to indicate that the receiver contains at least one\ncharacter in the RBR or the receiver FIFO.\n0 = no data ready\n1 = data ready"
          }
        ],
        "description": "Line Status Register"
      },
      {
        "type": "register",
        "name": "UART_MSR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_CARRIOR_DETECT",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Data Carrier Detect.\nThis is used to indicate the current state of the modem control\nline dcd_n."
          },
          {
            "name": "RING_INDICATOR",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "Ring Indicator.\nThis is used to indicate the current state of the modem control\nline ri_n."
          },
          {
            "name": "DATA_SET_READY",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "Data Set Ready.\nThis is used to indicate the current state of the modem control\nline dsr_n."
          },
          {
            "name": "CLEAR_TO_SEND",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Clear to Send.\nThis is used to indicate the current state of the modem control\nline cts_n."
          },
          {
            "name": "DELTA_DATA_CARRIER_DETECT",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Delta Data Carrier Detect.\nThis is used to indicate that the modem control line dcd_n has\nchanged since the last time the MSR was read."
          },
          {
            "name": "TRAILING_EDGE_RING_INDICATOR",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Trailing Edge of Ring Indicator.\nTrailing Edge of Ring Indicator. This is used to indicate that a\nchange on the input ri_n (from an active-low to an inactive-high\nstate) has occurred since the last time the MSR was read."
          },
          {
            "name": "DELTA_DATA_SET_READY",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Delta Data Set Ready.\nThis is used to indicate that the modem control line dsr_n has\nchanged since the last time the MSR was read."
          },
          {
            "name": "DELTA_CLEAR_TO_SEND",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Delta Clear to Send.\nThis is used to indicate that the modem control line cts_n has\nchanged since the last time the MSR was read."
          }
        ],
        "description": "Modem Status Register"
      },
      {
        "type": "register",
        "name": "UART_SCR",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TEMP_STORE_SPACE",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "This register is for programmers to use as a temporary storage\nspace."
          }
        ],
        "description": "Scratchpad Register"
      },
      {
        "type": "register",
        "name": "UART_SRBR",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_RBR",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "This is a shadow register for the RBR and has been allocated\nsixteen 32-bit locations so as to accommodate burst accesses\nfrom the master. This register contains the data byte received on\nthe serial input port (sin) in UART mode or the serial infrared\ninput (sir_in) in infrared mode. The data in this register is valid\nonly if the Data Ready (DR) bit in the Line status Register (LSR)\nis set.\nIf FIFOs are disabled (FCR[0] set to zero), the data in the RBR\nmust be read before the next data arrives, otherwise it is\noverwritten, resulting in an overrun error.\nIf FIFOs are enabled (FCR[0] set to one), this register accesses\nthe head of the receive FIFO. If the receive FIFO is full and this\nregister is not read before the next data character arrives, then\nthe data already in the FIFO are preserved, but any incoming\ndata is lost. An overrun error also occurs."
          }
        ],
        "description": "Shadow Receive Buffer Register"
      },
      {
        "type": "register",
        "name": "UART_STHR",
        "offset": "0x006c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_THR",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "This is a shadow register for the THR."
          }
        ],
        "description": "Shadow Transmit Holding Register"
      },
      {
        "type": "register",
        "name": "UART_FAR",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_ACCESS_TEST_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "This register is use to enable a FIFO access mode for testing, so\nthat the receive FIFO can be written by the master and the\ntransmit FIFO can be read by the master when FIFOs are\nimplemented and enabled. When FIFOs are not enabled it allows\nthe RBR to be written by the master and the THR to be read by\nthe master.\n0 = FIFO access mode disabled\n1 = FIFO access mode enabled"
          }
        ],
        "description": "FIFO Access Register"
      },
      {
        "type": "register",
        "name": "UART_TFR",
        "offset": "0x0074",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TRANS_FIFO_READ",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO Read.\nThese bits are only valid when FIFO access mode is enabled\n(FAR[0] is set to one).When FIFOs are implemented and enabled,\nreading this register gives the data at the top of the transmit\nFIFO. Each consecutive read pops the transmit FIFO and gives\nthe next data value that is currently at the top of the FIFO."
          }
        ],
        "description": "Transmit FIFO Read"
      },
      {
        "type": "register",
        "name": "UART_RFW",
        "offset": "0x0078",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RECEIVE_FIFO_FRAMING_ERROR",
            "bit_range": "9",
            "attr": "WO",
            "reset": "0x0",
            "description": "Receive FIFO Framing Error.\nThese bits are only valid when FIFO access mode is enabled\n(FAR[0] is set to one)."
          },
          {
            "name": "RECEIVE_FIFO_PARITY_ERROR",
            "bit_range": "8",
            "attr": "WO",
            "reset": "0x0",
            "description": "Receive FIFO Parity Error.\nThese bits are only valid when FIFO access mode is enabled\n(FAR[0] is set to one)."
          },
          {
            "name": "RECEIVE_FIFO_WRITE",
            "bit_range": "7:0",
            "attr": "WO",
            "reset": "0x00",
            "description": "Receive FIFO Write Data.\nThese bits are only valid when FIFO access mode is enabled\n(FAR[0] is set to one).\nWhen FIFOs are enabled, the data that is written to the RFWD is\npushed into the receive FIFO. Each consecutive write pushes the\nnew data to the next write location in the receive FIFO.\nWhen FIFOs not enabled, the data that is written to the RFWD is\npushed into the RBR."
          }
        ],
        "description": "Receive FIFO Write"
      },
      {
        "type": "register",
        "name": "UART_USR",
        "offset": "0x007c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RECEIVE_FIFO_FULL",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Full.\nThis is used to indicate that the receive FIFO is completely full.\n0 = Receive FIFO not full\n1 = Receive FIFO Full\nThis bit is cleared when the RX FIFO is no longer full."
          },
          {
            "name": "RECEIVE_FIFO_NOT_EMPTY",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Not Empty.\nThis is used to indicate that the receive FIFO contains one or\nmore entries.\n0 = Receive FIFO is empty\n1 = Receive FIFO is not empty\nThis bit is cleared when the RX FIFO is empty."
          },
          {
            "name": "TRASN_FIFO_EMPTY",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Empty.\nThis is used to indicate that the transmit FIFO is completely\nempty.\n0 = Transmit FIFO is not empty\n1 = Transmit FIFO is empty\nThis bit is cleared when the TX FIFO is no longer empty"
          },
          {
            "name": "TRANS_FIFO_NOT_FULL",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Not Full.\nThis is used to indicate that the transmit FIFO in not full.\n0 = Transmit FIFO is full\n1 = Transmit FIFO is not full\nThis bit is cleared when the TX FIFO is full."
          },
          {
            "name": "UART_BUSY",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "UART Busy.\nUART Busy. This is indicates that a serial transfer is in progress,\nwhen cleared indicates that the UART is idle or inactive.\n0 = UART is idle or inactive\n1 = UART is busy (actively transferring data)"
          }
        ],
        "description": "UART Status Register"
      },
      {
        "type": "register",
        "name": "UART_TFL",
        "offset": "0x0080",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TRANS_FIFO_LEVEL",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit FIFO Level.\nThis is indicates the number\nof data entries in the transmit FIFO."
          }
        ],
        "description": "Transmit FIFO Level"
      },
      {
        "type": "register",
        "name": "UART_RFL",
        "offset": "0x0084",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RECEIVE_FIFO_LEVEL",
            "bit_range": "4:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Receive FIFO Level.\nThis is indicates the number of data entries in the receive FIFO."
          }
        ],
        "description": "Receive FIFO Level"
      },
      {
        "type": "register",
        "name": "UART_SRR",
        "offset": "0x0088",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "XMIT_FIFO_RESET",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "XMIT FIFO Reset.\nThis is a shadow register for the XMIT FIFO Reset bit (FCR[2])."
          },
          {
            "name": "RCVR_FIFO_RESET",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "RCVR FIFO Reset.\nThis is a shadow register for the RCVR FIFO Reset bit (FCR[1])."
          },
          {
            "name": "UART_RESET",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "UART Reset.\nThis asynchronously resets the UART and synchronously removes\nthe reset assertion. For a two clock implementation both pclk and\nsclk domains are reset."
          }
        ],
        "description": "Software Reset Register"
      },
      {
        "type": "register",
        "name": "UART_SRTS",
        "offset": "0x008c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_REQ_TO_SEND",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow Request to Send.\nThis is a shadow register for the RTS bit (MCR[1]), this can be\nused to remove the burden of having to performing a read-\nmodify-write on the MCR."
          }
        ],
        "description": "Shadow Request to Send"
      },
      {
        "type": "register",
        "name": "UART_SBCR",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_BREAK_CTRL",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow Break Control Bit.\nThis is a shadow register for the Break bit (LCR[6]), this can be\nused to remove the burden of having to performing a read modify\nwrite on the LCR."
          }
        ],
        "description": "Shadow Break Control Register"
      },
      {
        "type": "register",
        "name": "UART_SDMAM",
        "offset": "0x0094",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_DMA_MODE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow DMA Mode.\nThis is a shadow register for the DMA mode bit (FCR[3])."
          }
        ],
        "description": "Shadow DMA Mode"
      },
      {
        "type": "register",
        "name": "UART_SFE",
        "offset": "0x0098",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_FIFO_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow FIFO Enable.\nShadow FIFO Enable. This is a shadow register for the FIFO\nenable bit (FCR[0])."
          }
        ],
        "description": "Shadow FIFO Enable"
      },
      {
        "type": "register",
        "name": "UART_SRT",
        "offset": "0x009c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_RCVR_TRIGGER",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow RCVR Trigger.\nThis is a shadow register for the RCVR trigger bits (FCR[7:6])."
          }
        ],
        "description": "Shadow RCVR Trigger"
      },
      {
        "type": "register",
        "name": "UART_STET",
        "offset": "0x00a0",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SHADOW_TX_EMPTY_TRIGGER",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Shadow TX Empty Trigger.\nThis is a shadow register for the TX empty trigger bits\n(FCR[5:4])."
          }
        ],
        "description": "Shadow TX Empty Trigger"
      },
      {
        "type": "register",
        "name": "UART_HTX",
        "offset": "0x00a4",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HALT_TX_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "This register is use to halt transmissions for testing, so that the\ntransmit FIFO can be filled by the master when FIFOs are\nimplemented and enabled.\n0 = Halt TX disabled\n1 = Halt TX enabled"
          }
        ],
        "description": "Halt TX"
      },
      {
        "type": "register",
        "name": "UART_DMASA",
        "offset": "0x00a8",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DMA_SOFTWARE_ACK",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "This register is use to perform a DMA software acknowledge if a\ntransfer needs to be terminated due to an error condition."
          }
        ],
        "description": "DMA Software Acknowledge"
      },
      {
        "type": "register",
        "name": "UART_CPR",
        "offset": "0x00f4",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_MODE",
            "bit_range": "23:16",
            "attr": "RO",
            "reset": "0x00",
            "description": "0x00 = 0\n0x01 = 16\n0x02 = 32\nto\n0x80 = 2048\n0x81- 0xff = reserved"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DMA_EXTRA",
            "bit_range": "13",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "UART_ADD_ENCODED_PARAMS",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "SHADOW",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "FIFO_STAT",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "FIFO_ACCESS",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "NEW_FEAT",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "SIR_LP_MODE",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "SIR_MODE",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "THRE_MODE",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "AFCE_MODE",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "0 = FALSE\n1 = TRUE"
          },
          {
            "name": "RESERVED",
            "bit_range": "3:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "APB_DATA_WIDTH",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "00 = 8 bits\n01 = 16 bits\n10 = 32 bits\n11 = reserved"
          }
        ],
        "description": "Component Parameter Register"
      },
      {
        "type": "register",
        "name": "UART_UCV",
        "offset": "0x00f8",
        "size": "W",
        "reset": "0x0330372a",
        "bit_ranges": [
          {
            "name": "VER",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x0330372a",
            "description": "ASCII value for each number in the version"
          }
        ],
        "description": "UART Component Version"
      },
      {
        "type": "register",
        "name": "UART_CTR",
        "offset": "0x00fc",
        "size": "W",
        "reset": "0x44570110",
        "bit_ranges": [
          {
            "name": "PERIPHERAL_ID",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x44570110",
            "description": "This register contains the peripherals identification code."
          }
        ],
        "description": "Component Type Register"
      }
    ],
    "name": "UART",
    "summary": [
      {
        "name": "UART_RBR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive Buffer Register"
      },
      {
        "name": "UART_THR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit Holding Register"
      },
      {
        "name": "UART_DLL",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "Divisor Latch (Low)"
      },
      {
        "name": "UART_DLH",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Divisor Latch (High)"
      },
      {
        "name": "UART_IER",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Enable Register"
      },
      {
        "name": "UART_IIR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Identification Register"
      },
      {
        "name": "UART_FCR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO Control Register"
      },
      {
        "name": "UART_LCR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Line Control Register"
      },
      {
        "name": "UART_MCR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Modem Control Register"
      },
      {
        "name": "UART_LSR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "Line Status Register"
      },
      {
        "name": "UART_MSR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Modem Status Register"
      },
      {
        "name": "UART_SCR",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Scratchpad Register"
      },
      {
        "name": "UART_SRBR",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Receive Buffer Register"
      },
      {
        "name": "UART_STHR",
        "offset": "0x006c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Transmit Holding Register"
      },
      {
        "name": "UART_FAR",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "description": "FIFO Access Register"
      },
      {
        "name": "UART_TFR",
        "offset": "0x0074",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Read"
      },
      {
        "name": "UART_RFW",
        "offset": "0x0078",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Write"
      },
      {
        "name": "UART_USR",
        "offset": "0x007c",
        "size": "W",
        "reset": "0x00000000",
        "description": "UART Status Register"
      },
      {
        "name": "UART_TFL",
        "offset": "0x0080",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Level"
      },
      {
        "name": "UART_RFL",
        "offset": "0x0084",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Level"
      },
      {
        "name": "UART_SRR",
        "offset": "0x0088",
        "size": "W",
        "reset": "0x00000000",
        "description": "Software Reset Register"
      },
      {
        "name": "UART_SRTS",
        "offset": "0x008c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Request to Send"
      },
      {
        "name": "UART_SBCR",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Break Control Register"
      },
      {
        "name": "UART_SDMAM",
        "offset": "0x0094",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow DMA Mode"
      },
      {
        "name": "UART_SFE",
        "offset": "0x0098",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow FIFO Enable"
      },
      {
        "name": "UART_SRT",
        "offset": "0x009c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow RCVR Trigger"
      },
      {
        "name": "UART_STET",
        "offset": "0x00a0",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow TX Empty Trigger"
      },
      {
        "name": "UART_HTX",
        "offset": "0x00a4",
        "size": "W",
        "reset": "0x00000000",
        "description": "Halt TX"
      },
      {
        "name": "UART_DMASA",
        "offset": "0x00a8",
        "size": "W",
        "reset": "0x00000000",
        "description": "DMA Software Acknowledge"
      },
      {
        "name": "UART_CPR",
        "offset": "0x00f4",
        "size": "W",
        "reset": "0x00000000",
        "description": "Component Parameter Register"
      },
      {
        "name": "UART_UCV",
        "offset": "0x00f8",
        "size": "W",
        "reset": "0x0330372a",
        "description": "UART Component Version"
      },
      {
        "name": "UART_CTR",
        "offset": "0x00fc",
        "size": "W",
        "reset": "0x44570110",
        "description": "Component Type Register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "GPIO_SWPORTA_DR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_SWPORTA_DR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Values written to this register are output on the I/O signals for\nPort A if the corresponding data direction bits for Port A are set to\nOutput mode. The value read back is equal to the last value\nwritten to this register."
          }
        ],
        "description": "Port A data register"
      },
      {
        "type": "register",
        "name": "GPIO_SWPORTA_DDR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_SWPORTA_DDR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Values written to this register independently control the direction\nof the corresponding data bit in Port A.\n0: Input (default)\n1: Output"
          }
        ],
        "description": "Port A data direction register"
      },
      {
        "type": "register",
        "name": "GPIO_INTEN",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INT_EN",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Allows each bit of Port A to be configured for interrupts.\nWhenever a 1 is written to a bit of this register, it configures the\ncorresponding bit on Port A to become an interrupt; otherwise,\nPort A operates as a normal GPIO signal.\nInterrupts are disabled on the corresponding bits of Port A if the\ncorresponding data direction register is set to Output.\n0: Configure Port A bit as normal GPIO signal (default)\n1: Configure Port A bit as interrupt"
          }
        ],
        "description": "Interrupt enable register"
      },
      {
        "type": "register",
        "name": "GPIO_INTMASK",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INT_MASK",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Controls whether an interrupt on Port A can create an\ninterrupt for the interrupt controller by not masking it. Whenever\na 1 is written to a bit in this register, it masks the interrupt\ngeneration capability for this signal; otherwise interrupts are\nallowed through.\n0: Interrupt bits are unmasked (default)\n1: Mask interrupt"
          }
        ],
        "description": "Interrupt mask register"
      },
      {
        "type": "register",
        "name": "GPIO_INTTYPE_LEVEL",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INTTYPE_LEVEL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Controls the type of interrupt that can occur on Port A.\n0: Level-sensitive (default)\n1: Edge-sensitive"
          }
        ],
        "description": "Interrupt level register"
      },
      {
        "type": "register",
        "name": "GPIO_INT_POLARITY",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INT_POLARITY",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Controls the polarity of edge or level sensitivity that can occur on\ninput of Port A.\n0: Active-low (default)\n1: Active-high"
          }
        ],
        "description": "Interrupt polarity register"
      },
      {
        "type": "register",
        "name": "GPIO_INT_STATUS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INT_STATUS",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Interrupt status of Port A"
          }
        ],
        "description": "Interrupt status of port A"
      },
      {
        "type": "register",
        "name": "GPIO_INT_RAWSTATUS",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_INT_RAWSTATUS",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Raw interrupt of status of Port A (premasking bits)"
          }
        ],
        "description": "Raw Interrupt status of port A"
      },
      {
        "type": "register",
        "name": "GPIO_DEBOUNCE",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_DEBOUNCE",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Controls whether an external signal that is the source of an\ninterrupt needs to be debounced to remove any spurious glitches.\nWriting a 1 to a bit in this register enables the debouncing\ncircuitry. A signal must be valid for two periods of an external\nclock before it is internally processed.\n0: No debounce (default)\n1: Enable debounce"
          }
        ],
        "description": "Debounce enable register"
      },
      {
        "type": "register",
        "name": "GPIO_PORTA_EOI",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_PORTA_EOI",
            "bit_range": "31:0",
            "attr": "WO",
            "reset": "0x00000000",
            "description": "Controls the clearing of edge type interrupts from Port A. When a\n1 is written into a corresponding bit of this register, the interrupt\nis cleared. All interrupts are cleared when Port A is not configured\nfor interrupts.\n0: No interrupt clear (default)\n1: Clear interrupt"
          }
        ],
        "description": "Port A clear interrupt register"
      },
      {
        "type": "register",
        "name": "GPIO_EXT_PORTA",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "GPIO_EXT_PORTA",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "When Port A is configured as Input, then reading this location\nreads the values on the signal. When the data direction of Port A\nis set as Output, reading this location reads the data register for\nPort A."
          }
        ],
        "description": "Port A external port register"
      },
      {
        "type": "register",
        "name": "GPIO_LS_SYNC",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GPIO_LS_SYNC",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Writing a 1 to this register results in all level-sensitive interrupts\nbeing synchronized to pclk_intr.\n0: No synchronization to pclk_intr (default)\n1: Synchronize to pclk_intr"
          }
        ],
        "description": "Level_sensitive synchronization enable register"
      }
    ],
    "name": "GPIO",
    "summary": [
      {
        "name": "GPIO_SWPORTA_DR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "Port A data register"
      },
      {
        "name": "GPIO_SWPORTA_DDR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Port A data direction register"
      },
      {
        "name": "GPIO_INTEN",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt enable register"
      },
      {
        "name": "GPIO_INTMASK",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt mask register"
      },
      {
        "name": "GPIO_INTTYPE_LEVEL",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt level register"
      },
      {
        "name": "GPIO_INT_POLARITY",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt polarity register"
      },
      {
        "name": "GPIO_INT_STATUS",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt status of port A"
      },
      {
        "name": "GPIO_INT_RAWSTATUS",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "description": "Raw Interrupt status of port A"
      },
      {
        "name": "GPIO_DEBOUNCE",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00000000",
        "description": "Debounce enable register"
      },
      {
        "name": "GPIO_PORTA_EOI",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Port A clear interrupt register"
      },
      {
        "name": "GPIO_EXT_PORTA",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "description": "Port A external port register"
      },
      {
        "name": "GPIO_LS_SYNC",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "description": "Level_sensitive synchronization enable register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "RKI2C_CON",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "VERSION",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0000",
            "description": "rki2c version\nversion information"
          },
          {
            "name": "STOP_SETUP",
            "bit_range": "15:14",
            "attr": "RW",
            "reset": "0x0",
            "description": "staop setup config\nTSU;sto = (stop_setup + 1) * T(SCL_HIGH) + Tclk_i2c"
          },
          {
            "name": "START_SETUP",
            "bit_range": "13:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "start setup config\nTSU;sta = (start_setup + 1) * T(SCL_HIGH) + Tclk_i2c\nTHD;sta = (start_setup + 2) * T(SCL_HIGH) - Tclk_i2c"
          },
          {
            "name": "RESERVED",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_UPD_ST",
            "bit_range": "10:8",
            "attr": "RW",
            "reset": "0x0",
            "description": "SDA update point config\nUsed to config sda change state when scl is low, used to adjust\nsetup/hold time\n4'bn:Thold = (n + 1) * Tclk_i2c\nNote: 0 <= n <= 5"
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ACT2NAK",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "operation when NAK handshake is received\n1'b0: ignored\n1'b1: stop transaction"
          },
          {
            "name": "ACK",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "last byte acknowledge control in master receive mode\n1'b0: ACK\n1'b1: NAK"
          },
          {
            "name": "STOP",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "stop enable\nstop enable, when this bit is written to 1, I2C will generate stop\nsignal."
          },
          {
            "name": "START",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "start enable\nstart enable, when this bit is written to 1, I2C will generate start\nsignal."
          },
          {
            "name": "I2C_MODE",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "i2c mode select\n2'b00: transmit only\n2'b01: transmit address (device + register address) --> restart -\n-> transmit address -> receive only\n2'b10: receive only\n2'b11: transmit address (device + register address, write/read bit\nis 1) --> restart --> transmit address (device address) -->\nreceive data"
          },
          {
            "name": "I2C_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "i2c module enable\n1'b0:not enable\n1'b1:enable"
          }
        ],
        "description": "control register"
      },
      {
        "type": "register",
        "name": "RKI2C_CLKDIV",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000001",
        "bit_ranges": [
          {
            "name": "CLKDIVH",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "scl high level clock count\nT(SCL_HIGH) = Tclk_i2c * (CLKDIVH + 1) * 8"
          },
          {
            "name": "CLKDIVL",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0001",
            "description": "scl low level clock count\nT(SCL_LOW) = Tclk_i2c * (CLKDIVL + 1) * 8"
          }
        ],
        "description": "clock divider register"
      },
      {
        "type": "register",
        "name": "RKI2C_MRXADDR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:27",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADDHVLD",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "address high byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "ADDMVLD",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "address middle byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "ADDLVLD",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "address low byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "SADDR",
            "bit_range": "23:0",
            "attr": "RW",
            "reset": "0x000000",
            "description": "master address register\nthe lowest bit indicate write or read\n24 bits address register"
          }
        ],
        "description": "the slave address accessed  for master rx mode"
      },
      {
        "type": "register",
        "name": "RKI2C_MRXRADDR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:27",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SRADDHVLD",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "address high byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "SRADDMVLD",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "address middle byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "SRADDLVLD",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "address low byte valid\n1'b0:invalid\n1'b1:valid"
          },
          {
            "name": "SRADDR",
            "bit_range": "23:0",
            "attr": "RW",
            "reset": "0x000000",
            "description": "slave register address accessed\n24 bits register address"
          }
        ],
        "description": "the slave register address accessed  for master rx mode"
      },
      {
        "type": "register",
        "name": "RKI2C_MTXCNT",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MTXCNT",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "master transmit count\n6 bits counter"
          }
        ],
        "description": "master transmit count"
      },
      {
        "type": "register",
        "name": "RKI2C_MRXCNT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MRXCNT",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "master rx count\n6 bits counter"
          }
        ],
        "description": "master rx count"
      },
      {
        "type": "register",
        "name": "RKI2C_IEN",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SLAVEHDSCLEN",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "slave hold scl interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "NAKRCVIEN",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "NAK handshake received interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "STOPIEN",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "stop operation finished interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "STARTIEN",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "start operation finished interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "MBRFIEN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "MRXCNT data received finished interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "MBTFIEN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "MTXCNT data transfer finished interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "BRFIEN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "byte rx finished interrupt enable\n1'b0:disable\n1'b1:enable"
          },
          {
            "name": "BTFIEN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "byte tx finished interrupt enable\n1'b0:disable\n1'b1:enable"
          }
        ],
        "description": "interrupt enable register"
      },
      {
        "type": "register",
        "name": "RKI2C_IPD",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SLAVEHDSCLIPD",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "slave hold scl interrupt pending bit\n1'b0:no interrupt available\n1'b1:slave hold scl interrupt appear, write 1 to clear"
          },
          {
            "name": "NAKRCVIPD",
            "bit_range": "6",
            "attr": "W1C",
            "reset": "0x0",
            "description": "NAK handshake received interrupt pending bit\n1'b0:no interrupt available\n1'b1:NAK handshake received interrupt appear, write 1 to clear"
          },
          {
            "name": "STOPIPD",
            "bit_range": "5",
            "attr": "W1C",
            "reset": "0x0",
            "description": "stop operation finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:stop operation finished interrupt appear, write 1 to clear"
          },
          {
            "name": "STARTIPD",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "start operation finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:start operation finished interrupt appear, write 1 to clear"
          },
          {
            "name": "MBRFIPD",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "MRXCNT data received finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:MRXCNT data received finished interrupt appear, write 1 to\nclear"
          },
          {
            "name": "MBTFIPD",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "MTXCNT data transfer finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:MTXCNT data transfer finished interrupt appear, write 1 to\nclear"
          },
          {
            "name": "BRFIPD",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "byte rx finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:byte rx finished interrupt appear, write 1 to clear"
          },
          {
            "name": "BTFIPD",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "byte tx finished interrupt pending bit\n1'b0:no interrupt available\n1'b1:byte tx finished interrupt appear, write 1 to clear"
          }
        ],
        "description": "interrupt pending register"
      },
      {
        "type": "register",
        "name": "RKI2C_FCNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FCNT",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "finished count\nthe count of data which has been transmitted or received\nfor debug purpose"
          }
        ],
        "description": "finished count"
      },
      {
        "type": "register",
        "name": "RKI2C_SCL_OE_DB",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000020",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SCL_OE_DB",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x20",
            "description": "slave hold scl debounce\ncycles for debounce (unit: Tclk_i2c)"
          }
        ],
        "description": "slave hold debounce configure register"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA0",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA0",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data0 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 0"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA1",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA1",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data1 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 1"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA2",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA2",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data2 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 2"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA3",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA3",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data3 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 3"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA4",
        "offset": "0x0110",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA4",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data4 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 4"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA5",
        "offset": "0x0114",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA5",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data5 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 5"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA6",
        "offset": "0x0118",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA6",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data6 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 6"
      },
      {
        "type": "register",
        "name": "RKI2C_TXDATA7",
        "offset": "0x011c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDATA7",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "data7 to be transmitted\n32 bits data"
          }
        ],
        "description": "I2C tx data register 7"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA0",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA0",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data0 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 0"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA1",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA1",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data1 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 1"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA2",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA2",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data2 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 2"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA3",
        "offset": "0x020c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA3",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data3 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 3"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA4",
        "offset": "0x0210",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA4",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data4 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 4"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA5",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA5",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data5 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 5"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA6",
        "offset": "0x0218",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA6",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data6 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 6"
      },
      {
        "type": "register",
        "name": "RKI2C_RXDATA7",
        "offset": "0x021c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDATA7",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "data7 received\n32 bits data"
          }
        ],
        "description": "I2C rx data register 7"
      },
      {
        "type": "register",
        "name": "RKI2C_ST",
        "offset": "0x0220",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SCL_ST",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "scl status\n1'b0: scl status low\n1'b0: scl status high"
          },
          {
            "name": "SDA_ST",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "sda status\n1'b0: sda status low\n1'b0: sda status high"
          }
        ],
        "description": "status debug register"
      }
    ],
    "name": "RKI2C",
    "summary": [
      {
        "name": "RKI2C_CON",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "control register"
      },
      {
        "name": "RKI2C_CLKDIV",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000001",
        "description": "clock divider register"
      },
      {
        "name": "RKI2C_MRXADDR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "the slave address accessed  for master rx mode"
      },
      {
        "name": "RKI2C_MRXRADDR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "the slave register address accessed  for master rx mode"
      },
      {
        "name": "RKI2C_MTXCNT",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "master transmit count"
      },
      {
        "name": "RKI2C_MRXCNT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "master rx count"
      },
      {
        "name": "RKI2C_IEN",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "interrupt enable register"
      },
      {
        "name": "RKI2C_IPD",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "interrupt pending register"
      },
      {
        "name": "RKI2C_FCNT",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "finished count"
      },
      {
        "name": "RKI2C_SCL_OE_DB",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000020",
        "description": "slave hold debounce configure register"
      },
      {
        "name": "RKI2C_TXDATA0",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 0"
      },
      {
        "name": "RKI2C_TXDATA1",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 1"
      },
      {
        "name": "RKI2C_TXDATA2",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 2"
      },
      {
        "name": "RKI2C_TXDATA3",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 3"
      },
      {
        "name": "RKI2C_TXDATA4",
        "offset": "0x0110",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 4"
      },
      {
        "name": "RKI2C_TXDATA5",
        "offset": "0x0114",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 5"
      },
      {
        "name": "RKI2C_TXDATA6",
        "offset": "0x0118",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 6"
      },
      {
        "name": "RKI2C_TXDATA7",
        "offset": "0x011c",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C tx data register 7"
      },
      {
        "name": "RKI2C_RXDATA0",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 0"
      },
      {
        "name": "RKI2C_RXDATA1",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 1"
      },
      {
        "name": "RKI2C_RXDATA2",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 2"
      },
      {
        "name": "RKI2C_RXDATA3",
        "offset": "0x020c",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 3"
      },
      {
        "name": "RKI2C_RXDATA4",
        "offset": "0x0210",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 4"
      },
      {
        "name": "RKI2C_RXDATA5",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 5"
      },
      {
        "name": "RKI2C_RXDATA6",
        "offset": "0x0218",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 6"
      },
      {
        "name": "RKI2C_RXDATA7",
        "offset": "0x021c",
        "size": "W",
        "reset": "0x00000000",
        "description": "I2C rx data register 7"
      },
      {
        "name": "RKI2C_ST",
        "offset": "0x0220",
        "size": "W",
        "reset": "0x00000000",
        "description": "status debug register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "I2S_TXCR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x0000000f",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:23",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RCNT",
            "bit_range": "22:17",
            "attr": "RW",
            "reset": "0x00",
            "description": "right justified counter\n(Can be written only when XFER[0] bit is 0.)\nOnly valid in I2S Right justified format and slave tx mode is\nselected.\nStart to transmit data RCNT sclk cycles after left channel valid."
          },
          {
            "name": "TCSR",
            "bit_range": "16:15",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX Channel select register\n2'b00:two channel\n2'b01:four channel\n2'b10:six channel\n2'b11:eight channel"
          },
          {
            "name": "HWT",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Halfword word transform\n(Can be written only when XFER[0] bit is 0.)\nOnly valid when VDW select 16bit data.\n0:32 bit data valid from AHB/APB bus. Low 16 bit for left channel\nand high 16 bit for right channel.\n1:low 16bit data valid from AHB/APB bus, high 16 bit data\ninvalid."
          },
          {
            "name": "RESERVED",
            "bit_range": "13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SJM",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Store justified mode\nSJM\nStore justified mode\n(Can be written only when XFER[1] bit is 0.)\n16bit~31bit DATA stored in 32 bits width fifo.\nThis bit is invalid if VDW select 16bit data and HWT select 0,\nBecause every fifo unit contain two 16bit data and 32 bit space is\nfull, it is impossible to choose justified mode.\n0:right justified\n1:left justified"
          },
          {
            "name": "FBM",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "First Bit Mode\n(Can be written only when XFER[0] bit is 0.)\n0:MSB\n1:LSB"
          },
          {
            "name": "IBM",
            "bit_range": "10:9",
            "attr": "RW",
            "reset": "0x0",
            "description": "I2S bus mode\n(Can be written only when XFER[0] bit is 0.)\n0:I2S normal\n1:I2S Left justified\n2:I2S Right justified\n3:reserved"
          },
          {
            "name": "PBM",
            "bit_range": "8:7",
            "attr": "RW",
            "reset": "0x0",
            "description": "PCM bus mode\n(Can be written only when XFER[0] bit is 0.)\n0:PCM no delay mode\n1:PCM delay 1 mode\n2:PCM delay 2 mode\n3:PCM delay 3 mode"
          },
          {
            "name": "RESERVED",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFS",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transfer format select\n(Can be written only when XFER[0] bit is 0.)\n0: I2S format\n1: PCM format"
          },
          {
            "name": "VDW",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x0f",
            "description": "Valid Data width\n(Can be written only when XFER[0] bit is 0.)\n0~14:reserved\n15:16bit\n16:17bit\n17:18bit\n18:19bit\n......\nn:(n+1)bit\n......\n28:29bit\n29:30bit\n30:31bit\n31:32bit"
          }
        ],
        "description": "transmit operation control register"
      },
      {
        "type": "register",
        "name": "I2S_RXCR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x0000000f",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RCSR",
            "bit_range": "16:15",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX Channel select register\n2'b00:two channel\n2'b01:four channel\n2'b10:six channel\n2'b11:eight channel"
          },
          {
            "name": "HWT",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Halfword word transform\n(Can be written only when XFER[1] bit is 0.)\nOnly valid when VDW select 16bit data.\n0:32 bit data valid to AHB/APB bus. Low 16 bit for left channel\nand high 16 bit for right channel.\n1:low 16bit data valid to AHB/APB bus, high 16 bit data invalid."
          },
          {
            "name": "RESERVED",
            "bit_range": "13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SJM",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Store justified mode\n(Can be written only when XFER[1] bit is 0.)\n16bit~31bit DATA stored in 32 bits width fifo.\nIf VDW select 16bit data, this bit is valid only when HWT select\n0.Because if HWT is 1, every fifo unit contain two 16bit data and\n32 bit space is full, it is impossible to choose justified mode.\n0:right justified\n1:left justified"
          },
          {
            "name": "FBM",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "First Bit Mode\n(Can be written only when XFER[1] bit is 0.)\n0:MSB\n1:LSB"
          },
          {
            "name": "IBM",
            "bit_range": "10:9",
            "attr": "RW",
            "reset": "0x0",
            "description": "I2S bus mode\n(Can be written only when XFER[1] bit is 0.)\n0:I2S normal\n1:I2S Left justified\n2:I2S Right justified\n3:reserved"
          },
          {
            "name": "PBM",
            "bit_range": "8:7",
            "attr": "RW",
            "reset": "0x0",
            "description": "PCM bus mode\n(Can be written only when XFER[1] bit is 0.)\n0:PCM no delay mode\n1:PCM delay 1 mode\n2:PCM delay 2 mode\n3:PCM delay 3 mode"
          },
          {
            "name": "RESERVED",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFS",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transfer format select\n(Can be written only when XFER[1] bit is 0.)\n0:i2s\n1:pcm"
          },
          {
            "name": "VDW",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x0f",
            "description": "Valid Data width\n(Can be written only when XFER[1] bit is 0.)\n0~14:reserved\n15:16bit\n16:17bit\n17:18bit\n18:19bit\n......\nn:(n+1)bit\n......\n28:29bit\n29:30bit\n30:31bit\n31:32bit"
          }
        ],
        "description": "receive operation control register"
      },
      {
        "type": "register",
        "name": "I2S_CKR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00071f1f",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TRCM",
            "bit_range": "29:28",
            "attr": "RW",
            "reset": "0x0",
            "description": "Tx and Rx Common Use\n2'b00/2'b11:tx_lrck/rx_lrck are used as synchronous signal for\nTX /RX respectively.\n2'b01:only tx_lrck is used as synchronous signal for TX and RX.\n2'b10:only rx_lrck is used as synchronous signal for TX and RX."
          },
          {
            "name": "MSS",
            "bit_range": "27",
            "attr": "RW",
            "reset": "0x0",
            "description": "Master/slave mode select\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\n0:master mode(sclk output)\n1:slave mode(sclk input)"
          },
          {
            "name": "CKP",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "Sclk polarity\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\n0: sample data at posedge sclk and drive data at negedge sclk\n1: sample data at negedge sclk and drive data at posedge sclk"
          },
          {
            "name": "RLP",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive lrck polarity\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\n0:normal polarity\n(I2S normal: low for left channel, high for right channel\nI2S left/right just: high for left channel, low for right channel\nPCM start signal: high valid)\n1:oppsite polarity\n(I2S normal: high for left channel, low for right channel\nI2S left/right just: low for left channel, high for right channel\nPCM start signal: low valid)"
          },
          {
            "name": "TLP",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit lrck polarity\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\n0:normal polarity\n(I2S normal: low for left channel, high for right channel\nI2S left/right just: high for left channel, low for right channel\nPCM start signal: high valid)\n1:oppsite polarity\n(I2S normal: high for left channel, low for right channel\nI2S left/right just: low for left channel, high for right channel\nPCM start signal: low valid)"
          },
          {
            "name": "MDIV",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x07",
            "description": "mclk divider\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\nSerial Clock Divider = Fmclk / Ftxsclk-1.(mclk frequecy / txsclk\nfrequecy-1)\n0   :Fmclk=Ftxsclk;\n1   :Fmclk=2*Ftxsclk;\n2,3  :Fmclk=4*Ftxsclk;\n4,5  :Fmclk=6*Ftxsclk;\n......\n2n,2n+1:Fmclk=(2n+2)*Ftxsclk;\n......\n60,61:Fmclk=62*Ftxsclk;\n62,63:Fmclk=64*Ftxsclk;\n......\n252,253:Fmclk=254*Ftxsclk;\n254,255:Fmclk=256*Ftxsclk;"
          },
          {
            "name": "RSD",
            "bit_range": "15:8",
            "attr": "RW",
            "reset": "0x1f",
            "description": "Receive sclk divider\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\nReceive sclk divider= Fsclk/Frxlrck\n0~30:reserved\n31:  32fs\n32:  33fs\n33:  34fs\n34:  35fs\n......\nn:  (n+1)fs\n......\n253:   254fs\n254:   255fs\n255:   256fs"
          },
          {
            "name": "TSD",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x1f",
            "description": "Transmit sclk divider\n(Can be written only when XFER[1] or XFER[0] bit is 0.)\nTransmit sclk divider=Ftxsclk/Ftxlrck\n0~30:reserved\n31:  32fs\n32:  33fs\n33:  34fs\n34:  35fs\n......\nn:  (n+1)fs\n......\n253:   254fs\n254:   255fs\n255:   256fs"
          }
        ],
        "description": "clock generation register"
      },
      {
        "type": "register",
        "name": "I2S_TXFIFOLR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFL3",
            "bit_range": "23:18",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO3 Level\nContains the number of valid data entries in the transmit FIFO3."
          },
          {
            "name": "TFL2",
            "bit_range": "17:12",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO2 Level\nContains the number of valid data entries in the transmit FIFO2."
          },
          {
            "name": "TFL1",
            "bit_range": "11:6",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO1 Level\nContains the number of valid data entries in the transmit FIFO1."
          },
          {
            "name": "TFL0",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO0 Level\nContains the number of valid data entries in the transmit FIFO0."
          }
        ],
        "description": "TX FIFO level register"
      },
      {
        "type": "register",
        "name": "I2S_DMACR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x001f0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RDE",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive DMA Enable\n0 : Receive DMA disabled\n1 : Receive DMA enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "23:21",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RDL",
            "bit_range": "20:16",
            "attr": "RW",
            "reset": "0x1f",
            "description": "Receive Data Level\nThis bit field controls the level at which a DMA request is made\nby the receive logic. The watermark level = DMARDL+1; that is,\ndma_rx_req is generated when the number of valid data entries\nin the receive FIFO (RXFIFO0 if RCSR=00;RXFIFO1 if\nRCSR=01,RXFIFO2 if RCSR=10,RXFIFO3 if RCSR=11)is equal to\nor above this field value + 1."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TDE",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit DMA Enable\n0 : Transmit DMA disabled\n1 : Transmit DMA enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TDL",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit Data Level\nThis bit field controls the level at which a DMA request is made by\nthe transmit logic. It is equal to the watermark level; that is, the\ndma_tx_req signal is generated when the number of valid data\nentries in the TXFIFO(TXFIFO0 if TCSR=00;TXFIFO1 if\nTCSR=01,TXFIFO2 if TCSR=10,TXFIFO3 if TCSR=11)is equal to\nor below this field value."
          }
        ],
        "description": "DMA control register"
      },
      {
        "type": "register",
        "name": "I2S_INTCR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFT",
            "bit_range": "24:20",
            "attr": "RW",
            "reset": "0x00",
            "description": "Receive FIFO Threshold\nWhen the number of receive FIFO entries  (RXFIFO0 if RCSR=00;\nRXFIFO1 if RCSR=01, RXFIFO2 if RCSR=10, RXFIFO3 if\nRCSR=11) is more than or equal to this threshold plus 1, the\nreceive FIFO full interrupt is triggered."
          },
          {
            "name": "RESERVED",
            "bit_range": "19",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXOIC",
            "bit_range": "18",
            "attr": "WO",
            "reset": "0x0",
            "description": "RX overrun interrupt clear\nWrite 1 to clear RX overrun interrupt."
          },
          {
            "name": "RXOIE",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX overrun interrupt enable\n0:disable\n1:enable"
          },
          {
            "name": "RXFIE",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX full interrupt enable\n0:disable\n1:enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFT",
            "bit_range": "8:4",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit FIFO Threshold\nWhen the number of transmit FIFO (TXFIFO0 if TCSR=00;\nTXFIFO1 if TCSR=01, TXFIFO2 if TCSR=10, TXFIFO3 if TCSR=11)\nentries is less than or equal to this threshold, the transmit FIFO\nempty interrupt is triggered."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TXUIC",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "TX underrun interrupt clear\nWrite 1 to clear TX underrun interrupt."
          },
          {
            "name": "TXUIE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX underrun interrupt enable\n0:disable\n1:enable"
          },
          {
            "name": "TXEIE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX empty interrupt enable\n0:disable\n1:enable"
          }
        ],
        "description": "interrupt control register"
      },
      {
        "type": "register",
        "name": "I2S_INTSR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXOI",
            "bit_range": "17",
            "attr": "RO",
            "reset": "0x0",
            "description": "RX overrun interrupt\n0:inactive\n1:active"
          },
          {
            "name": "RXFI",
            "bit_range": "16",
            "attr": "RO",
            "reset": "0x0",
            "description": "RX full interrupt\n0:inactive\n1:active"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TXUI",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "TX underrun interrupt\n0:inactive\n1:active"
          },
          {
            "name": "TXEI",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "TX empty interrupt\n0:inactive\n1:active"
          }
        ],
        "description": "interrupt status register"
      },
      {
        "type": "register",
        "name": "I2S_XFER",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXS",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX Transfer start bit\n0:stop RX transfer.\n1:start RX transfer"
          },
          {
            "name": "TXS",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX Transfer start bit\n0:stop TX transfer.\n1:start TX transfer"
          }
        ],
        "description": "Transfer Start Register"
      },
      {
        "type": "register",
        "name": "I2S_CLR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXC",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "RX logic clear\nThis is a self cleared bit. Write 1 to clear all receive logic."
          },
          {
            "name": "TXC",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "TX logic clear\nThis is a self cleared bit. Write 1 to clear all transmit logic."
          }
        ],
        "description": "SCLK domain logic clear Register"
      },
      {
        "type": "register",
        "name": "I2S_TXDR",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXDR",
            "bit_range": "31:0",
            "attr": "WO",
            "reset": "0x00000000",
            "description": "Transmit FIFO Data Register\nWhen it is written to, data are moved into the transmit FIFO."
          }
        ],
        "description": "Transmit FIFO Data Register"
      },
      {
        "type": "register",
        "name": "I2S_RXDR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXDR",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Receive FIFO Data Register\nWhen the register is read, data in the receive FIFO is accessed."
          }
        ],
        "description": "Receive FIFO Data Register"
      },
      {
        "type": "register",
        "name": "I2S_RXFIFOLR",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFL3",
            "bit_range": "23:18",
            "attr": "RO",
            "reset": "0x00",
            "description": "Receive FIFO3 Level\nContains the number of valid data entries in the receive FIFO3."
          },
          {
            "name": "RFL2",
            "bit_range": "17:12",
            "attr": "RO",
            "reset": "0x00",
            "description": "Receive FIFO2 Level\nContains the number of valid data entries in the receive FIFO2."
          },
          {
            "name": "RFL1",
            "bit_range": "11:6",
            "attr": "RU",
            "reset": "0x00",
            "description": "Receive FIFO1 Level\nContains the number of valid data entries in the receive FIFO1."
          },
          {
            "name": "RFL0",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Receive FIFO0 Level\nContains the number of valid data entries in the receive FIFO0."
          }
        ],
        "description": "RX FIFO level register"
      }
    ],
    "name": "I2S",
    "summary": [
      {
        "name": "I2S_TXCR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x0000000f",
        "description": "transmit operation control register"
      },
      {
        "name": "I2S_RXCR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x0000000f",
        "description": "receive operation control register"
      },
      {
        "name": "I2S_CKR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00071f1f",
        "description": "clock generation register"
      },
      {
        "name": "I2S_TXFIFOLR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "TX FIFO level register"
      },
      {
        "name": "I2S_DMACR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x001f0000",
        "description": "DMA control register"
      },
      {
        "name": "I2S_INTCR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "interrupt control register"
      },
      {
        "name": "I2S_INTSR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "interrupt status register"
      },
      {
        "name": "I2S_XFER",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transfer Start Register"
      },
      {
        "name": "I2S_CLR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "SCLK domain logic clear Register"
      },
      {
        "name": "I2S_TXDR",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Data Register"
      },
      {
        "name": "I2S_RXDR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Data Register"
      },
      {
        "name": "I2S_RXFIFOLR",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "RX FIFO level register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "SPI_CTRLR0",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000002",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MTM",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "Microwire Transfer Mode\nValid when frame format is set to National Semiconductors\nMicrowire.\n1'b0: non-sequential transfer\n1'b1: sequential transfer"
          },
          {
            "name": "OPM",
            "bit_range": "20",
            "attr": "RW",
            "reset": "0x0",
            "description": "Operation Mode\n1'b0: Master Mode\n1'b1: Slave Mode"
          },
          {
            "name": "XFM",
            "bit_range": "19:18",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transfer Mode\n2'b00 :Transmit & Receive\n2'b01 : Transmit Only\n2'b10 : Receive Only\n2'b11 :reserved"
          },
          {
            "name": "FRF",
            "bit_range": "17:16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Frame Format\n2'b00: Motorola SPI\n2'b01: Texas Instruments SSP\n2'b10: National Semiconductors Microwire\n2'b11 : Reserved"
          },
          {
            "name": "RSD",
            "bit_range": "15:14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Rxd Sample Delay\nWhen SPI is configured as a master, if the rxd data cannot be\nsampled by the sclk_out edge at the right time, this register\nshould be configured to define the number of the spi_clk cycles\nafter the active sclk_out edge to sample rxd data later when SPI\nworks at high frequency.\n2'b00:do not delay\n2'b01:1 cycle delay\n2'b10:2 cycles delay\n2'b11:3 cycles delay"
          },
          {
            "name": "BHT",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Byte and Halfword Transform\nValid when data frame size is 8bit.\n1'b0:apb 16bit write/read, spi 8bit write/read\n1'b1: apb 8bit write/read, spi 8bit write/read"
          },
          {
            "name": "FBM",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "First Bit Mode\n1'b0:first bit is MSB\n1'b1:first bit is LSB"
          },
          {
            "name": "EM",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Endian Mode\nSerial endian mode can be configured by this bit. Apb endian\nmode is always little endian.\n1'b0:little endian\n1'b1:big endian"
          },
          {
            "name": "SSD",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "ss_n to sclk_out delay\nValid when the frame format is set to Motorola SPI and SPI used\nas a master.\n1'b0: the period between ss_n active and sclk_out active is half\nsclk_out cycles.\n1'b1: the period between ss_n active and sclk_out active is one\nsclk_out cycle."
          },
          {
            "name": "CSM",
            "bit_range": "9:8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Chip Select Mode\nValid when the frame format is set to Motorola SPI and SPI used\nas a master.\n2'b00: ss_n keep low after every frame data is transferred.\n2'b01:ss_n be high for half sclk_out cycles after every frame data\nis transferred.\n2'b10: ss_n be high for one sclk_out cycle after every frame data\nis transferred.\n2'b11:reserved"
          },
          {
            "name": "SCPOL",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Serial Clock Polarity\nValid when the frame format is set to Motorola SPI.\n1'b0: Inactive state of serial clock is low\n1'b1: Inactive state of serial clock is high"
          },
          {
            "name": "SCPH",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Serial Clock Phase\nValid when the frame format is set to Motorola SPI.\n1'b0: Serial clock toggles in middle of first data bit\n1'b1: Serial clock toggles at start of first data bit"
          },
          {
            "name": "CFS",
            "bit_range": "5:2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Control Frame Size\nSelects the length of the control word for the Microwire frame\nformat.\n4'b0000~0010:reserved\n4'b0011:4-bit serial data transfer\n4'b0100:5-bit serial data transfer\n4'b0101:6-bit serial data transfer\n4'b0110:7-bit serial data transfer\n4'b0111:8-bit serial data transfer\n4'b1000:9-bit serial data transfer\n4'b1001:10-bit serial data transfer\n4'b1010:11-bit serial data transfer\n4'b1011:12-bit serial data transfer\n4'b1100:13-bit serial data transfer\n4'b1101:14-bit serial data transfer\n4'b1110:15-bit serial data transfer\n4'b1111:16-bit serial data transfer"
          },
          {
            "name": "DFS",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x2",
            "description": "Data Frame Size\nSelects the data frame length.\n2'b00:4bit data\n2'b01:8bit data\n2'b10:16bit data\n2'b11:reserved"
          }
        ],
        "description": "Control Register 0"
      },
      {
        "type": "register",
        "name": "SPI_CTRLR1",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "NDM",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Number of Data Frames\nWhen Transfer Mode is receive only, this register field sets the\nnumber of data frames to be continuously received by the SPI.\nThe SPI continues to receive serial data until the number of data\nframes received is equal to this register value plus 1, which\nenables you to receive up to 64 KB of data in a continuous\ntransfer."
          }
        ],
        "description": "Control Register 1"
      },
      {
        "type": "register",
        "name": "SPI_ENR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ENR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "SPI Enable\n1\u2019b1: Enable all SPI operations.\n1\u2019b0: Disable all SPI operations\nTransmit and receive FIFO buffers are cleared when the device is\ndisabled."
          }
        ],
        "description": "SPI Enable"
      },
      {
        "type": "register",
        "name": "SPI_SER",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SER1",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Slave 1 Select Enable\n1\u2019b1: Enable chip select 1\n1\u2019b0: Disable chip select 1\nThis register is valid only when SPI is configured as a master\ndevice."
          },
          {
            "name": "SER0",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Slave Select Enable\n1\u2019b1: Enable chip select 0\n1\u2019b0: Disable chip select 0\nThis register is valid only when SPI is configured as a master\ndevice."
          }
        ],
        "description": "Slave Enable Register"
      },
      {
        "type": "register",
        "name": "SPI_BAUDR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BAUDR",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Baud Rate Select\nSPI Clock Divider.\nThis register is valid only when the SPI is configured as a master\ndevice.\nThe LSB for this field is always set to 0 and is unaffected by a\nwrite operation, which ensures an even value is held in this\nregister.\nIf the value is 0, the serial output clock (sclk_out) is disabled.\nThe frequency of the sclk_out is derived from the following\nequation:\nFsclk_out = Fspi_clk/ SCKDV\nWhere SCKDV is any even value between 2 and 65534.\nFor example:\nfor Fspi_clk = 3.6864MHz and SCKDV =2\nFsclk_out = 3.6864/2= 1.8432MHz"
          }
        ],
        "description": "Baud Rate Select"
      },
      {
        "type": "register",
        "name": "SPI_TXFTLR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TXFTLR",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit FIFO Threshold Level\nWhen the number of transmit FIFO entries is less than or equal to\nthis value, the transmit FIFO empty interrupt is triggered."
          }
        ],
        "description": "Transmit FIFO Threshold Level"
      },
      {
        "type": "register",
        "name": "SPI_RXFTLR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXFTLR",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Receive FIFO Threshold Level\nWhen the number of receive FIFO entries is greater than or equal\nto this value + 1, the receive FIFO full interrupt is triggered."
          }
        ],
        "description": "Receive FIFO Threshold Level"
      },
      {
        "type": "register",
        "name": "SPI_TXFLR",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TXFLR",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Transmit FIFO Level\nContains the number of valid data entries in the transmit FIFO."
          }
        ],
        "description": "Transmit FIFO Level"
      },
      {
        "type": "register",
        "name": "SPI_RXFLR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXFLR",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Receive FIFO Level\nContains the number of valid data entries in the receive FIFO."
          }
        ],
        "description": "Receive FIFO Level"
      },
      {
        "type": "register",
        "name": "SPI_SR",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x0000000c",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFF",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Full\n1'b0: Receive FIFO is not full\n1'b1: Receive FIFO is full"
          },
          {
            "name": "RFE",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x1",
            "description": "Receive FIFO Empty\n1'b0: Receive FIFO is not empty\n1'b1: Receive FIFO is empty"
          },
          {
            "name": "TFE",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x1",
            "description": "Transmit FIFO Empty\n1'b0: Transmit FIFO is not empty\n1'b1: Transmit FIFO is empty"
          },
          {
            "name": "TFF",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Full\n1'b0: Transmit FIFO is not full\n1'b1: Transmit FIFO is full"
          },
          {
            "name": "BSF",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "SPI Busy Flag\nWhen set, indicates that a serial transfer is in progress; when\ncleared indicates that the SPI is idle or disabled.\n1'b0: SPI is idle or disabled\n1'b1: SPI is actively transferring data"
          }
        ],
        "description": "SPI Status"
      },
      {
        "type": "register",
        "name": "SPI_IPR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "IPR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Interrupt Polarity\nInterrupt Polarity Register\n1'b0:Active Interrupt Polarity Level is HIGH\n1'b1: Active Interrupt Polarity Level is LOW"
          }
        ],
        "description": "Interrupt Polarity"
      },
      {
        "type": "register",
        "name": "SPI_IMR",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFFIM",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive FIFO Full Interrupt Mask\n1'b0: spi_rxf_intr interrupt is masked\n1'b1: spi_rxf_intr interrupt is not masked"
          },
          {
            "name": "RFOIM",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive FIFO Overflow Interrupt Mask\n1'b0: spi_rxo_intr interrupt is masked\n1'b1: spi_rxo_intr interrupt is not masked"
          },
          {
            "name": "RFUIM",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive FIFO Underflow Interrupt Mask\n1'b0: spi_rxu_intr interrupt is masked\n1'b1: spi_rxu_intr interrupt is not masked"
          },
          {
            "name": "TFOIM",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit FIFO Overflow Interrupt Mask\n1'b0: spi_txo_intr interrupt is masked\n1'b1: spi_txo_intr interrupt is not masked"
          },
          {
            "name": "TFEIM",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit FIFO Empty Interrupt Mask\n1'b0: spi_txe_intr interrupt is masked\n1'b1: spi_txe_intr interrupt is not masked"
          }
        ],
        "description": "Interrupt Mask"
      },
      {
        "type": "register",
        "name": "SPI_ISR",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFFIS",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Full Interrupt Status\n1'b0: spi_rxf_intr interrupt is not active after masking\n1'b1: spi_rxf_intr interrupt is full after masking"
          },
          {
            "name": "RFOIS",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Overflow Interrupt Status\n1'b0: spi_rxo_intr interrupt is not active after masking\n1'b1: spi_rxo_intr interrupt is active after masking"
          },
          {
            "name": "RFUIS",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Underflow Interrupt Status\n1'b0: spi_rxu_intr interrupt is not active after masking\n1'b1: spi_rxu_intr interrupt is active after masking"
          },
          {
            "name": "TFOIS",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Overflow Interrupt Status\n1'b0: spi_txo_intr interrupt is not active after masking\n1'b1: spi_txo_intr interrupt is active after masking"
          },
          {
            "name": "TFEIS",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Empty Interrupt Status\n1'b0: spi_txe_intr interrupt is not active after masking\n1'b1: spi_txe_intr interrupt is active after masking"
          }
        ],
        "description": "Interrupt Status"
      },
      {
        "type": "register",
        "name": "SPI_RISR",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000001",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFFRIS",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Full Raw Interrupt Status\n1'b0: spi_rxf_intr interrupt is not active prior to masking\n1'b1: spi_rxf_intr interrupt is full prior to masking"
          },
          {
            "name": "RFORIS",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Overflow Raw Interrupt Status\n1'b0 = spi_rxo_intr interrupt is not active prior to masking\n1'b1 = spi_rxo_intr interrupt is active prior to masking"
          },
          {
            "name": "RFURIS",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive FIFO Underflow Raw Interrupt Status\n1'b0: spi_rxu_intr interrupt is not active prior to masking\n1'b1: spi_rxu_intr interrupt is active prior to masking"
          },
          {
            "name": "TFORIS",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit FIFO Overflow Raw Interrupt Status\n1'b0: spi_txo_intr interrupt is not active prior to masking\n1'b1: spi_txo_intr interrupt is active prior to masking"
          },
          {
            "name": "TFERIS",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x1",
            "description": "Transmit FIFO Empty Raw Interrupt Status\n1'b0: spi_txe_intr interrupt is not active prior to masking\n1'b1: spi_txe_intr interrupt is active prior to masking"
          }
        ],
        "description": "Raw Interrupt Status"
      },
      {
        "type": "register",
        "name": "SPI_ICR",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CTFOI",
            "bit_range": "3",
            "attr": "WO",
            "reset": "0x0",
            "description": "Clear Transmit FIFO Overflow Interrupt\nWrite 1 to Clear Transmit FIFO Overflow Interrupt"
          },
          {
            "name": "CRFOI",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "Clear Receive FIFO Overflow Interrupt\nWrite 1 to Clear Receive FIFO Overflow Interrupt"
          },
          {
            "name": "CRFUI",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "Clear Receive FIFO Underflow Interrupt\nWrite 1 to Clear Receive FIFO Underflow Interrupt"
          },
          {
            "name": "CCI",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "Clear Combined Interrupt\nWrite 1 to Clear Combined Interrupt"
          }
        ],
        "description": "Interrupt Clear"
      },
      {
        "type": "register",
        "name": "SPI_DMACR",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TDE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit DMA Enable\n1'b0: Transmit DMA disabled\n1'b1: Transmit DMA enabled"
          },
          {
            "name": "RDE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive DMA Enable\n1'b0: Receive DMA disabled\n1'b1: Receive DMA enabled"
          }
        ],
        "description": "DMA Control"
      },
      {
        "type": "register",
        "name": "SPI_DMATDLR",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TDL",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit Data Level\nThis bit field controls the level at which a DMA request is made by\nthe transmit logic. It is equal to the watermark level; that is, the\ndma_tx_req signal is generated when the number of valid data\nentries in the transmit FIFO is equal to or below this field value,\nand Transmit DMA Enable (DMACR[1]) = 1."
          }
        ],
        "description": "DMA Transmit Data Level"
      },
      {
        "type": "register",
        "name": "SPI_DMARDLR",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RDL",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Receive Data Level\nThis bit field controls the level at which a DMA request is made by\nthe receive logic. The watermark level = DMARDL+1; that is,\ndma_rx_req is generated when the number of valid data entries\nin the receive FIFO is equal to or above this field value + 1, and\nReceive DMA Enable(DMACR[0])=1."
          }
        ],
        "description": "DMA Receive Data Level"
      },
      {
        "type": "register",
        "name": "SPI_TXDR",
        "offset": "0x0400",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TXDR",
            "bit_range": "15:0",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Transimt FIFO Data Register.\nWhen it is written to, data are moved into the transmit FIFO."
          }
        ],
        "description": "Transmit FIFO Data"
      },
      {
        "type": "register",
        "name": "SPI_RXDR",
        "offset": "0x0800",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RXDR",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Receive FIFO Data Register.\nWhen the register is read, data in the receive FIFO is accessed."
          }
        ],
        "description": "Receive FIFO Data"
      }
    ],
    "name": "SPI",
    "summary": [
      {
        "name": "SPI_CTRLR0",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000002",
        "description": "Control Register 0"
      },
      {
        "name": "SPI_CTRLR1",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Control Register 1"
      },
      {
        "name": "SPI_ENR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "SPI Enable"
      },
      {
        "name": "SPI_SER",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Slave Enable Register"
      },
      {
        "name": "SPI_BAUDR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Baud Rate Select"
      },
      {
        "name": "SPI_TXFTLR",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Threshold Level"
      },
      {
        "name": "SPI_RXFTLR",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Threshold Level"
      },
      {
        "name": "SPI_TXFLR",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Level"
      },
      {
        "name": "SPI_RXFLR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Level"
      },
      {
        "name": "SPI_SR",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x0000000c",
        "description": "SPI Status"
      },
      {
        "name": "SPI_IPR",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Polarity"
      },
      {
        "name": "SPI_IMR",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Mask"
      },
      {
        "name": "SPI_ISR",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Status"
      },
      {
        "name": "SPI_RISR",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000001",
        "description": "Raw Interrupt Status"
      },
      {
        "name": "SPI_ICR",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Clear"
      },
      {
        "name": "SPI_DMACR",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "DMA Control"
      },
      {
        "name": "SPI_DMATDLR",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "description": "DMA Transmit Data Level"
      },
      {
        "name": "SPI_DMARDLR",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000000",
        "description": "DMA Receive Data Level"
      },
      {
        "name": "SPI_TXDR",
        "offset": "0x0400",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit FIFO Data"
      },
      {
        "name": "SPI_RXDR",
        "offset": "0x0800",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive FIFO Data"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "SPDIF_CFGR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MCD",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "mclk divider\nFmclk/Fsdo\nThis parameter can be calculated by Fmclk/(Fs*128).\nFs=the sample frequency be wanted"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PCMTYPE",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "PCM type\n0: linear PCM\n1: non-linear PCM"
          },
          {
            "name": "CLR",
            "bit_range": "7",
            "attr": "WO",
            "reset": "0x0",
            "description": "mclk domain logic clear\nWrite 1 to clear mclk domain logic. Read return zero."
          },
          {
            "name": "CSE",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Channel status enable\n0: disable\n1: enable\nThe bit should be set to 1 when the channel conveys non-linear\nPCM"
          },
          {
            "name": "UDE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "User data enable\n0: disable\n1: enable"
          },
          {
            "name": "VFE",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Validity flag enable\n0: disable\n1: enable"
          },
          {
            "name": "ADJ",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "audio data justified\n0: Right justified\n1: Left justified"
          },
          {
            "name": "HWT",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Halfword word transform enable\n0: disable\n1: enable\nIt is valid only when the valid data width is 16bit."
          },
          {
            "name": "VDW",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Valid data width\n00: 16bit\n01: 20bit\n10: 24bit\n11: reserved\nThe valid data width is 16bit only for non-linear PCM"
          }
        ],
        "description": "Transfer Configuration Register"
      },
      {
        "type": "register",
        "name": "SPDIF_SDBLR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDBLR",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Sample Date Buffer Level Register\nContains the number of valid data entries in the sample data\nbuffer."
          }
        ],
        "description": "Sample Date Buffer Level Register"
      },
      {
        "type": "register",
        "name": "SPDIF_DMACR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TDE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit DMA Enable\n0: Transmit DMA disabled\n1: Transmit DMA enabled"
          },
          {
            "name": "TDL",
            "bit_range": "4:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Transmit Data Level\nThis bit field controls the level at which a DMA request is made by\nthe transmit logic. It is equal to the watermark level; that is, the\ndma_tx_req signal is generated when the number of valid data\nentries in the Sample Date Buffer is equal to or below this field\nvalue"
          }
        ],
        "description": "DMA Control Register"
      },
      {
        "type": "register",
        "name": "SPDIF_INTCR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "UDTIC",
            "bit_range": "17",
            "attr": "W1C",
            "reset": "0x0",
            "description": "User Data Interrupt Clear\nWrite '1' to clear the user data interrupt."
          },
          {
            "name": "BTTIC",
            "bit_range": "16",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Block/Data burst transfer finish interrupt clear\nWrite 1 to clear the interrupt."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDBT",
            "bit_range": "9:5",
            "attr": "RW",
            "reset": "0x00",
            "description": "Sample Date Buffer Threshold\nSample Date Buffer Threshold for empty interrupt"
          },
          {
            "name": "SDBEIE",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Sample Date Buffer empty interrupt enable\n0: disable\n1: enable"
          },
          {
            "name": "BTTIE",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Block transfer/repetition period end interrupt enable\nWhen enabled, an interrupt will be asserted when the block\ntransfer is finished if the channel conveys linear PCM or when the\nrepetition period is reached if the channel conveys non-linear\nPCM.\n0: disable\n1: enable"
          },
          {
            "name": "UDTIE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "User Data Interrupt\n0: disable\n1: enable\nIf enabled, an interrupt will be asserted when the content of the\nuser data register is fed into the corresponding shadow register"
          },
          {
            "name": "RESERVED",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Interrupt Control Register"
      },
      {
        "type": "register",
        "name": "SPDIF_INTSR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDBEIS",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Sample Date Buffer empty interrupt status\n0: inactive\n1: active"
          },
          {
            "name": "BTTIS",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Block/Data burst transfer interrupt status\n0: inactive\n1: active"
          },
          {
            "name": "UDTIS",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "User Data Interrupt Status\n0: inactive\n1: active"
          },
          {
            "name": "RESERVED",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Interrupt Status Register"
      },
      {
        "type": "register",
        "name": "SPDIF_XFER",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "XFER",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transfer Start Register\nTransfer Start Register"
          }
        ],
        "description": "Transfer Start Register"
      },
      {
        "type": "register",
        "name": "SPDIF_SMPDR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "SMPDR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Sample Data Register\nSample Data Register"
          }
        ],
        "description": "Sample Data Register"
      },
      {
        "type": "register",
        "name": "SPDIF_VLDFRn",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "VLDFR_SUB_1",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Validity Flag Subframe 1\nValidity Flag Register 0"
          },
          {
            "name": "VLDFR_SUB_0",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Validity Flag Subframe 0\nValidity Flag for Subframe 0"
          }
        ],
        "description": "Validity Flag Register n"
      },
      {
        "type": "register",
        "name": "SPDIF_USRDRn",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "USR_SUB_1",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "User Data Subframe 1\nUser Data Bit for Subframe 1"
          },
          {
            "name": "USR_SUB_0",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "User Data Subframe 0\nUser Data Bit for Subframe 0"
          }
        ],
        "description": "User Data Register n"
      },
      {
        "type": "register",
        "name": "SPDIF_CHNSRn",
        "offset": "0x00c0",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CHNSR_SUB_1",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Channel Status Subframe 1\nChannel Status Bit for Subframe 1"
          },
          {
            "name": "CHNSR_SUB_0",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Channel Status Subframe 0\nChannel Status Bit for Subframe 0"
          }
        ],
        "description": "Channel Status Register n"
      },
      {
        "type": "register",
        "name": "SPDIF_BURTSINFO",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PD",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "pd\nPreamble Pd for non-linear pcm, indicating the length of burst\npayload in unit of bytes or bits."
          },
          {
            "name": "BSNUM",
            "bit_range": "15:13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Bitstream Number\nThis field indicates the bitstream number. Usually the bitstream\nnumber is 0."
          },
          {
            "name": "DATAINFO",
            "bit_range": "12:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Data-type-dependent info\nThis field gives the data-type-dependent info"
          },
          {
            "name": "ERRFLAG",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Error Flag\n0: indicates a valid burst-payload\n1: indicates that the burst-payload may contain errors"
          },
          {
            "name": "DATATYPE",
            "bit_range": "6:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Data type\n0000000: null data\n0000001: AC-3 data\n0000011: Pause data\n0000100: MPEG-1 layer 1 data\n0000101: MPEG-1 layer 2 or 3 data or MPEG-2 without extension\n0000110: MPEG-2 data with extension\n0000111: MPEG-2 AAC\n0001000: MPEG-2, layer-1 low sampling frequency\n0001001: MPEG-2, layer-2 low sampling frequency\n0001010: MPEG-2, layer-3 low sampling frequency\n0001011: DTS type I\n0001100: DTS type II\n0001101: DTS type III\n0001110: ATRAC\n0001111: ATRAC 2/3\n0010000: ATRAC-X\n0010001: DTS type IV\n0010010: WMA professional type I\n0110010: WMA professional type II\n1010010: WMA professional type III\n1110010: WMA professional type IV\n0010011: MPEG-2 AAC low sampling frequency\n0110011: MPEG-2 AAC low sampling frequency\n1010011: MPEG-2 AAC low sampling frequency\n1110011: MPEG-2 AAC low sampling frequency\n0010100: MPEG-4 AAC\n0110100: MPEG-4 AAC\n1010100: MPEG-4 AAC\n1110100: MPEG-4 AAC\n0010101: Enhanced AC-3\n0010110: MAT\nothers: reserved"
          }
        ],
        "description": "Channel Burst Info Register"
      },
      {
        "type": "register",
        "name": "SPDIF_REPETTION",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "REPETTION",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Repetition\nThis define the repetition period when the channel conveys non-\nlinear PCM"
          }
        ],
        "description": "Channel Repetition Register"
      },
      {
        "type": "register",
        "name": "SPDIF_BURTSINFO_SHD",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PD",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0000",
            "description": "pd\nPreamble Pd for non-linear pcm, indicating the length of burst\npayload in unit of bytes or bits."
          },
          {
            "name": "BSNUM",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "Bitstream Number\nThis field indicates the bitstream number. Usually the birstream\nnumber is 0."
          },
          {
            "name": "DATAINFO",
            "bit_range": "12:8",
            "attr": "RO",
            "reset": "0x00",
            "description": "Data-type-dependent info\nThis field gives the data-type-dependent info"
          },
          {
            "name": "ERRFLAG",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Error Flag\n0: indicates a valid burst-payload\n1: indicates that the burst-payload may contain errors"
          },
          {
            "name": "DATATYPE",
            "bit_range": "6:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Data type\n0000000: null data\n0000001: AC-3 data\n0000011: Pause data\n0000100: MPEG-1 layer 1 data\n0000101: MPEG-1 layer 2 or 3 data or MPEG-2 without extension\n0000110: MPEG-2 data with extension\n0000111: MPEG-2 AAC\n0001000: MPEG-2, layer-1 low sampling frequency\n0001001: MPEG-2, layer-2 low sampling frequency\n0001010: MPEG-2, layer-3 low sampling frequency\n0001011: DTS type I\n0001100: DTS type II\n0001101: DTS type III\n0001110: ATRAC\n0001111: ATRAC 2/3\n0010000: ATRAC-X\n0010001: DTS type IV\n0010010: WMA professional type I\n0110010: WMA professional type II\n1010010: WMA professional type III\n1110010: WMA professional type IV\n0010011: MPEG-2 AAC low sampling frequency\n0110011: MPEG-2 AAC low sampling frequency\n1010011: MPEG-2 AAC low sampling frequency\n1110011: MPEG-2 AAC low sampling frequency\n0010100: MPEG-4 AAC\n0110100: MPEG-4 AAC\n1010100: MPEG-4 AAC\n1110100: MPEG-4 AAC\n0010101: Enhanced AC-3\n0010110: MAT\nothers: reserved"
          }
        ],
        "description": "Shadow Channel Burst Info Register"
      },
      {
        "type": "register",
        "name": "SPDIF_REPETTION_SHD",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "REPETTION",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0000",
            "description": "Repetition\nThis register provides the repetition of the bitstream when\nchannel conveys non-linear PCM. In the design, it defines the\nlength between Pa of the two consecutive data-burst. For the\nsame audio format, the definition is different. Please convert the\nactual repetition in order to comply with the design."
          }
        ],
        "description": "Shadow Channel Repetition Register"
      },
      {
        "type": "register",
        "name": "SPDIF_USRDR_SHDn",
        "offset": "0x0190",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "USR_SUB_1",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0000",
            "description": "User Data Subframe 1\nUser Data Bit for Subframe 1"
          },
          {
            "name": "USR_SUB_0",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0000",
            "description": "User Data Subframe 0\nUser Data Bit for Subframe 0"
          }
        ],
        "description": "Shadow User Data Register n"
      }
    ],
    "name": "SPDIF",
    "summary": [
      {
        "name": "SPDIF_CFGR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transfer Configuration Register"
      },
      {
        "name": "SPDIF_SDBLR",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Sample Date Buffer Level Register"
      },
      {
        "name": "SPDIF_DMACR",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "DMA Control Register"
      },
      {
        "name": "SPDIF_INTCR",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Control Register"
      },
      {
        "name": "SPDIF_INTSR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Status Register"
      },
      {
        "name": "SPDIF_XFER",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transfer Start Register"
      },
      {
        "name": "SPDIF_SMPDR",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "Sample Data Register"
      },
      {
        "name": "SPDIF_VLDFRn",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "description": "Validity Flag Register n"
      },
      {
        "name": "SPDIF_USRDRn",
        "offset": "0x0090",
        "size": "W",
        "reset": "0x00000000",
        "description": "User Data Register n"
      },
      {
        "name": "SPDIF_CHNSRn",
        "offset": "0x00c0",
        "size": "W",
        "reset": "0x00000000",
        "description": "Channel Status Register n"
      },
      {
        "name": "SPDIF_BURTSINFO",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "description": "Channel Burst Info Register"
      },
      {
        "name": "SPDIF_REPETTION",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "description": "Channel Repetition Register"
      },
      {
        "name": "SPDIF_BURTSINFO_SHD",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Channel Burst Info Register"
      },
      {
        "name": "SPDIF_REPETTION_SHD",
        "offset": "0x010c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow Channel Repetition Register"
      },
      {
        "name": "SPDIF_USRDR_SHDn",
        "offset": "0x0190",
        "size": "W",
        "reset": "0x00000000",
        "description": "Shadow User Data Register n"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "GMAC_MAC_CONF",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:25",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TC",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Configuration in RGMII\nWhen set, this bit enables the transmission of duplex mode, link\nspeed, and link up/down information to the PHY in the RGMII\nports. When this bit is reset, no such information is driven to the\nPHY."
          },
          {
            "name": "WD",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "Watchdog Disable\nWhen this bit is set, the GMAC disables the watchdog timer on\nthe receiver, and can receive frames of up to 16,384 bytes.\nWhen this bit is reset, the GMAC allows no more than 2,048 bytes\n(10,240 if JE is set high) of the frame being received and cuts off\nany bytes received after that."
          },
          {
            "name": "JD",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "Jabber Disable\nWhen this bit is set, the GMAC disables the jabber timer on the\ntransmitter, and can transfer frames of up to 16,384 bytes.\nWhen this bit is reset, the GMAC cuts off the transmitter if the\napplication sends out more than 2,048 bytes of data (10,240 if JE\nis set high) during transmission."
          },
          {
            "name": "BE",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "Frame Burst Enable\nWhen this bit is set, the GMAC allows frame bursting during\ntransmission in GMII Half-Duplex mode."
          },
          {
            "name": "RESERVED",
            "bit_range": "20",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "IFG",
            "bit_range": "19:17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Inter-Frame Gap\nThese bits control the minimum IFG between frames during\ntransmission.\n3'b000: 96 bit times\n3'b001: 88 bit times\n3'b010: 80 bit times\n...\n3'b111: 40 bit times"
          },
          {
            "name": "DCRS",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Carrier Sense During Transmission\nWhen set high, this bit makes the MAC transmitter ignore the\n(G)MII CRS signal during frame transmission in Half-Duplex\nmode. This request results in no errors generated due to Loss of\nCarrier or No Carrier during such transmission. When this bit is\nlow, the MAC transmitter generates such errors due to Carrier\nSense and will even abort the transmissions."
          },
          {
            "name": "PS",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "Port Select\nSelects between GMII and MII:\n1'b0: GMII (1000 Mbps)\n1'b1: MII (10/100 Mbps)"
          },
          {
            "name": "FES",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Speed\nIndicates the speed in Fast Ethernet (MII) mode:\n1'b0: 10 Mbps\n1'b1: 100 Mbps"
          },
          {
            "name": "DO",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Receive Own\nWhen this bit is set, the GMAC disables the reception of frames\nwhen the gmii_txen_o is asserted in Half-Duplex mode.\nWhen this bit is reset, the GMAC receives all packets that are\ngiven by the PHY while transmitting."
          },
          {
            "name": "LM",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Loopback Mode\nWhen this bit is set, the GMAC operates in loopback mode at\nGMII/MII. The (G)MII Receive clock input (clk_rx_i) is required\nfor the loopback to work properly, as the Transmit clock is not\nlooped-back internally."
          },
          {
            "name": "DM",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Duplex Mode\nWhen this bit is set, the GMAC operates in a Full-Duplex mode\nwhere it can transmit and receive simultaneously. This bit is RO\nwith default value of 1'b1 in Full-Duplex-only configuration."
          },
          {
            "name": "IPC",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Checksum Offload\nWhen this bit is set, the GMAC calculates the 16-bit one's\ncomplement of the one's complement sum of all received\nEthernet frame payloads. It also checks whether the IPv4 Header\nchecksum (assumed to be bytes 25-26 or 29-30 (VLAN-tagged)\nof the received Ethernet frame) is correct for the received frame\nand gives the status in the receive status word. The GMAC core\nalso appends the 16-bit checksum calculated for the IP header\ndatagram payload (bytes after the IPv4 header) and appends it\nto the Ethernet frame transferred to the application (when Type 2\nCOE is deselected).\nWhen this bit is reset, this function is disabled.\nWhen Type 2 COE is selected, this bit, when set, enables IPv4\nchecksum checking for received frame payloads TCP/UDP/ICMP\nheaders. When this bit is reset, the COE function in the receiver\nis disabled and the corresponding PCE and IP HCE status bits are\nalways cleared."
          },
          {
            "name": "DR",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Retry\nWhen this bit is set, the GMAC will attempt only 1 transmission.\nWhen a collision occurs on the GMII/MII, the GMAC will ignore\nthe current frame transmission and report a Frame Abort with\nexcessive collision error in the transmit frame status.\nWhen this bit is reset, the GMAC will attempt retries based on the\nsettings of BL."
          },
          {
            "name": "LUD",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Link Up/Down\nIndicates whether the link is up or down during the transmission\nof configuration in RGMII interface:\n1'b0: Link Down\n1'b1: Link Up"
          },
          {
            "name": "ACS",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Automatic Pad/CRC Stripping\nWhen this bit is set, the GMAC strips the Pad/FCS field on\nincoming frames only if the length's field value is less than or\nequal to 1,500 bytes. All received frames with length field greater\nthan or equal to 1,501 bytes are passed to the application\nwithout stripping the Pad/FCS field.\nWhen this bit is reset, the GMAC will pass all incoming frames to\nthe Host unmodified."
          },
          {
            "name": "BL",
            "bit_range": "6:5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Back-Off Limit\nThe Back-Off limit determines the random integer number (r) of\nslot time delays (4,096 bit times for 1000 Mbps and 512 bit times\nfor 10/100 Mbps) the GMAC waits before rescheduling a\ntransmission attempt during retries after a collision. This bit is\napplicable only to Half-Duplex mode and is reserved (RO) in Full-\nDuplex-only configuration.\n2'b00: k = min (n, 10)\n2'b01: k = min (n, 8)\n2'b10: k = min (n, 4)\n2'b11: k = min (n, 1),\nWhere n = retransmission attempt. The random integer r takes\nthe value in the range 0 =  r < 2^k"
          },
          {
            "name": "DC",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Deferral Check\nWhen this bit is set, the deferral check function is enabled in the\nGMAC. The GMAC will issue a Frame Abort status, along with the\nexcessive deferral error bit set in the transmit frame status when\nthe transmission state machine is deferred for more than 24,288\nbit times in 10/100-Mbps mode. If the Core is configured for\n1000 Mbps operation, the threshold for deferral is 155,680 bits\ntimes. Deferral begins when the transmitter is ready to transmit,\nbut is prevented because of an active CRS (carrier sense) signal\non the GMII/MII. Defer time is not cumulative. If the transmitter\ndefers for 10,000 bit times, then transmits, collides, backs off,\nand then has to defer again after completion of back-off, the\ndeferral timer resets to 0 and restarts.\nWhen this bit is reset, the deferral check function is disabled and\nthe GMAC defers until the CRS signal goes inactive."
          },
          {
            "name": "TE",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmitter Enable\nWhen this bit is set, the transmission state machine of the GMAC\nis enabled for transmission on the GMII/MII. When this bit is\nreset, the GMAC transmit state machine is disabled after the\ncompletion of the transmission of the current frame, and will not\ntransmit any further frames."
          },
          {
            "name": "RE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receiver Enable\nWhen this bit is set, the receiver state machine of the GMAC is\nenabled for receiving frames from the GMII/MII. When this bit is\nreset, the GMAC receive state machine is disabled after the\ncompletion of the reception of the current frame, and will not\nreceive any further frames from the GMII/MII."
          },
          {
            "name": "RESERVED",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "MAC Configuration Register"
      },
      {
        "type": "register",
        "name": "GMAC_MAC_FRM_FILT",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RA",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive All\nWhen this bit is set, the GMAC Receiver module passes to the\nApplication all frames received irrespective of whether they pass\nthe address filter. The result of the SA/DA filtering is updated\n(pass or fail) in the corresponding bits in the Receive Status\nWord. When this bit is reset, the Receiver module passes to the\nApplication only those frames that pass the SA/DA address filter."
          },
          {
            "name": "RESERVED",
            "bit_range": "30:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HPF",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hash or Perfect Filter\nWhen set, this bit configures the address filter to pass a frame if\nit matches either the perfect filtering or the hash filtering as set\nby HMC or HUC bits. When low and if the HUC/HMC bit is set, the\nframe is passed only if it matches the Hash filter."
          },
          {
            "name": "SAF",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Source Address Filter Enable\nThe GMAC core compares the SA field of the received frames with\nthe values programmed in the enabled SA registers. If the\ncomparison matches, then the SAMatch bit of RxStatus Word is\nset high. When this bit is set high and the SA filter fails, the\nGMAC drops the frame.\nWhen this bit is reset, then the GMAC Core forwards the received\nframe to the application and with the updated SA Match bit of the\nRxStatus depending on the SA address comparison."
          },
          {
            "name": "SAIF",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "SA Inverse Filtering\nWhen this bit is set, the Address Check block operates in inverse\nfiltering mode for the SA address comparison. The frames whose\nSA matches the SA registers will be marked as failing the SA\nAddress filter.\nWhen this bit is reset, frames whose SA does not match the SA\nregisters will be marked as failing the SA Address filter."
          },
          {
            "name": "PCF",
            "bit_range": "7:6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Pass Control Frames\nThese bits control the forwarding of all control frames (including\nunicast and multicast PAUSE frames). Note that the processing of\nPAUSE control frames depends only on RFE of Register\nGMAC_FLOW_CTRL[2].\n2'b00: GMAC filters all control frames from reaching the\napplication.\n2'b01: GMAC forwards all control frames except PAUSE control\nframes to application even if they fail the Address filter.\n2'b10: GMAC forwards all control frames to application even if\nthey fail the Address Filter.\n2'b11: GMAC forwards control frames that pass the Address\nFilter."
          },
          {
            "name": "DBF",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Broadcast Frames\nWhen this bit is set, the AFM module filters all incoming\nbroadcast frames.\nWhen this bit is reset, the AFM module passes all received\nbroadcast frames."
          },
          {
            "name": "PM",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Pass All Multicast\nWhen set, this bit indicates that all received frames with a\nmulticast destination address (first bit in the destination address\nfield is '1') are passed.\nWhen reset, filtering of multicast frame depends on HMC bit."
          },
          {
            "name": "DAIF",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "DA Inverse Filtering\nWhen this bit is set, the Address Check block operates in inverse\nfiltering mode for the DA address comparison for both unicast\nand multicast frames.\nWhen reset, normal filtering of frames is performed."
          },
          {
            "name": "HMC",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hash Multicast\nWhen set, MAC performs destination address filtering of received\nmulticast frames according to the hash table.\nWhen reset, the MAC performs a perfect destination address\nfiltering for multicast frames, that is, it compares the DA field\nwith the values programmed in DA registers."
          },
          {
            "name": "HUC",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hash Unicast\nWhen set, MAC performs destination address filtering of unicast\nframes according to the hash table.\nWhen reset, the MAC performs a perfect destination address\nfiltering for unicast frames, that is, it compares the DA field with\nthe values programmed in DA registers."
          },
          {
            "name": "PR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Promiscuous Mode\nWhen this bit is set, the Address Filter module passes all\nincoming frames regardless of its destination or source address.\nThe SA/DA Filter Fails status bits of the Receive Status Word will\nalways be cleared when PR is set."
          }
        ],
        "description": "MAC Frame Filter"
      },
      {
        "type": "register",
        "name": "GMAC_HASH_TAB_HI",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HTH",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Hash Table High\nThis field contains the upper 32 bits of Hash table"
          }
        ],
        "description": "Hash Table High Register"
      },
      {
        "type": "register",
        "name": "GMAC_HASH_TAB_LO",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HTL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Hash Table Low\nThis field contains the lower 32 bits of Hash table"
          }
        ],
        "description": "Hash Table Low Register"
      },
      {
        "type": "register",
        "name": "GMAC_GMII_ADDR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PA",
            "bit_range": "15:11",
            "attr": "RW",
            "reset": "0x00",
            "description": "Physical Layer Address\nThis field tells which of the 32 possible PHY devices are being\naccessed"
          },
          {
            "name": "GR",
            "bit_range": "10:6",
            "attr": "RW",
            "reset": "0x00",
            "description": "GMII Register\nThese bits select the desired GMII register in the selected PHY\ndevice"
          },
          {
            "name": "CR",
            "bit_range": "5:2",
            "attr": "RW",
            "reset": "0x0",
            "description": "APB Clock Range\nThe APB Clock Range selection determines the frequency of the\nMDC clock as per the pclk_gmac frequency used in your design.\nThe suggested range of pclk_gmac frequency applicable for each\nvalue below (when Bit[5] = 0) ensures that the MDC clock is\napproximately between the frequency range 1.0 MHz - 2.5 MHz.\nSelection    pclk_gmacMDC Clock\n0000       60-100 MHz      pclk_gmac/42\n0001       100-150 MHz     pclk_gmac/62\n0010       20-35 MHz       pclk_gmac/16\n0011       35-60 MHz       pclk_gmac/26\n0100       150-250 MHz    pclk_gmac/102\n0101       250-300 MHz    pclk_gmac/124\n0110, 0111   Reserved\nWhen bit 5 is set, you can achieve MDC clock of frequency higher\nthan the IEEE802.3 specified frequency limit of 2.5 MHz and\nprogram a clock divider of lower value. For example, when\npclk_gmac is of frequency 100 MHz and you program these bits\nas \"1010\", then the resultant MDC clock will be of 12.5 MHz\nwhich is outside the limit of IEEE 802.3 specified range. Please\nprogram the values given below only if the interfacing chips\nsupports faster MDC clocks.\nSelection        MDC Clock\n1000          pclk_gmac/4\n1001          pclk_gmac/6\n1010          pclk_gmac/8\n1011          pclk_gmac/10\n1100          pclk_gmac/12\n1101          pclk_gmac/14\n1110          pclk_gmac/16\n1111          pclk_gmac/18"
          },
          {
            "name": "GW",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "GMII Write\nWhen set, this bit tells the PHY that this will be a Write operation\nusing register GMAC_GMII_DATA. If this bit is not set, this will be\na Read operation, placing the data in register GMAC_GMII_DATA."
          },
          {
            "name": "GB",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "GMII Busy\nThis bit should read a logic 0 before writing to Register\nGMII_ADDR and Register GMII_DATA. This bit must also be set to\n0 during a Write to Register GMII_ADDR. During a PHY register\naccess, this bit will be set to 1'b1 by the Application to indicate\nthat a Read or Write access is in progress. Register GMII_DATA\n(GMII Data) should be kept valid until this bit is cleared by the\nGMAC during a PHY Write operation. The Register GMII_DATA is\ninvalid until this bit is cleared by the GMAC during a PHY Read\noperation. The Register GMII_ADDR (GMII Address) should not\nbe written to until this bit is cleared."
          }
        ],
        "description": "GMII Address Register"
      },
      {
        "type": "register",
        "name": "GMAC_GMII_DATA",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GD",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "GMII Data\nThis contains the 16-bit data value read from the PHY after a\nManagement Read operation or the 16-bit data value to be\nwritten to the PHY before a Management Write operation."
          }
        ],
        "description": "GMII Data Register"
      },
      {
        "type": "register",
        "name": "GMAC_FLOW_CTRL",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "PT",
            "bit_range": "31:16",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Pause Time\nThis field holds the value to be used in the Pause Time field in the\ntransmit control frame. If the Pause Time bits is configured to be\ndouble-synchronized to the (G)MII clock domain, then\nconsecutive writes to this register should be performed only after\nat least 4 clock cycles in the destination clock domain."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DZPQ",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Zero-Quanta Pause\nWhen set, this bit disables the automatic generation of Zero-\nQuanta Pause Control frames on the de-assertion of the flow-\ncontrol signal from the FIFO layer (MTL or external sideband flow\ncontrol signal sbd_flowctrl_i/mti_flowctrl_i).\nWhen this bit is reset, normal operation with automatic Zero-\nQuanta Pause Control frame generation is enabled."
          },
          {
            "name": "RESERVED",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PLT",
            "bit_range": "5:4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Pause Low Threshold\nThis field configures the threshold of the PAUSE timer at which\nthe input flow control signal mti_flowctrl_i (or sbd_flowctrl_i) is\nchecked for automatic retransmission of PAUSE Frame. The\nthreshold values should be always less than the Pause Time\nconfigured in Bits[31:16]. For example, if PT = 100H (256 slot-\ntimes), and PLT = 01, then a second PAUSE frame is\nautomatically transmitted if the mti_flowctrl_i signal is asserted\nat 228 (256-28) slot-times after the first PAUSE frame is\ntransmitted.\nSelection          Threshold\n00      Pause time minus 4 slot times\n01      Pause time minus 28 slot times\n10      Pause time minus 144 slot times\n11      Pause time minus 256 slot times\nSlot time is defined as time taken to transmit 512 bits (64 bytes)\non the GMII/MII interface."
          },
          {
            "name": "UP",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Unicast Pause Frame Detect\nWhen this bit is set, the GMAC will detect the Pause frames with\nthe station's unicast address specified in MAC Address0 High\nRegister and MAC Address0 Low Register, in addition to the\ndetecting Pause frames with the unique multicast address. When\nthis bit is reset, the GMAC will detect only a Pause frame with the\nunique multicast address specified in the 802.3x standard."
          },
          {
            "name": "RFE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Flow Control Enable\nWhen this bit is set, the GMAC will decode the received Pause\nframe and disable its transmitter for a specified (Pause Time)\ntime. When this bit is reset, the decode function of the Pause\nframe is disabled."
          },
          {
            "name": "TFE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Flow Control Enable\nIn Full-Duplex mode, when this bit is set, the GMAC enables the\nflow control operation to transmit Pause frames. When this bit is\nreset, the flow control operation in the GMAC is disabled, and the\nGMAC will not transmit any Pause frames.\nIn Half-Duplex mode, when this bit is set, the GMAC enables the\nback-pressure operation. When this bit is reset, the backpressure\nfeature is disabled."
          },
          {
            "name": "FCB_BPA",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Flow Control Busy/Backpressure Activate\nThis bit initiates a Pause Control frame in Full-Duplex mode and\nactivates the backpressure function in Half-Duplex mode if TFE\nbit is set.\nIn Full-Duplex mode, this bit should be read as 1'b0 before\nwriting to the register GMAC_FLOW_CTRL. To initiate a pause\ncontrol frame, the application must set this bit to 1'b1. During a\ntransfer of the control frame, this bit will continue to be set to\nsignify that a frame transmission is in progress. After the\ncompletion of Pause control frame transmission, the GMAC will\nreset this bit to 1'b0. The register GMAC_FLOW_CTRL should not\nbe written to until this bit is cleared.\nIn Half-Duplex mode, when this bit is set (and TFE is set), then\nbackpressure is asserted by the GMAC Core. During\nbackpressure, when the GMAC receives a new frame, the\ntransmitter starts sending a JAM pattern resulting in a collision.\nThis control register bit is logically OR'ed with the mti_flowctrl_i\ninput signal for the backpressure function."
          }
        ],
        "description": "Flow Control Register"
      },
      {
        "type": "register",
        "name": "GMAC_VLAN_TAG",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ETV",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable 12-Bit VLAN Tag Comparison\nWhen this bit is set, a 12-bit VLAN identifier, rather than the\ncomplete 16-bit VLAN tag, is used for comparison and filtering.\nBits[11:0] of the VLAN tag are compared with the corresponding\nfield in the received VLAN-tagged frame.\nWhen this bit is reset, all 16 bits of the received VLAN frame's\nfifteenth and sixteenth bytes are used for comparison."
          },
          {
            "name": "VL",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "VLAN Tag Identifier for Receive Frames\nThis contains the 802.1Q VLAN tag to identify VLAN frames, and\nis compared to the fifteenth and sixteenth bytes of the frames\nbeing received for VLAN frames. Bits[15:13] are the User Priority,\nBit[12] is the Canonical Format Indicator (CFI) and bits[11:0] are\nthe VLAN tag's VLAN Identifier (VID) field. When the ETV bit is\nset, only the VID (Bits[11:0]) is used for comparison.\nIf VL (VL[11:0] if ETV is set) is all zeros, the GMAC does not\ncheck the fifteenth and sixteenth bytes for VLAN tag comparison,\nand declares all frames with a Type field value of 0x8100 to be\nVLAN frames."
          }
        ],
        "description": "VLAN Tag Register"
      },
      {
        "type": "register",
        "name": "GMAC_DEBUG",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFIFO3",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MTL TxStatus FIFO is full and\nhence the MTL will not be accepting any more frames for\ntransmission."
          },
          {
            "name": "TFIFO2",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MTL TxFIFO is not empty and has\nsome data left for transmission."
          },
          {
            "name": "RESERVED",
            "bit_range": "23",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TFIFO1",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MTL TxFIFO Write Controller is\nactive and transferring data to the TxFIFO."
          },
          {
            "name": "TFIFOSTA",
            "bit_range": "21:20",
            "attr": "RW",
            "reset": "0x0",
            "description": "This indicates the state of the TxFIFO read Controller:\n2'b00: IDLE state\n2'b01: READ state (transferring data to MAC transmitter)\n2'b10: Waiting for TxStatus from MAC transmitter\n2'b11: Writing the received TxStatus or flushing the TxFIFO"
          },
          {
            "name": "PAUSE",
            "bit_range": "19",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MAC transmitter is in PAUSE\ncondition (in full-duplex only) and hence will not schedule any\nframe for transmission"
          },
          {
            "name": "TSAT",
            "bit_range": "18:17",
            "attr": "RW",
            "reset": "0x0",
            "description": "This indicates the state of the MAC Transmit Frame Controller\nmodule:\n2'b00: IDLE\n2'b01: Waiting for Status of previous frame or IFG/backoff period\nto be over\n2'b10: Generating and transmitting a PAUSE control frame (in full\nduplex mode)\n2'b11: Transferring input frame for transmission"
          },
          {
            "name": "TACT",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MAC GMII/MII transmit protocol\nengine is actively transmitting data and not in IDLE state."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFIFO",
            "bit_range": "9:8",
            "attr": "RW",
            "reset": "0x0",
            "description": "This gives the status of the RxFIFO Fill-level:\n2'b00: RxFIFO Empty\n2'b01: RxFIFO fill-level below flow-control de-activate threshold\n2'b10: RxFIFO fill-level above flow-control activate threshold\n2'b11: RxFIFO Full"
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFIFORD",
            "bit_range": "6:5",
            "attr": "RW",
            "reset": "0x0",
            "description": "It gives the state of the RxFIFO read Controller:\n2'b00: IDLE state\n2'b01: Reading frame data\n2'b10: Reading frame status (or time-stamp)\n2'b11: Flushing the frame data and Status"
          },
          {
            "name": "RFIFOWR",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MTL RxFIFO Write Controller is\nactive and transferring a received frame to the FIFO."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ACT",
            "bit_range": "2:1",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates the active state of the small FIFO Read\nand Write controllers respectively of the MAC receive Frame\nController module"
          },
          {
            "name": "RDB",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "When high, it indicates that the MAC GMII/MII receive protocol\nengine is actively receiving data and not in IDLE state."
          }
        ],
        "description": "Debug register"
      },
      {
        "type": "register",
        "name": "GMAC_PMT_CTRL_STA",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "WFFRPR",
            "bit_range": "31",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Wake-Up Frame Filter Register Pointer Reset\nWhen set, resets the Remote Wake-up Frame Filter register\npointer to 3'b000. It is automatically cleared after 1 clock cycle."
          },
          {
            "name": "RESERVED",
            "bit_range": "30:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GU",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Global Unicast\nWhen set, enables any unicast packet filtered by the GMAC (DAF)\naddress recognition to be a wake-up frame."
          },
          {
            "name": "RESERVED",
            "bit_range": "8:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WFR",
            "bit_range": "6",
            "attr": "RC",
            "reset": "0x0",
            "description": "Wake-Up Frame Received\nWhen set, this bit indicates the power management event was\ngenerated due to reception of a wake-up frame. This bit is\ncleared by a read into this register."
          },
          {
            "name": "MPR",
            "bit_range": "5",
            "attr": "RC",
            "reset": "0x0",
            "description": "Magic Packet Received\nWhen set, this bit indicates the power management event was\ngenerated by the reception of a Magic Packet. This bit is cleared\nby a read into this register."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WFE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Wake-Up Frame Enable\nWhen set, enables generation of a power management event due\nto wake-up frame reception."
          },
          {
            "name": "MPE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Magic Packet Enable\nWhen set, enables generation of a power management event due\nto Magic Packet reception."
          },
          {
            "name": "PD",
            "bit_range": "0",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Power Down\nWhen set, all received frames will be dropped. This bit is cleared\nautomatically when a magic packet or Wake-Up frame is\nreceived, and Power-Down mode is disabled. Frames received\nafter this bit is cleared are forwarded to the application. This bit\nmust only be set when either the Magic Packet Enable or Wake-\nUp Frame Enable bit is set high."
          }
        ],
        "description": "PMT Control and Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_INT_STATUS",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MRCOIS",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "MMC Receive Checksum Offload Interrupt Status\nThis bit is set high whenever an interrupt is generated in the MMC\nReceive Checksum Offload Interrupt Register. This bit is cleared\nwhen all the bits in this interrupt register are cleared."
          },
          {
            "name": "MTIS",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "MMC Transmit Interrupt Status\nThis bit is set high whenever an interrupt is generated in the MMC\nTransmit Interrupt Register. This bit is cleared when all the bits in\nthis interrupt register are cleared. This bit is only valid when the\noptional MMC module is selected during configuration."
          },
          {
            "name": "MRIS",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "MMC Receive Interrupt Status\nThis bit is set high whenever an interrupt is generated in the MMC\nReceive Interrupt Register. This bit is cleared when all the bits in\nthis interrupt register are cleared. This bit is only valid when the\noptional MMC module is selected during configuration."
          },
          {
            "name": "MIS",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "MMC Interrupt Status\nThis bit is set high whenever any of bits 7:5 is set high and\ncleared only when all of these bits are low. This bit is valid only\nwhen the optional MMC module is selected during configuration."
          },
          {
            "name": "PIS",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "PMT Interrupt Status\nThis bit is set whenever a Magic packet or Wake-on-LAN frame is\nreceived in Power-Down mode). This bit is cleared when both\nbits[6:5] are cleared due to a read operation to the register\nGMAC_PMT_CTRL_STA."
          },
          {
            "name": "RESERVED",
            "bit_range": "2:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RIS",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "RGMII Interrupt Status\nThis bit is set due to any change in value of the Link Status of\nRGMII interface. This bit is cleared when the user makes a read\noperation the RGMII Status register."
          }
        ],
        "description": "Interrupt Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_INT_MASK",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PIM",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "PMT Interrupt Mask\nThis bit when set, will disable the assertion of the interrupt signal\ndue to the setting of PMT Interrupt Status bit in Register\nGMAC_INT_STATUS."
          },
          {
            "name": "RESERVED",
            "bit_range": "2:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RIM",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "RGMII Interrupt Mask\nThis bit when set, will disable the assertion of the interrupt signal\ndue to the setting of RGMII Interrupt Status bit in Register\nGMAC_INT_STATUS."
          }
        ],
        "description": "Interrupt Mask Register"
      },
      {
        "type": "register",
        "name": "GMAC_MAC_ADDR0_HI",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x0000ffff",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "A47_A32",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0xffff",
            "description": "MAC Address0 [47:32]\nThis field contains the upper 16 bits (47:32) of the 6-byte first\nMAC address. This is used by the MAC for filtering for received\nframes and for inserting the MAC address in the Transmit Flow\nControl (PAUSE) Frames."
          }
        ],
        "description": "MAC Address0 High Register"
      },
      {
        "type": "register",
        "name": "GMAC_MAC_ADDR0_LO",
        "offset": "0x0044",
        "size": "W",
        "reset": "0xffffffff",
        "bit_ranges": [
          {
            "name": "A31_A0",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0xffffffff",
            "description": "MAC Address0 [31:0]\nThis field contains the lower 32 bits of the 6-byte first MAC\naddress. This is used by the MAC for filtering for received frames\nand for inserting the MAC address in the Transmit Flow Control\n(PAUSE) Frames."
          }
        ],
        "description": "MAC Address0 Low Register"
      },
      {
        "type": "register",
        "name": "GMAC_AN_CTRL",
        "offset": "0x00c0",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ANE",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Auto-Negotiation Enable\nWhen set, will enable the GMAC to perform auto-negotiation with\nthe link partner.\nClearing this bit will disable auto-negotiation."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RAN",
            "bit_range": "9",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Restart Auto-Negotiation\nWhen set, will cause auto-negotiation to restart if the ANE is set.\nThis bit is self-clearing after auto-negotiation starts. This bit\nshould be cleared for normal operation."
          },
          {
            "name": "RESERVED",
            "bit_range": "8:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "AN Control Register"
      },
      {
        "type": "register",
        "name": "GMAC_AN_STATUS",
        "offset": "0x00c4",
        "size": "W",
        "reset": "0x00000008",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ANC",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto-Negotiation Complete\nWhen set, this bit indicates that the auto-negotiation process is\ncompleted.\nThis bit is cleared when auto-negotiation is reinitiated."
          },
          {
            "name": "RESERVED",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ANA",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x1",
            "description": "Auto-Negotiation Ability\nThis bit is always high, because the GMAC supports auto-\nnegotiation."
          },
          {
            "name": "LS",
            "bit_range": "2",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Link Status\nWhen set, this bit indicates that the link is up. When cleared, this\nbit indicates that the link is down."
          },
          {
            "name": "RESERVED",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "AN Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_AN_ADV",
        "offset": "0x00c8",
        "size": "W",
        "reset": "0x000001e0",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "NP",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "Next Page Support\nThis bit is tied to low, because the GMAC does not support the\nnext page."
          },
          {
            "name": "RESERVED",
            "bit_range": "14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RFE",
            "bit_range": "13:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Remote Fault Encoding\nThese 2 bits provide a remote fault encoding, indicating to a link\npartner that a fault or error condition has occurred."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PSE",
            "bit_range": "8:7",
            "attr": "RW",
            "reset": "0x3",
            "description": "Pause Encoding\nThese 2 bits provide an encoding for the PAUSE bits, indicating\nthat the GMAC is capable of configuring the PAUSE function as\ndefined in IEEE 802.3x."
          },
          {
            "name": "HD",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x1",
            "description": "Half-Duplex\nThis bit, when set high, indicates that the GMAC supports Half-\nDuplex. This bit is tied to low (and RO) when the GMAC is\nconfigured for Full-Duplex-only operation."
          },
          {
            "name": "FD",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x1",
            "description": "Full-Duplex\nThis bit, when set high, indicates that the GMAC supports Full-\nDuplex."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Auto Negotiation Advertisement Register"
      },
      {
        "type": "register",
        "name": "GMAC_AN_LINK_PART_AB",
        "offset": "0 x00cc",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "NP",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "Next Page Support\nWhen set, this bit indicates that more next page information is\navailable.\nWhen cleared, this bit indicates that next page exchange is not\ndesired."
          },
          {
            "name": "ACK",
            "bit_range": "14",
            "attr": "RO",
            "reset": "0x0",
            "description": "Acknowledge\nWhen set, this bit is used by the auto-negotiation function to\nindicate that the link partner has successfully received the\nGMAC's base page. When cleared, it indicates that a successful\nreceipt of the base page has not been achieved."
          },
          {
            "name": "RFE",
            "bit_range": "13:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "Remote Fault Encoding\nThese 2 bits provide a remote fault encoding, indicating a fault or\nerror condition of the link partner."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PSE",
            "bit_range": "8:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Pause Encoding\nThese 2 bits provide an encoding for the PAUSE bits, indicating\nthat the link partner's capability of configuring the PAUSE\nfunction as defined in IEEE 802.3x."
          },
          {
            "name": "HD",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "Half-Duplex\nWhen set, this bit indicates that the link partner has the ability to\noperate in Half-Duplex mode. When cleared, the link partner does\nnot have the ability to operate in Half-Duplex mode."
          },
          {
            "name": "FD",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "Full-Duplex\nWhen set, this bit indicates that the link partner has the ability to\noperate in Full-Duplex mode. When cleared, the link partner does\nnot have the ability to operate in Full-Duplex mode."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Auto Negotiation Link Partner Ability Register"
      },
      {
        "type": "register",
        "name": "GMAC_AN_EXP",
        "offset": "0x00d0",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "NPA",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Next Page Ability\nThis bit is tied to low, because the GMAC does not support next\npage function."
          },
          {
            "name": "NPR",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "New Page Received\nWhen set, this bit indicates that a new page has been received by\nthe GMAC. This bit will be cleared when read."
          },
          {
            "name": "RESERVED",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Auto Negotiation Expansion Register"
      },
      {
        "type": "register",
        "name": "GMAC_INTF_MODE_STA",
        "offset": "0x00d8",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LST",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Link Status\nIndicates whether the link is up (1'b1) or down (1'b0)"
          },
          {
            "name": "LSD",
            "bit_range": "2:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Link Speed\nIndicates the current speed of the link:\n2'b00: 2.5 MHz\n2'b01: 25 MHz\n2'b10: 125 MHz"
          },
          {
            "name": "LM",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Link Mode\nIndicates the current mode of operation of the link:\n1'b0: Half-Duplex mode\n1'b1: Full-Duplex mode"
          }
        ],
        "description": "RGMII Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_CTRL",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FHP",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Full-Half preset\nWhen low and bit4 is set, all MMC counters get preset to almost-\nhalf value. All octet counters get preset to 0x7FFF_F800 (half -\n2K Bytes) and all frame-counters gets preset to 0x7FFF_FFF0\n(half - 16)\nWhen high and bit4 is set, all MMC counters get preset to almost-\nfull value. All octet counters get preset to 0xFFFF_F800 (full - 2K\nBytes) and all frame-counters gets preset to 0xFFFF_FFF0 (full -\n16)"
          },
          {
            "name": "CP",
            "bit_range": "4",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Counters Preset\nWhen set, all counters will be initialized or preset to almost full or\nalmost half as per Bit5 above. This bit will be cleared\nautomatically after 1 clock cycle. This bit along with bit5 is useful\nfor debugging and testing the assertion of interrupts due to MMC\ncounter becoming half-full or full."
          },
          {
            "name": "MCF",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "MMC Counter Freeze\nWhen set, this bit freezes all the MMC counters to their current\nvalue. (None of the MMC counters are updated due to any\ntransmitted or received frame until this bit is reset to 0. If any\nMMC counter is read with the Reset on Read bit set, then that\ncounter is also cleared in this mode.)"
          },
          {
            "name": "ROR",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Reset on Read\nWhen set, the MMC counters will be reset to zero after Read (self-\nclearing after reset). The counters are cleared when the least\nsignificant byte lane (bits[7:0]) is read."
          },
          {
            "name": "CSR",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Counter Stop Rollover\nWhen set, counter after reaching maximum value will not roll\nover to zero"
          },
          {
            "name": "CR",
            "bit_range": "0",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Counters Reset\nWhen set, all counters will be reset. This bit will be cleared\nautomatically after 1 clock cycle"
          }
        ],
        "description": "MMC Control Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RX_INTR",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT21",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "The bit is set when the rxfifooverflow counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "20:19",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT18",
            "bit_range": "18",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxlengtherror counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "17:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT5",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "The bit is set when the rxcrcerror counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT4",
            "bit_range": "4",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxmulticastframes_g counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT2",
            "bit_range": "2",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxoctetcount_g counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxoctetcount_gb counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxframecount_gb counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          }
        ],
        "description": "MMC Receive Interrupt Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TX_INTR",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT21",
            "bit_range": "21",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txframecount_g counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT20",
            "bit_range": "20",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txoctetcount_g counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT19",
            "bit_range": "19",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txcarriererror counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "18:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT13",
            "bit_range": "13",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txunderflowerror counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "12:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txframecount_gb counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the txoctetcount_gb counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          }
        ],
        "description": "MMC Transmit Interrupt Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RX_INT_MSK",
        "offset": "0 x010c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT21",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxfifooverflow\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "20:19",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT18",
            "bit_range": "18",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxlengtherror\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "17:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT5",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxcrcerror counter\nreaches half the maximum value, and also when it reaches the\nmaximum value."
          },
          {
            "name": "INT4",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the\nrxmulticastframes_g counter reaches half the maximum value,\nand also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT2",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxoctetcount_g\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxoctetcount_gb\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxframecount_gb\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          }
        ],
        "description": "MMC Receive Interrupt Mask Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TX_INT_MSK",
        "offset": "0x0110",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT21",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txframecount_g\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT20",
            "bit_range": "20",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txoctetcount_g\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT19",
            "bit_range": "19",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txcarriererror\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "18:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT13",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txunderflowerror\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "12:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txframecount_gb\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the txoctetcount_gb\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          }
        ],
        "description": "MMC Transmit Interrupt Mask Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXOCTETCNT_GB",
        "offset": "0x0114",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXOCTETCOUNT_GB",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes transmitted, exclusive of preamble and retried\nbytes, in good and bad frames."
          }
        ],
        "description": "MMC TX OCTET Good and Bad Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXFRMCNT_GB",
        "offset": "0x0118",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXFRAMECOUNT_GB",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good and bad frames transmitted, exclusive of retried\nframes."
          }
        ],
        "description": "MMC TX Frame Good and Bad Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXUNDFLWERR",
        "offset": "0x0148",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXUNDERFLOWERROR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of frames aborted due to frame underflow error."
          }
        ],
        "description": "MMC TX Underflow Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXCARERR",
        "offset": "0x0160",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXCARRIERERROR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of frames aborted due to carrier sense error (no carrier\nor loss of carrier)."
          }
        ],
        "description": "MMC TX Carrier Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXOCTETCNT_G",
        "offset": "0x0164",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXOCTETCOUNT_G",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes transmitted, exclusive of preamble, in good\nframes only."
          }
        ],
        "description": "MMC TX OCTET Good Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_TXFRMCNT_G",
        "offset": "0x0168",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TXFRAMECOUNT_G",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good frames transmitted."
          }
        ],
        "description": "MMC TX Frame Good Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXFRMCNT_GB",
        "offset": "0x0180",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXFRAMECOUNT_GB",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good and bad frames received."
          }
        ],
        "description": "MMC RX Frame Good and Bad Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXOCTETCNT_GB",
        "offset": "0x0184",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXOCTETCOUNT_GB",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received, exclusive of preamble, in good and\nbad frames."
          }
        ],
        "description": "MMC RX OCTET Good and Bad Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXOCTETCNT_G",
        "offset": "0x0188",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXOCTETCOUNT_G",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received, exclusive of preamble, only in good\nframes."
          }
        ],
        "description": "MMC RX OCTET Good Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXMCFRMCNT_G",
        "offset": "0x0190",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXMULTICASTFRAMES_G",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good multicast frames received."
          }
        ],
        "description": "MMC RX Multicast Frame Good Counter"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXCRCERR",
        "offset": "0x0194",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXCRCERROR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of frames received with CRC error."
          }
        ],
        "description": "MMC RX Carrier"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXLENERR",
        "offset": "0x01c8",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXLENGTHERROR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of frames received with length error (Length type field\n\u2260frame size), for all frames with valid length field."
          }
        ],
        "description": "MMC RX Length Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXFIFOOVRFLW",
        "offset": "0x01d4",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXFIFOOVERFLOW",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of missed received frames due to FIFO overflow."
          }
        ],
        "description": "MMC RX FIFO Overflow"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_IPC_INT_MSK",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT29",
            "bit_range": "29",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxicmp_err_octets\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT27",
            "bit_range": "27",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxtcp_err_octets\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT25",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxudp_err_octets\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "24:23",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT22",
            "bit_range": "22",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the\nrxipv6_hdrerr_octets counter reaches half the maximum value,\nand also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "21:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT17",
            "bit_range": "17",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the\nrxipv4_hdrerr_octets counter reaches half the maximum value,\nand also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "16:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT13",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxicmp_err_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT11",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxtcp_err_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT9",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxudp_err_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "8:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT6",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxipv6_hdrerr_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT5",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxipv6_gd_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxipv4_hdrerr_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Setting this bit masks the interrupt when the rxipv4_gd_frms\ncounter reaches half the maximum value, and also when it\nreaches the maximum value."
          }
        ],
        "description": "MMC Receive Checksum Offload Interrupt Mask Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_IPC_INTR",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT29",
            "bit_range": "29",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxicmp_err_octets counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "RESERVED",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT27",
            "bit_range": "27",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxtcp_err_octets counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT25",
            "bit_range": "25",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxudp_err_octets counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "24:23",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT22",
            "bit_range": "22",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv6_hdrerr_octets counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "RESERVED",
            "bit_range": "21:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT17",
            "bit_range": "17",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv4_hdrerr_octets counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "RESERVED",
            "bit_range": "16:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT13",
            "bit_range": "13",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxicmp_err_frms counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT11",
            "bit_range": "11",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxtcp_err_frms counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT9",
            "bit_range": "9",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxudp_err_frms counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "8:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT6",
            "bit_range": "6",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv6_hdrerr_frms counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "INT5",
            "bit_range": "5",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv6_gd_frms counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT1",
            "bit_range": "1",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv4_hdrerr_frms counter reaches half\nthe maximum value, and also when it reaches the maximum\nvalue."
          },
          {
            "name": "INT0",
            "bit_range": "0",
            "attr": "RC",
            "reset": "0x0",
            "description": "The bit is set when the rxipv4_gd_frms counter reaches half the\nmaximum value, and also when it reaches the maximum value."
          }
        ],
        "description": "MMC Receive Checksum Offload Interrupt Register"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV4GFRM",
        "offset": "0 x0210",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV4_GD_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good IPv4 datagrams received with the TCP, UDP, or\nICMP payload"
          }
        ],
        "description": "MMC RX IPV4 Good Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV4HDERRFRM",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV4_HDRERR_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of IPv4 datagrams received with header (checksum,\nlength, or version mismatch) errors"
          }
        ],
        "description": "MMC RX IPV4 Head Error Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV6GFRM",
        "offset": "0 x0224",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV6_GD_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good IPv6 datagrams received with TCP, UDP, or ICMP\npayloads."
          }
        ],
        "description": "MMC RX IPV6 Good Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV6HDERRFRM",
        "offset": "0x0228",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV6_HDRERR_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of IPv6 datagrams received with header errors (length or\nversion mismatch)."
          }
        ],
        "description": "MMC RX IPV6 Head Error Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXUDPERRFRM",
        "offset": "0x0234",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXUDP_ERR_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good IP datagrams whose UDP payload has a\nchecksum error."
          }
        ],
        "description": "MMC RX UDP Error Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXTCPERRFRM",
        "offset": "0x023c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXTCP_ERR_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good IP datagrams whose TCP payload has a\nchecksum error."
          }
        ],
        "description": "MMC RX TCP Error Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXICMPERRFRM",
        "offset": "0x0244",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXICMP_ERR_FRMS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of good IP datagrams whose ICMP payload has a\nchecksum error."
          }
        ],
        "description": "MMC RX ICMP Error Frame"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV4HDERROCT",
        "offset": "0x0254",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV4_HDRERR_OCTETS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received in IPv4 datagrams with header errors\n(checksum, length, version mismatch). The value in the Length\nfield of IPv4 header is used to update this counter."
          }
        ],
        "description": "MMC RX OCTET IPV4 Head Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXIPV6HDERROCT",
        "offset": "0x0268",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXIPV6_HDRERR_OCTETS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received in IPv6 datagrams with header errors\n(length, version mismatch). The value in the IPv6 header's\nLength field is used to update this counter."
          }
        ],
        "description": "MMC RX OCTET IPV6 Head Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXUDPERROCT",
        "offset": "0x0274",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXUDP_ERR_OCTETS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received in a UDP segment that had checksum\nerrors."
          }
        ],
        "description": "MMC RX OCTET UDP Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXTCPERROCT",
        "offset": "0x027c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXTCP_ERR_OCTETS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received in a TCP segment with checksum\nerrors."
          }
        ],
        "description": "MMC RX OCTET TCP Error"
      },
      {
        "type": "register",
        "name": "GMAC_MMC_RXICMPERROCT",
        "offset": "0x0284",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RXICMP_ERR_OCTETS",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Number of bytes received in an ICMP segment with checksum\nerrors."
          }
        ],
        "description": "MMC RX OCTET ICMP Error"
      },
      {
        "type": "register",
        "name": "GMAC_BUS_MODE",
        "offset": "0x1000",
        "size": "W",
        "reset": "0x00020101",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:26",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "AAL",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Address-Aligned Beats\nWhen this bit is set high and the FB bit equals 1, the AXI\ninterface generates all bursts aligned to the start address LS bits.\nIf the FB bit equals 0, the first burst (accessing the data buffer's\nstart address) is not aligned, but subsequent bursts are aligned\nto the address."
          },
          {
            "name": "PBL_MODE",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "8xPBL Mode\nWhen set high, this bit multiplies the PBL value programmed (bits\n[22:17] and bits [13:8]) eight times. Thus the DMA will transfer\ndata in to a maximum of 8, 16, 32, 64, 128, and 256 beats\ndepending on the PBL value."
          },
          {
            "name": "USP",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x0",
            "description": "Use Separate PBL\nWhen set high, it configures the RxDMA to use the value\nconfigured in bits [22:17] as PBL while the PBL value in bits\n[13:8] is applicable to TxDMA operations only. When reset to low,\nthe PBL value in bits [13:8] is applicable for both DMA engines."
          },
          {
            "name": "RPBL",
            "bit_range": "22:17",
            "attr": "RW",
            "reset": "0x01",
            "description": "RxDMA PBL\nThese bits indicate the maximum number of beats to be\ntransferred in one RxDMA transaction. This will be the maximum\nvalue that is used in a single block Read/Write. The RxDMA will\nalways attempt to burst as specified in RPBL each time it starts a\nBurst transfer on the host bus. RPBL can be programmed with\npermissible values of 1, 2, 4, 8, 16, and 32. Any other value will\nresult in undefined behavior. These bits are valid and applicable\nonly when USP is set high."
          },
          {
            "name": "FB",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Fixed Burst\nThis bit controls whether the AXI Master interface performs fixed\nburst transfers or not. When set, the AHB will use only SINGLE,\nINCR4, INCR8 or INCR16 during start of normal burst transfers.\nWhen reset, the AXI will use SINGLE and INCR burst transfer\noperations."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PBL",
            "bit_range": "13:8",
            "attr": "RW",
            "reset": "0x01",
            "description": "Programmable Burst Length\nThese bits indicate the maximum number of beats to be\ntransferred in one DMA transaction. This will be the maximum\nvalue that is used in a single block Read/Write.\nThe DMA will always attempt to burst as specified in PBL each\ntime it starts a Burst transfer on the host bus. PBL can be\nprogrammed with permissible values of 1, 2, 4, 8, 16, and 32.\nAny other value will result in undefined behavior. When USP is\nset high, this PBL value is applicable for TxDMA transactions only.\nThe PBL values have the following limitations.\nThe maximum number of beats (PBL) possible is limited by the\nsize of the Tx FIFO and Rx FIFO in the MTL layer and the data bus\nwidth on the DMA. The FIFO has a constraint that the maximum\nbeat supported is half the depth of the FIFO, except when\nspecified (as given below). For different data bus widths and FIFO\nsizes, the valid PBL range (including x8 mode) is provided in the\nfollowing table. If the PBL is common for both transmit and\nreceive DMA, the minimum Rx FIFO and Tx FIFO depths must be\nconsidered. Do not program out-of-range PBL values, because\nthe system may not behave properly.\nFor TxFIFO, valid PBL range in full duplex mode and duplex mode\nis 128 or less.\nFor RxFIFO, valid PBL range in full duplex mode is all."
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DSL",
            "bit_range": "6:2",
            "attr": "RW",
            "reset": "0x00",
            "description": "Descriptor Skip Length\nThis bit specifies the number of dword to skip between two\nunchained descriptors. The address skipping starts from the end\nof current descriptor to the start of next descriptor. When DSL\nvalue equals zero, then the descriptor table is taken as\ncontiguous by the DMA, in Ring mode."
          },
          {
            "name": "RESERVED",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SWR",
            "bit_range": "0",
            "attr": "R/WSC",
            "reset": "0x1",
            "description": "Software Reset\nWhen this bit is set, the MAC DMA Controller resets all GMAC\nSubsystem internal registers and logic. It is cleared automatically\nafter the reset operation has completed in all of the core clock\ndomains. Read a 0 value in this bit before re-programming any\nregister of the core.\nNote: The reset operation is completed only when all the resets in\nall the active clock domains are de-asserted. Hence it is essential\nthat all the PHY inputs clocks (applicable for the selected PHY\ninterface) are present for software reset completion."
          }
        ],
        "description": "Bus Mode Register"
      },
      {
        "type": "register",
        "name": "GMAC_TX_POLL_DEMAND",
        "offset": "0x1004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TPD",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Transmit Poll Demand\nWhen these bits are written with any value, the DMA reads the\ncurrent descriptor pointed to by Register\nGMAC_CUR_HOST_TX_DESC. If that descriptor is not available\n(owned by Host), transmission returns to the Suspend state and\nDMA Register GMAC_STATUS[2] is asserted. If the descriptor is\navailable, transmission resumes."
          }
        ],
        "description": "Transmit Poll Demand Register"
      },
      {
        "type": "register",
        "name": "GMAC_RX_POLL_DEMAND",
        "offset": "0x1008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RPD",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Receive Poll Demand\nWhen these bits are written with any value, the DMA reads the\ncurrent descriptor pointed to by Register\nGMAC_CUR_HOST_RX_DESC. If that descriptor is not available\n(owned by Host), reception returns to the Suspended state and\nRegister GMAC_STATUS[7] is not asserted. If the descriptor is\navailable, the Receive DMA returns to active state."
          }
        ],
        "description": "Receive Poll Demand Register"
      },
      {
        "type": "register",
        "name": "GMAC_RX_DESC_LIST_ADDR",
        "offset": "0x100c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "SRL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Start of Receive List\nThis field contains the base address of the First Descriptor in the\nReceive Descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit\nbus width) will be ignored and taken as all-zero by the DMA\ninternally. Hence these LSB bits are Read Only."
          }
        ],
        "description": "Receive Descriptor List Address Register"
      },
      {
        "type": "register",
        "name": "GMAC_TX_DESC_LIST_ADDR",
        "offset": "0x1010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "STL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Start of Transmit List\nThis field contains the base address of the First Descriptor in the\nTransmit Descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit\nbus width) will be ignored and taken as all-zero by the DMA\ninternally. Hence these LSB bits are Read Only."
          }
        ],
        "description": "Transmit Descriptor List Address Register"
      },
      {
        "type": "register",
        "name": "GMAC_STATUS",
        "offset": "0x1014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:29",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "GPI",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "GMAC PMT Interrupt\nThis bit indicates an interrupt event in the GMAC core's PMT\nmodule. The software must read the corresponding registers in\nthe GMAC core to get the exact cause of interrupt and clear its\nsource to reset this bit to 1'b0. The interrupt signal from the\nGMAC subsystem (sbd_intr_o) is high when this bit is high."
          },
          {
            "name": "GMI",
            "bit_range": "27",
            "attr": "RO",
            "reset": "0x0",
            "description": "GMAC MMC Interrupt\nThis bit reflects an interrupt event in the MMC module of the\nGMAC core. The software must read the corresponding registers\nin the GMAC core to get the exact cause of interrupt and clear the\nsource of interrupt to make this bit as 1'b0. The interrupt signal\nfrom the GMAC subsystem (sbd_intr_o) is high when this bit is\nhigh."
          },
          {
            "name": "GLI",
            "bit_range": "26",
            "attr": "RO",
            "reset": "0x0",
            "description": "GMAC Line interface Interrupt\nThis bit reflects an interrupt event in the GMAC Core's PCS or\nRGMII interface block. The software must read the corresponding\nregisters in the GMAC core to get the exact cause of interrupt and\nclear the source of interrupt to make this bit as 1'b0. The\ninterrupt signal from the GMAC subsystem (sbd_intr_o) is high\nwhen this bit is high."
          },
          {
            "name": "EB",
            "bit_range": "25:23",
            "attr": "RO",
            "reset": "0x0",
            "description": "Error Bits\nThese bits indicate the type of error that caused a Bus Error\n(e.g., error response on the AXI interface). Valid only with Fatal\nBus Error bit (Register GMAC_STATUS[13]) set. This field does\nnot generate an interrupt.\nBit 23: 1'b1 Error during data transfer by TxDMA\n1'b0 Error during data transfer by RxDMA\nBit 24: 1'b1 Error during read transfer\n1'b0 Error during write transfer\nBit 25: 1'b1 Error during descriptor access\n1'b0 Error during data buffer access"
          },
          {
            "name": "TS",
            "bit_range": "22:20",
            "attr": "RO",
            "reset": "0x0",
            "description": "Transmit Process State\nThese bits indicate the Transmit DMA FSM state. This field does\nnot generate an interrupt.\n3'b000: Stopped; Reset or Stop Transmit Command issued.\n3'b001: Running; Fetching Transmit Transfer Descriptor.\n3'b010: Running; Waiting for status.\n3'b011: Running; Reading Data from host memory buffer and\nqueuing it to transmit buffer (Tx FIFO).\n3'b100: TIME_STAMP write state.\n3'b101: Reserved for future use.\n3'b110: Suspended; Transmit Descriptor Unavailable or Transmit\nBuffer Underflow.\n3'b111: Running; Closing Transmit Descriptor."
          },
          {
            "name": "RS",
            "bit_range": "19:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "Receive Process State\nThese bits indicate the Receive DMA FSM state. This field does\nnot generate an interrupt.\n3'b000: Stopped: Reset or Stop Receive Command issued.\n3'b001: Running: Fetching Receive Transfer Descriptor.\n3'b010: Reserved for future use.\n3'b011: Running: Waiting for receive packet.\n3'b100: Suspended: Receive Descriptor Unavailable.\n3'b101: Running: Closing Receive Descriptor.\n3'b110: TIME_STAMP write state.\n3'b111: Running: Transferring the receive packet data from\nreceive buffer to host memory."
          },
          {
            "name": "NIS",
            "bit_range": "16",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Normal Interrupt Summary\nNormal Interrupt Summary bit value is the logical OR of the\nfollowing when the corresponding interrupt bits are enabled in\nRegister OP_MODE:\nRegister GMAC_STATUS[0]: Transmit Interrupt\nRegister GMAC_STATUS[2]: Transmit Buffer Unavailable\nRegister GMAC_STATUS[6]: Receive Interrupt\nRegister GMAC_STATUS[14]: Early Receive Interrupt\nOnly unmasked bits affect the Normal Interrupt Summary bit.\nThis is a sticky bit and must be cleared (by writing a 1 to this bit)\neach time a corresponding bit that causes NIS to be set is\ncleared."
          },
          {
            "name": "AIS",
            "bit_range": "15",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Abnormal Interrupt Summary\nAbnormal Interrupt Summary bit value is the logical OR of the\nfollowing when the corresponding interrupt bits are enabled in\nRegister OP_MODE:\nRegister GMAC_STATUS[1]: Transmit Process Stopped\nRegister GMAC_STATUS[3]: Transmit Jabber Timeout\nRegister GMAC_STATUS[4]: Receive FIFO Overflow\nRegister GMAC_STATUS[5]: Transmit Underflow\nRegister GMAC_STATUS[7]: Receive Buffer Unavailable\nRegister GMAC_STATUS[8]: Receive Process Stopped\nRegister GMAC_STATUS[9]: Receive Watchdog Timeout\nRegister GMAC_STATUS[10]: Early Transmit Interrupt\nRegister GMAC_STATUS[13]: Fatal Bus Error\nOnly unmasked bits affect the Abnormal Interrupt Summary bit.\nThis is a sticky bit and must be cleared each time a\ncorresponding bit that causes AIS to be set is cleared."
          },
          {
            "name": "ERI",
            "bit_range": "14",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Early Receive Interrupt\nThis bit indicates that the DMA had filled the first data buffer of\nthe packet. Receive Interrupt Register GMAC_STATUS[6]\nautomatically clears this bit."
          },
          {
            "name": "FBI",
            "bit_range": "13",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Fatal Bus Error Interrupt\nThis bit indicates that a bus error occurred, as detailed in\n[25:23]. When this bit is set, the corresponding DMA engine\ndisables all its bus accesses."
          },
          {
            "name": "RESERVED",
            "bit_range": "12:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ETI",
            "bit_range": "10",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Early Transmit Interrupt\nThis bit indicates that the frame to be transmitted was fully\ntransferred to the MTL Transmit FIFO."
          },
          {
            "name": "RWT",
            "bit_range": "9",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Receive Watchdog Timeout\nThis bit is asserted when a frame with a length greater than\n2,048 bytes is received."
          },
          {
            "name": "RPS",
            "bit_range": "8",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Receive Process Stopped\nThis bit is asserted when the Receive Process enters the Stopped\nstate."
          },
          {
            "name": "RU",
            "bit_range": "7",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Receive Buffer Unavailable\nThis bit indicates that the Next Descriptor in the Receive List is\nowned by the host and cannot be acquired by the DMA. Receive\nProcess is suspended. To resume processing Receive descriptors,\nthe host should change the ownership of the descriptor and issue\na Receive Poll Demand command. If no Receive Poll Demand is\nissued, Receive Process resumes when the next recognized\nincoming frame is received. Register GMAC_STATUS[7] is set\nonly when the previous Receive Descriptor was owned by the\nDMA."
          },
          {
            "name": "RI",
            "bit_range": "6",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Receive Interrupt\nThis bit indicates the completion of frame reception. Specific\nframe status information has been posted in the descriptor.\nReception remains in the Running state."
          },
          {
            "name": "UNF",
            "bit_range": "5",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Transmit Underflow\nThis bit indicates that the Transmit Buffer had an Underflow\nduring frame transmission. Transmission is suspended and an\nUnderflow Error TDES0[1] is set."
          },
          {
            "name": "OVF",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Receive Overflow\nThis bit indicates that the Receive Buffer had an Overflow during\nframe reception. If the partial frame is transferred to application,\nthe overflow status is set in RDES0[11]."
          },
          {
            "name": "TJT",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Transmit Jabber Timeout\nThis bit indicates that the Transmit Jabber Timer expired,\nmeaning that the transmitter had been excessively active. The\ntransmission process is aborted and placed in the Stopped state.\nThis causes the Transmit Jabber Timeout TDES0[14] flag to\nassert."
          },
          {
            "name": "TU",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Transmit Buffer Unavailable\nThis bit indicates that the Next Descriptor in the Transmit List is\nowned by the host and cannot be acquired by the DMA.\nTransmission is suspended. Bits[22:20] explain the Transmit\nProcess state transitions. To resume processing transmit\ndescriptors, the host should change the ownership of the bit of\nthe descriptor and then issue a Transmit Poll Demand command."
          },
          {
            "name": "TPS",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Transmit Process Stopped\nThis bit is set when the transmission is stopped."
          },
          {
            "name": "TI",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Transmit Interrupt\nThis bit indicates that frame transmission is finished and\nTDES1[31] is set in the First Descriptor."
          }
        ],
        "description": "Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_OP_MODE",
        "offset": "0x1018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:27",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DT",
            "bit_range": "26",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Dropping of TCP/IP Checksum Error Frames\nWhen this bit is set, the core does not drop frames that only have\nerrors detected by the Receive Checksum Offload engine. Such\nframes do not have any errors (including FCS error) in the\nEthernet frame received by the MAC but have errors in the\nencapsulated payload only. When this bit is reset, all error frames\nare dropped if the FEF bit is reset."
          },
          {
            "name": "RSF",
            "bit_range": "25",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Store and Forward\nWhen this bit is set, the MTL only reads a frame from the Rx FIFO\nafter the complete frame has been written to it, ignoring RTC\nbits. When this bit is reset, the Rx FIFO operates in Cut-Through\nmode, subject to the threshold specified by the RTC bits."
          },
          {
            "name": "DFF",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Disable Flushing of Received Frames\nWhen this bit is set, the RxDMA does not flush any frames due to\nthe unavailability of receive descriptors/buffers as it does\nnormally when this bit is reset."
          },
          {
            "name": "RESERVED",
            "bit_range": "23:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TSF",
            "bit_range": "21",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Store and Forward\nWhen this bit is set, transmission starts when a full frame resides\nin the MTL Transmit FIFO. When this bit is set, the TTC values\nspecified in Register GMAC_OP_MODE[16:14] are ignored. This\nbit should be changed only when transmission is stopped."
          },
          {
            "name": "FTF",
            "bit_range": "20",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Flush Transmit FIFO\nWhen this bit is set, the transmit FIFO controller logic is reset to\nits default values and thus all data in the Tx FIFO is lost/flushed.\nThis bit is cleared internally when the flushing operation is\ncompleted fully. The Operation Mode register should not be\nwritten to until this bit is cleared. The data which is already\naccepted by the MAC transmitter will not be flushed. It will be\nscheduled for transmission and will result in underflow and runt\nframe transmission.\nNote: The flush operation completes only after emptying the\nTxFIFO of its contents and all the pending Transmit Status of the\ntransmitted frames are accepted by the host. In order to\ncomplete this flush operation, the PHY transmit clock (clk_tx_i) is\nrequired to be active."
          },
          {
            "name": "RESERVED",
            "bit_range": "19:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TTC",
            "bit_range": "16:14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Threshold Control\nThese three bits control the threshold level of the MTL Transmit\nFIFO. Transmission starts when the frame size within the MTL\nTransmit FIFO is larger than the threshold. In addition, full\nframes with a length less than the threshold are also transmitted.\nThese bits are used only when the TSF bit (Bit 21) is reset.\n3'b000: 64\n3'b001: 128\n3'b010: 192\n3'b011: 256\n3'b100: 40\n3'b101: 32\n3'b110: 24\n3'b111: 16"
          },
          {
            "name": "ST",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Start/Stop Transmission Command\nWhen this bit is set, transmission is placed in the Running state,\nand the DMA checks the Transmit List at the current position for a\nframe to be transmitted. Descriptor acquisition is attempted\neither from the current position in the list, which is the Transmit\nList Base Address set by Register GMAC_TX_DESC_LIST_ADDR,\nor from the position retained when transmission was stopped\npreviously. If the current descriptor is not owned by the DMA,\ntransmission enters the Suspended state and Transmit Buffer\nUnavailable (Register GMAC_STATUS[2]) is set. The Start\nTransmission command is effective only when transmission is\nstopped. If the command is issued before setting DMA Register\nTX_DESC_LIST_ADDR, then the DMA behavior is unpredictable.\nWhen this bit is reset, the transmission process is placed in the\nStopped state after completing the transmission of the current\nframe. The Next Descriptor position in the Transmit List is saved,\nand becomes the current position when transmission is restarted.\nThe stop transmission command is effective only the transmission\nof the current frame is complete or when the transmission is in\nthe Suspended state."
          },
          {
            "name": "RFD",
            "bit_range": "12:11",
            "attr": "RW",
            "reset": "0x0",
            "description": "Threshold for deactivating flow control (in both HD and FD)\nThese bits control the threshold (Fill-level of Rx FIFO) at which\nthe flow-control is de-asserted after activation.\n2'b00: Full minus 1 KB\n2'b01: Full minus 2 KB\n2'b10: Full minus 3 KB\n2'b11: Full minus 4 KB\nNote that the de-assertion is effective only after flow control is\nasserted."
          },
          {
            "name": "RFA",
            "bit_range": "10:9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Threshold for activating flow control (in both HD and FD)\nThese bits control the threshold (Fill level of Rx FIFO) at which\nflow control is activated.\n2'b00: Full minus 1 KB\n2'b01: Full minus 2 KB\n2'b10: Full minus 3 KB\n2'b11: Full minus 4 KB\nNote that the above only applies to Rx FIFOs of 4 KB or more\nwhen the EFC bit is set high."
          },
          {
            "name": "EFC",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable HW flow control\nWhen this bit is set, the flow control signal operation based on\nfill-level of Rx FIFO is enabled. When reset, the flow control\noperation is disabled."
          },
          {
            "name": "FEF",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Forward Error Frames\nWhen this bit is reset, the Rx FIFO drops frames with error status\n(CRC error, collision error, GMII_ER, giant frame, watchdog\ntimeout, overflow). However, if the frame's start byte (write)\npointer is already transferred to the read controller side (in\nThreshold mode), then the frames are not dropped.\nWhen FEF is set, all frames except runt error frames are\nforwarded to the DMA. But when RxFIFO overflows when a partial\nframe is written, then such frames are dropped even when FEF is\nset."
          },
          {
            "name": "FUF",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Forward Undersized Good Frames\nWhen set, the Rx FIFO will forward Undersized frames (frames\nwith no Error and length less than 64 bytes) including pad-bytes\nand CRC).\nWhen reset, the Rx FIFO will drop all frames of less than 64\nbytes, unless it is already transferred due to lower value of\nReceive Threshold (e.g., RTC = 01)."
          },
          {
            "name": "RESERVED",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RTC",
            "bit_range": "4:3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Threshold Control\nThese two bits control the threshold level of the MTL Receive\nFIFO. Transfer (request) to DMA starts when the frame size\nwithin the MTL Receive FIFO is larger than the threshold. In\naddition, full frames with a length less than the threshold are\ntransferred automatically. Note that value of 11 is not applicable\nif the configured Receive FIFO size is 128 bytes. These bits are\nvalid only when the RSF bit is zero, and are ignored when the\nRSF bit is set to 1.\n2'b00: 64\n2'b01: 32\n2'b10: 96\n2'b11: 128"
          },
          {
            "name": "OSF",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Operate on Second Frame\nWhen this bit is set, this bit instructs the DMA to process a\nsecond frame of Transmit data even before status for first frame\nis obtained."
          },
          {
            "name": "SR",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Start/Stop Receive\nWhen this bit is set, the Receive process is placed in the Running\nstate. The DMA attempts to acquire the descriptor from the\nReceive list and processes incoming frames. Descriptor\nacquisition is attempted from the current position in the list,\nwhich is the address set by register GMAC_RX_DESC_LIST_ADDR\nor the position retained when the Receive process was previously\nstopped. If no descriptor is owned by the DMA, reception is\nsuspended and Receive Buffer Unavailable (Register\nGMAC_STATUS[7]) is set. The Start Receive command is effective\nonly when reception has stopped. If the command was issued\nbefore setting register GMAC_RX_DESC_LIST_ADDR, DMA\nbehavior is unpredictable.\nWhen this bit is cleared, RxDMA operation is stopped after the\ntransfer of the current frame. The next descriptor position in the\nReceive list is saved and becomes the current position after the\nReceive process is restarted. The Stop Receive command is\neffective only when the Receive process is in either the Running\n(waiting for receive packet) or in the Suspended state."
          },
          {
            "name": "RESERVED",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Operation Mode Register"
      },
      {
        "type": "register",
        "name": "GMAC_INT_ENA",
        "offset": "0x101c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "NIE",
            "bit_range": "16",
            "attr": "RW",
            "reset": "0x0",
            "description": "Normal Interrupt Summary Enable\nWhen this bit is set, a normal interrupt is enabled. When this bit\nis reset, a normal interrupt is disabled. This bit enables the\nfollowing bits:\nRegister GMAC_STATUS[0]: Transmit Interrupt\nRegister GMAC_STATUS[2]: Transmit Buffer Unavailable\nRegister GMAC_STATUS[6]: Receive Interrupt\nRegister GMAC_STATUS[14]: Early Receive Interrupt"
          },
          {
            "name": "AIE",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "Abnormal Interrupt Summary Enable\nWhen this bit is set, an Abnormal Interrupt is enabled. When this\nbit is reset, an Abnormal Interrupt is disabled. This bit enables\nthe following bits\nRegister GMAC_STATUS[1]: Transmit Process Stopped\nRegister GMAC_STATUS[3]: Transmit Jabber Timeout\nRegister GMAC_STATUS[4]: Receive Overflow\nRegister GMAC_STATUS[5]: Transmit Underflow\nRegister GMAC_STATUS[7]: Receive Buffer Unavailable\nRegister GMAC_STATUS[8]: Receive Process Stopped\nRegister GMAC_STATUS[9]: Receive Watchdog Timeout\nRegister GMAC_STATUS[10]: Early Transmit Interrupt\nRegister GMAC_STATUS[13]: Fatal Bus Error"
          },
          {
            "name": "ERE",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Early Receive Interrupt Enable\nWhen this bit is set with Normal Interrupt Summary Enable (BIT\n16), Early Receive Interrupt is enabled. When this bit is reset,\nEarly Receive Interrupt is disabled."
          },
          {
            "name": "FBE",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "Fatal Bus Error Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), the Fatal Bus Error Interrupt is enabled. When this bit is\nreset, Fatal Bus Error Enable Interrupt is disabled."
          },
          {
            "name": "RESERVED",
            "bit_range": "12:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ETE",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Early Transmit Interrupt Enable\nWhen this bit is set with an Abnormal Interrupt Summary Enable\n(BIT 15), Early Transmit Interrupt is enabled. When this bit is\nreset, Early Transmit Interrupt is disabled."
          },
          {
            "name": "RWE",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Watchdog Timeout Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), the Receive Watchdog Timeout Interrupt is enabled.\nWhen this bit is reset, Receive\nWatchdog Timeout Interrupt is disabled."
          },
          {
            "name": "RSE",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Stopped Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Receive Stopped Interrupt is enabled. When this bit is\nreset, Receive Stopped Interrupt is disabled."
          },
          {
            "name": "RUE",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Buffer Unavailable Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Receive Buffer Unavailable Interrupt is enabled. When\nthis bit is reset, the Receive Buffer Unavailable Interrupt is\ndisabled"
          },
          {
            "name": "RIE",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Receive Interrupt Enable\nWhen this bit is set with Normal Interrupt Summary Enable (BIT\n16), Receive Interrupt is enabled. When this bit is reset, Receive\nInterrupt is disabled."
          },
          {
            "name": "UNE",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Underflow Interrupt Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Transmit Underflow Interrupt is enabled. When this bit\nis reset, Underflow Interrupt is disabled."
          },
          {
            "name": "OVE",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Overflow Interrupt Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Receive Overflow Interrupt is enabled. When this bit is\nreset, Overflow Interrupt is disabled"
          },
          {
            "name": "TJE",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Jabber Timeout Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Transmit Jabber Timeout Interrupt is enabled. When\nthis bit is reset, Transmit Jabber Timeout Interrupt is disabled."
          },
          {
            "name": "TUE",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Buffer Unavailable Enable\nWhen this bit is set with Normal Interrupt Summary Enable (BIT\n16), Transmit Buffer Unavailable Interrupt is enabled. When this\nbit is reset, Transmit Buffer Unavailable Interrupt is disabled."
          },
          {
            "name": "TSE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Stopped Enable\nWhen this bit is set with Abnormal Interrupt Summary Enable\n(BIT 15), Transmission Stopped Interrupt is enabled. When this\nbit is reset, Transmission Stopped Interrupt is disabled."
          },
          {
            "name": "TIE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Transmit Interrupt Enable\nWhen this bit is set with Normal Interrupt Summary Enable (BIT\n16), Transmit Interrupt is enabled. When this bit is reset,\nTransmit Interrupt is disabled."
          }
        ],
        "description": "Interrupt Enable Register"
      },
      {
        "type": "register",
        "name": "GMAC_OVERFLOW_CNT",
        "offset": "0x1020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:29",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_OVERFLOW_BIT",
            "bit_range": "28",
            "attr": "RC",
            "reset": "0x0",
            "description": "Overflow bit for FIFO Overflow Counter"
          },
          {
            "name": "FRAME_MISS_NUMBER",
            "bit_range": "27:17",
            "attr": "RC",
            "reset": "0x000",
            "description": "Indicates the number of frames missed by the application\nThis counter is incremented each time the MTL asserts the\nsideband signal mtl_rxoverflow_o. The counter is cleared when\nthis register is read with mci_be_i[2] at 1'b1."
          },
          {
            "name": "MISS_FRAME_OVERFLOW_BIT",
            "bit_range": "16",
            "attr": "RC",
            "reset": "0x0",
            "description": "Overflow bit for Missed Frame Counter"
          },
          {
            "name": "FRAME_MISS_NUMBER_2",
            "bit_range": "15:0",
            "attr": "RC",
            "reset": "0x0000",
            "description": "Indicates the number of frames missed by the controller due to\nthe Host Receive Buffer being unavailable. This counter is\nincremented each time the DMA discards an incoming frame. The\ncounter is cleared when this register is read with mci_be_i[0] at\n1'b1."
          }
        ],
        "description": "Missed Frame and Buffer Overflow Counter Register"
      },
      {
        "type": "register",
        "name": "GMAC_REC_INT_WDT_TIMER",
        "offset": "0x1024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RIWT",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "RI Watchdog Timer count\nIndicates the number of system clock cycles multiplied by 256 for\nwhich the watchdog timer is set. The watchdog timer gets\ntriggered with the programmed value after the RxDMA completes\nthe transfer of a frame for which the  RI status bit is not set due\nto the setting in the corresponding descriptor RDES1[31]. When\nthe watch-dog timer runs out, the RI bit is set and the timer is\nstopped. The watchdog timer is reset when RI bit is set high due\nto automatic setting of RI as per RDES1[31] of any received\nframe."
          }
        ],
        "description": "Receive Interrupt Watchdog Timer Register"
      },
      {
        "type": "register",
        "name": "GMAC_AXI_BUS_MODE",
        "offset": "0x1028",
        "size": "W",
        "reset": "0x00110001",
        "bit_ranges": [
          {
            "name": "EN_LPI",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable LPI (Low Power Interface)\nWhen set to 1, enable the LPI (Low Power Interface) supported\nby the GMAC and accepts the LPI request from the AXI System\nClock controller.\nWhen set to 0, disables the Low Power Mode and always denies\nthe LPI request from the AXI System Clock controller."
          },
          {
            "name": "UNLCK_ON_MGK_RWK",
            "bit_range": "30",
            "attr": "RW",
            "reset": "0x0",
            "description": "Unlock  on Magic Packet or Remote Wake Up\nWhen set to 1, enables it to request coming out of Low Power\nmode only when Magic Packet or Remote Wake Up Packet is\nreceived.\nWhen set to 0, enables it requests to come out of Low Power\nmode when any frame is received."
          },
          {
            "name": "RESERVED",
            "bit_range": "29:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WR_OSR_LMT",
            "bit_range": "21:20",
            "attr": "RW",
            "reset": "0x1",
            "description": "AXI Maximum Write Out Standing Request Limit\nThis value limits the maximum outstanding request on the AXI\nwrite interface.\nMaximum outstanding requests = WR_OSR_LMT+1"
          },
          {
            "name": "RESERVED",
            "bit_range": "19:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RD_OSR_LMT",
            "bit_range": "17:16",
            "attr": "RW",
            "reset": "0x1",
            "description": "AXI Maximum Read Out Standing Request Limit\nThis value limits the maximum outstanding request on the AXI\nread interface.\nMaximum outstanding requests = RD_OSR_LMT+1"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "AXI_AAL",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x0",
            "description": "Address-Aligned Beats\nThis bit is read-only bit and reflects the AAL bit (register\nGMAC_BUS_MODE[25]).\nWhen this bit set to 1, it performs address-aligned burst transfers\non both read and write channels."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BLEN16",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "AXI Burst Length 16\nWhen this bit is set to 1, or when UNDEF is set to 1, it is allowed\nto select a burst length of 16."
          },
          {
            "name": "BLEN8",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "AXI Burst Length 8\nWhen this bit is set to 1, or when UNDEF is set to 1, it is allowed\nto select a burst length of 8."
          },
          {
            "name": "BLEN4",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "AXI Burst Length 4\nWhen this bit is set to 1, or when UNDEF is set to 1, it is allowed\nto select a burst length of 4."
          },
          {
            "name": "UNDEF",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x1",
            "description": "AXI Undefined Burst Length\nThis bit is read-only bit and indicates the complement (invert)\nvalue of FB bit in register GMAC_BUS_MODE[16].\nWhen this bit is set to 1, it is allowed to perform any burst length\nequal to or below the maximum allowed burst length as\nprogrammed in bits[7:1];\nWhen this bit is set to 0, it is allowed to perform only fixed burst\nlengths as indicated by BLEN256/128/64/32/16/8/4, or a burst\nlength of 1."
          }
        ],
        "description": "AXI Bus Mode Register"
      },
      {
        "type": "register",
        "name": "GMAC_AXI_STATUS",
        "offset": "0x102c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RD_CH_STA",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "When high, it indicates that AXI Master's read channel is active\nand transferring data."
          },
          {
            "name": "WR_CH_STA",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "When high, it indicates that AXI Master's write channel is active\nand transferring data."
          }
        ],
        "description": "AXI Status Register"
      },
      {
        "type": "register",
        "name": "GMAC_CUR_HOST_TX_DESC",
        "offset": "0x1048",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HTDAP",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Host Transmit Descriptor Address Pointer\nCleared on Reset. Pointer updated by DMA during operation."
          }
        ],
        "description": "Current Host Transmit Descriptor Register"
      },
      {
        "type": "register",
        "name": "GMAC_CUR_HOST_RX_DESC",
        "offset": "0x104c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HRDAP",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Host Receive Descriptor Address Pointer\nCleared on Reset. Pointer updated by DMA during operation."
          }
        ],
        "description": "Current Host Receive Descriptor Register"
      },
      {
        "type": "register",
        "name": "GMAC_CUR_HOST_TX_BUF_ADDR",
        "offset": "0x1050",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HTBAP",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Host Transmit Buffer Address Pointer\nCleared on Reset. Pointer updated by DMA during operation."
          }
        ],
        "description": "Current Host Transmit Buffer Address Register"
      },
      {
        "type": "register",
        "name": "GMAC_CUR_HOST_RX_BUF_ADDR",
        "offset": "0x1054",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "HRBAP",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Host Receive Buffer Address Pointer\nCleared on Reset. Pointer updated by DMA during operation."
          }
        ],
        "description": "Current Host Receive Buffer Address Register"
      }
    ],
    "name": "GMAC",
    "summary": [
      {
        "name": "GMAC_MAC_CONF",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "MAC Configuration Register"
      },
      {
        "name": "GMAC_MAC_FRM_FILT",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "MAC Frame Filter"
      },
      {
        "name": "GMAC_HASH_TAB_HI",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "Hash Table High Register"
      },
      {
        "name": "GMAC_HASH_TAB_LO",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Hash Table Low Register"
      },
      {
        "name": "GMAC_GMII_ADDR",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "GMII Address Register"
      },
      {
        "name": "GMAC_GMII_DATA",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "GMII Data Register"
      },
      {
        "name": "GMAC_FLOW_CTRL",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Flow Control Register"
      },
      {
        "name": "GMAC_VLAN_TAG",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "VLAN Tag Register"
      },
      {
        "name": "GMAC_DEBUG",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "description": "Debug register"
      },
      {
        "name": "GMAC_PMT_CTRL_STA",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "PMT Control and Status Register"
      },
      {
        "name": "GMAC_INT_STATUS",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Status Register"
      },
      {
        "name": "GMAC_INT_MASK",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Mask Register"
      },
      {
        "name": "GMAC_MAC_ADDR0_HI",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x0000ffff",
        "description": "MAC Address0 High Register"
      },
      {
        "name": "GMAC_MAC_ADDR0_LO",
        "offset": "0x0044",
        "size": "W",
        "reset": "0xffffffff",
        "description": "MAC Address0 Low Register"
      },
      {
        "name": "GMAC_AN_CTRL",
        "offset": "0x00c0",
        "size": "W",
        "reset": "0x00000000",
        "description": "AN Control Register"
      },
      {
        "name": "GMAC_AN_STATUS",
        "offset": "0x00c4",
        "size": "W",
        "reset": "0x00000008",
        "description": "AN Status Register"
      },
      {
        "name": "GMAC_AN_ADV",
        "offset": "0x00c8",
        "size": "W",
        "reset": "0x000001e0",
        "description": "Auto Negotiation Advertisement Register"
      },
      {
        "name": "GMAC_AN_LINK_PART_AB",
        "offset": "0 x00cc",
        "size": "W",
        "reset": "0x00000000",
        "description": "Auto Negotiation Link Partner Ability Register"
      },
      {
        "name": "GMAC_AN_EXP",
        "offset": "0x00d0",
        "size": "W",
        "reset": "0x00000000",
        "description": "Auto Negotiation Expansion Register"
      },
      {
        "name": "GMAC_INTF_MODE_STA",
        "offset": "0x00d8",
        "size": "W",
        "reset": "0x00000000",
        "description": "RGMII Status Register"
      },
      {
        "name": "GMAC_MMC_CTRL",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Control Register"
      },
      {
        "name": "GMAC_MMC_RX_INTR",
        "offset": "0x0104",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Receive Interrupt Register"
      },
      {
        "name": "GMAC_MMC_TX_INTR",
        "offset": "0x0108",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Transmit Interrupt Register"
      },
      {
        "name": "GMAC_MMC_RX_INT_MSK",
        "offset": "0 x010c",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Receive Interrupt Mask Register"
      },
      {
        "name": "GMAC_MMC_TX_INT_MSK",
        "offset": "0x0110",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Transmit Interrupt Mask Register"
      },
      {
        "name": "GMAC_MMC_TXOCTETCNT_GB",
        "offset": "0x0114",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX OCTET Good and Bad Counter"
      },
      {
        "name": "GMAC_MMC_TXFRMCNT_GB",
        "offset": "0x0118",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX Frame Good and Bad Counter"
      },
      {
        "name": "GMAC_MMC_TXUNDFLWERR",
        "offset": "0x0148",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX Underflow Error"
      },
      {
        "name": "GMAC_MMC_TXCARERR",
        "offset": "0x0160",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX Carrier Error"
      },
      {
        "name": "GMAC_MMC_TXOCTETCNT_G",
        "offset": "0x0164",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX OCTET Good Counter"
      },
      {
        "name": "GMAC_MMC_TXFRMCNT_G",
        "offset": "0x0168",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC TX Frame Good Counter"
      },
      {
        "name": "GMAC_MMC_RXFRMCNT_GB",
        "offset": "0x0180",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX Frame Good and Bad Counter"
      },
      {
        "name": "GMAC_MMC_RXOCTETCNT_GB",
        "offset": "0x0184",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET Good and Bad Counter"
      },
      {
        "name": "GMAC_MMC_RXOCTETCNT_G",
        "offset": "0x0188",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET Good Counter"
      },
      {
        "name": "GMAC_MMC_RXMCFRMCNT_G",
        "offset": "0x0190",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX Multicast Frame Good Counter"
      },
      {
        "name": "GMAC_MMC_RXCRCERR",
        "offset": "0x0194",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX Carrier"
      },
      {
        "name": "GMAC_MMC_RXLENERR",
        "offset": "0x01c8",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX Length Error"
      },
      {
        "name": "GMAC_MMC_RXFIFOOVRFLW",
        "offset": "0x01d4",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX FIFO Overflow"
      },
      {
        "name": "GMAC_MMC_IPC_INT_MSK",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Receive Checksum Offload Interrupt Mask Register"
      },
      {
        "name": "GMAC_MMC_IPC_INTR",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC Receive Checksum Offload Interrupt Register"
      },
      {
        "name": "GMAC_MMC_RXIPV4GFRM",
        "offset": "0 x0210",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX IPV4 Good Frame"
      },
      {
        "name": "GMAC_MMC_RXIPV4HDERRFRM",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX IPV4 Head Error Frame"
      },
      {
        "name": "GMAC_MMC_RXIPV6GFRM",
        "offset": "0 x0224",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX IPV6 Good Frame"
      },
      {
        "name": "GMAC_MMC_RXIPV6HDERRFRM",
        "offset": "0x0228",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX IPV6 Head Error Frame"
      },
      {
        "name": "GMAC_MMC_RXUDPERRFRM",
        "offset": "0x0234",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX UDP Error Frame"
      },
      {
        "name": "GMAC_MMC_RXTCPERRFRM",
        "offset": "0x023c",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX TCP Error Frame"
      },
      {
        "name": "GMAC_MMC_RXICMPERRFRM",
        "offset": "0x0244",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX ICMP Error Frame"
      },
      {
        "name": "GMAC_MMC_RXIPV4HDERROCT",
        "offset": "0x0254",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET IPV4 Head Error"
      },
      {
        "name": "GMAC_MMC_RXIPV6HDERROCT",
        "offset": "0x0268",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET IPV6 Head Error"
      },
      {
        "name": "GMAC_MMC_RXUDPERROCT",
        "offset": "0x0274",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET UDP Error"
      },
      {
        "name": "GMAC_MMC_RXTCPERROCT",
        "offset": "0x027c",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET TCP Error"
      },
      {
        "name": "GMAC_MMC_RXICMPERROCT",
        "offset": "0x0284",
        "size": "W",
        "reset": "0x00000000",
        "description": "MMC RX OCTET ICMP Error"
      },
      {
        "name": "GMAC_BUS_MODE",
        "offset": "0x1000",
        "size": "W",
        "reset": "0x00020101",
        "description": "Bus Mode Register"
      },
      {
        "name": "GMAC_TX_POLL_DEMAND",
        "offset": "0x1004",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit Poll Demand Register"
      },
      {
        "name": "GMAC_RX_POLL_DEMAND",
        "offset": "0x1008",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive Poll Demand Register"
      },
      {
        "name": "GMAC_RX_DESC_LIST_ADDR",
        "offset": "0x100c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive Descriptor List Address Register"
      },
      {
        "name": "GMAC_TX_DESC_LIST_ADDR",
        "offset": "0x1010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Transmit Descriptor List Address Register"
      },
      {
        "name": "GMAC_STATUS",
        "offset": "0x1014",
        "size": "W",
        "reset": "0x00000000",
        "description": "Status Register"
      },
      {
        "name": "GMAC_OP_MODE",
        "offset": "0x1018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Operation Mode Register"
      },
      {
        "name": "GMAC_INT_ENA",
        "offset": "0x101c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt Enable Register"
      },
      {
        "name": "GMAC_OVERFLOW_CNT",
        "offset": "0x1020",
        "size": "W",
        "reset": "0x00000000",
        "description": "Missed Frame and Buffer Overflow Counter Register"
      },
      {
        "name": "GMAC_REC_INT_WDT_TIMER",
        "offset": "0x1024",
        "size": "W",
        "reset": "0x00000000",
        "description": "Receive Interrupt Watchdog Timer Register"
      },
      {
        "name": "GMAC_AXI_BUS_MODE",
        "offset": "0x1028",
        "size": "W",
        "reset": "0x00110001",
        "description": "AXI Bus Mode Register"
      },
      {
        "name": "GMAC_AXI_STATUS",
        "offset": "0x102c",
        "size": "W",
        "reset": "0x00000000",
        "description": "AXI Status Register"
      },
      {
        "name": "GMAC_CUR_HOST_TX_DESC",
        "offset": "0x1048",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current Host Transmit Descriptor Register"
      },
      {
        "name": "GMAC_CUR_HOST_RX_DESC",
        "offset": "0x104c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current Host Receive Descriptor Register"
      },
      {
        "name": "GMAC_CUR_HOST_TX_BUF_ADDR",
        "offset": "0x1050",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current Host Transmit Buffer Address Register"
      },
      {
        "name": "GMAC_CUR_HOST_RX_BUF_ADDR",
        "offset": "0x1054",
        "size": "W",
        "reset": "0x00000000",
        "description": "Current Host Receive Buffer Address Register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "EMMCCORE_SADDR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "SADDR",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "This register contains the physical system memory address used\nfor DMA transfers or the second argument for the Auto CMD23.\n(1) SDMA System Address\nThis register contains the system memory address for a SDMA\ntransfer. When the Host Controller stops a SDMA transfer, this\nregister shall point to the system address of the next contiguous\ndata position. It can be accessed only if no transaction is\nexecuting (i.e., after a transaction has stopped). Read operations\nduring transfers may return an invalid value. The Host Driver\nshall initialize this register before starting a SDMA transaction.\nAfter SDMA has stopped, the next system address of the next\ncontiguous data position can be read from this register.\nThe SDMA transfer waits at the every boundary specified by the\nHost SDMA Buffer Boundary in the Block Size register. The Host\nController generates DMA Interrupt to request the Host Driver to\nupdate this register. The Host Driver sets the next system\naddress of the next data position to this register.\nWhen the most upper byte of this register (003h) is written, the\nHost Controller restarts the SDMA transfer.\nWhen restarting SDMA by the Resume command or by setting\nContinue Request in the Block Gap Control register, the Host\nController shall start at the next contiguous address stored here\nin the SDMA System Address register. ADMA does not use this\nregister.\n(2) Argument 2\nThis register is used with the Auto CMD23 to set a 32-bit block\ncount value to the argument of the CMD23 while executing Auto\nCMD23.\nIf Auto CMD23 is used with ADMA, the full 32-bit block count\nvalue can be used. If Auto CMD23 is used without AMDA, the\navailable block count value is limited by the Block Count register.\n65535 blocks is the maximum value in this case."
          }
        ],
        "description": "System address/ Argument 2 register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_BLKSIZ",
        "offset": "0x0004",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HOSTSDMABUFFERSIZE",
            "bit_range": "14:12",
            "attr": "RW",
            "reset": "0x0",
            "description": "To perform long DMA transfer, System Address register shall be\nupdated at every system boundary during DMA transfer. These\nbits specify the size of contiguous buffer in the system memory.\nThe DMA transfer shall wait at the every boundary specified by\nthese fields and the HC generates the DMA Interrupt to request\nthe HD to update the System Address register.\nThese bits shall support when the DMA Support in the Capabilities\nregister is set to 1 and this function is active when the DMA\nEnable in the Transfer Mode register is set to 1.\n3'h0: 4KB(Detects A11 Carry out)\n3'h1: 8KB(Detects A12 Carry out)\n3'h2: 16KB(Detects A13 Carry out)\n3'h3: 32KB(Detects A14 Carry out)\n3'h4: 64KB(Detects A15 Carry out)\n3'h5: 128KB(Detects A16 Carry out)\n3'h6: 256KB(Detects A17 Carry out)\n3'h7: 512KB(Detects A18 Carry out)"
          },
          {
            "name": "TRANSFERBLOCKSIZE",
            "bit_range": "11:0",
            "attr": "RW",
            "reset": "0x000",
            "description": "This register specifies the block size for block data transfers for\nCMD17, CMD18, CMD24, CMD25, and CMD53. It can be accessed\nonly if no transaction is executing (i.e after a transaction has\nstopped). Read operations during transfer return an invalid value\nand write operations shall be ignored.\n12'h0000: No Data Transfer\n12'h0001: 1 Byte\n12'h0002: 2 Bytes\n12'h0003: 3 Bytes\n12'h0004: 4 Bytes\n........\n12'h01FF: 511 Bytes\n12'h0200: 512 Bytes\n........\n12'h0800: 2048 Bytes"
          }
        ],
        "description": "Block size register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_BLKCNT",
        "offset": "0x0006",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "BLOCKCOUNTFORCURRENTTRANSFER",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "This register is enabled when Block Count Enable in the Transfer\nMode register is set to 1 and is valid only for multiple block\ntransfers. The HC decrements the block count after each block\ntransfer and stops when the count reaches zero. It can be\naccessed only if no transaction is executing (i.e. after a\ntransaction has stopped). Read operations during transfer return\nan invalid value and write operations shall be ignored.\nWhen saving transfer context as a result of Suspend command,\nthe number of blocks yet to be transferred can be determined by\nreading this register. When restoring transfer context prior to\nissuing a Resume command, the HD shall restore the previously\nsave block count.\n16'h0000: Stop Count\n16'h0001: 1 block\n16'h0002: 2 blocks\n........\n16'hFFFF: 65535 blocks"
          }
        ],
        "description": "Block count register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ARG",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "COMMANDARGUMENT1",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "The SD Command Argument is specified as bit39-8 of Command-\nFormat."
          }
        ],
        "description": "Argument register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_TRANSMOD",
        "offset": "0x000c",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MULTIBLOCKSELECT",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit enables multiple block data transfers.\n0: Single Block\n1: Multiple Block"
          },
          {
            "name": "DATATRANSFERDIRECTIONSELECT",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit defines the direction of data transfers.\n0: Write (Host to Card)\n1: Read (Card to Host)"
          },
          {
            "name": "AUTOCMDENABLE",
            "bit_range": "3:2",
            "attr": "RW",
            "reset": "0x0",
            "description": "This field determines use of auto command functions\n0: Auto Command Disabled\n1: Auto CMD12 Enable\n2: Auto CMD23 Enable\n3: Reserved\nThere are two methods to stop Multiple-block read and write\noperation.\n(1) Auto CMD12 Enable\nMultiple-block read and write commands for memory require\nCMD12 to stop the operation. When this field is set to 01b, the\nHost Controller issues CMD12 automatically when last block\ntransferis completed. Auto CMD12 error is indicated to the Auto\nCMD Error Status register. The Host Driver shall not set this bit if\nthe command does not require CMD12.\n(2) Auto CMD23 Enable\nWhen this bit field is set to 10b, the Host Controller issues a\nCMD23 automatically before issuing a command specified in the\nCommand Register\nThe following conditions are required to use the Auto CMD23.\na. Auto CMD23 Supported (Host Controller Version is 3.00 or\nlater)\nb. A memory card that supports CMD23 (SCR[33]=1)\nc. If DMA is used, it shall be ADMA\nd. Only when CMD18 or CMD25 is issued\nBy writing the Command register, the Host Controller issues a\nCMD23 first and then issues a command specified by the\nCommand Index in Command register 32-bit block count value\nfor CMD23 is set to SDMA System Address / Argument 2 register"
          },
          {
            "name": "BLOCKCOUNTENABLE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit is used to enable the Block count register, which is only\nrelevant for multiple block transfers. When this bit is 0, the Block\nCount register is disabled, which is useful in executing an infinite\ntransfer.\n0: Disable\n1: Enable"
          },
          {
            "name": "DMAENABLE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "DMA can be enabled only if DMA Support bit in the Capabilities\nregister is set. If this bit is set to 1, a DMA operation shall begin\nwhen the HD writes to the upper byte of Command register\n(00Fh).\n0: Disable\n1: Enable"
          }
        ],
        "description": "Transfer mode register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CMD",
        "offset": "0x000e",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDTYPE",
            "bit_range": "7:6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Normal\n1: Suspend\n2: Resume\n3: Abort\nThere are three types of special commands. Suspend, Resume\nand Abort. These bits shall bet set to 00b for all other commands.\nSuspend Command\nIf the Suspend command succeeds, the HC shall assume the SD\nBus has been released and that it is possible to issue the next\ncommand which uses the DAT line. The HC shall de-assert Read\nWait for read transactions and stop checking busy for write\ntransactions. The Interrupt cycle shall start, in 4-bit mode. If the\nSuspend command fails, the HC shall maintain its current state.\nand the HD shall restart the transfer by setting Continue Request\nin the Block Gap Control Register.\nResume Command\nThe HD re-starts the data transfer by restoring the registers in\nthe range of 000-00Dh. The HC shall check for busy before\nstarting write transfers.\nAbort Command\nIf this command is set when executing a read transfer, the HC\nshall stop reads to the buffer. If this command is set when\nexecuting a write transfer, the HC shall stop driving the DAT line.\nAfter issuing the Abort command, the HD should issue a software\nreset."
          },
          {
            "name": "DATAPRESENTSEL",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: No Data Present\n1: Data Present\nThis bit is set to 1 to indicate that data is present and shall be\ntransferred using the DAT line. If is set to 0 for the following:\na. Commands using only CMD line (ex. CMD52)\nb. Commands with no data transfer but using busy signal on\nDAT[0] line (R1b or R5b ex. CMD38)\nc Resume Command"
          },
          {
            "name": "CMDINDEXCHKENA",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "If this bit is set to 1, the HC shall check the index field in the\nresponse to see if it has the same value as the command index.\nIf it is not, it is reported as a Command Index Error. If this bit is\nset to 0, the Index field is not checked.\n0: Disable\n1: Enable"
          },
          {
            "name": "CMDCRCCHKENA",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "If this bit is set to 1, the HC shall check the CRC field in the\nresponse. If an error is detected, it is reported as a Command\nCRC Error. If this bit is set to 0, the CRC field is not checked.\n0: Disable\n1: Enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RESPTYPESEL",
            "bit_range": "1:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Response Type Select\n0: No Response\n1: Response length 136\n2: Response length 48\n3: Response length 48 check Busy after response"
          }
        ],
        "description": "Command register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_RESP0",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESP",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Response register bit [31:0]"
          }
        ],
        "description": "Response register bit [31:0]"
      },
      {
        "type": "register",
        "name": "EMMCCORE_RESP1",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESP",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Response register bit [63:32]"
          }
        ],
        "description": "Response register bit [63:32]"
      },
      {
        "type": "register",
        "name": "EMMCCORE_RESP2",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESP",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Response register bit [95:64]"
          }
        ],
        "description": "Response register bit [95:64]"
      },
      {
        "type": "register",
        "name": "EMMCCORE_RESP3",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESP",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Response register bit [127:98]"
          }
        ],
        "description": "Response register bit [127:98]"
      },
      {
        "type": "register",
        "name": "EMMCCORE_BUFFER",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "BUFFERDATA",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "The Host Controller Buffer can be accessed through this 32-bit\nData Port Register."
          }
        ],
        "description": "Buffer data port register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PRESTS",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x1fff0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:29",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DAT74LINESIGNALLEVEL",
            "bit_range": "28:25",
            "attr": "RW",
            "reset": "0xf",
            "description": "This status is used to check DAT line level to recover from errors,\nand for debugging.\n[28]: DAT[7]\n[27]: DAT[6]\n[26]: DAT[5]\n[25]: DAT[4]"
          },
          {
            "name": "CMDLINESIGNALLEVEL",
            "bit_range": "24",
            "attr": "RO",
            "reset": "0x1",
            "description": "This status is used to check CMD line level to recover from errors,\nand for debugging."
          },
          {
            "name": "DAT30LINESIGNALLEVEL",
            "bit_range": "23:20",
            "attr": "RO",
            "reset": "0xf",
            "description": "DAT[3:0] Line Signal Level\nThis status is used to check DAT line level to recover from errors,\nand for debugging. This is especially useful in detecting the busy\nsignal level from DAT[0].\n[23]: DAT[3]\n[22]: DAT[2]\n[21]: DAT[1]\n[20]: DAT[0]"
          },
          {
            "name": "WRPRTSWPINLVL",
            "bit_range": "19",
            "attr": "RO",
            "reset": "0x1",
            "description": "Write Protect Switch Pin Level.\nThe Write Protect Switch is supported for memory and combo\ncards. This bit reflects the SDWP# pin.\n0: Write protected (SDWP# = 0)\n1: Write enabled (SDWP# = 1)"
          },
          {
            "name": "CARDDETECTPINLEVEL",
            "bit_range": "18",
            "attr": "RO",
            "reset": "0x1",
            "description": "This bit reflects the inverse value of the SDCD# pin.\n0: No Card present (SDCD# = 1)\n1: Card present (SDCD# = 0)"
          },
          {
            "name": "CARDSTATESTABLE",
            "bit_range": "17",
            "attr": "RO",
            "reset": "0x1",
            "description": "0: Reset of Debouncing\n1: No Card or Inserted\nThis bit is used for testing. If it is 0, the Card Detect Pin Level is\nnot stable. If this bit is set to 1, it means the Card Detect Pin\nLevel is stable. The Software Reset For All in the Software Reset\nRegister shall not affect this bit."
          },
          {
            "name": "CARDINSERTED",
            "bit_range": "16",
            "attr": "RO",
            "reset": "0x1",
            "description": "0: Reset or Debouncing or NoCard\n1: Card Inserted\nThis bit indicates whether a card has been inserted. Changing\nfrom 0 to 1 generates a Card Insertion interrupt in the Normal\nInterrupt Status register and changing from 1 to 0 generates a\nCard Removal Interrupt in the Normal Interrupt Status register.\nThe Software Reset For All in the Software Reset register shall\nnot affect this bit.\nIf a Card is removed while its power is on and its clock is\noscillating, the HC shall clear SD Bus Power in the Power Control\nregister and SD Clock Enable in the Clock control register. In\naddition the HD should clear the HC by the Software Reset For All\nin Software register. The card detect is active regardless of the\nSD Bus Power."
          },
          {
            "name": "RESERVED",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BUFFERREADENABLE",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "0: Read Disable\n1: Read Enable\nThis status is used for non-DMA read transfers.\nThis read only flag indicates that valid data exists in the host side\nbuffer status. If this bit is 1, readable data exists in the buffer. A\nchange of this bit from 1 to 0 occurs when all the block data is\nread from the buffer. A change of this bit from 0 to 1 occurs\nwhen all the block data is ready in the buffer and generates the\nBuffer Read Ready Interrupt."
          },
          {
            "name": "BUFFERWRITEENABLE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "0: Write Disable\n1: Write Enable\nThis status is used for non-DMA write transfers.\nThis read only flag indicates if space is available for write data. If\nthis bit is 1, data can be written to the buffer. A change of this bit\nfrom 1 to 0 occurs when all the block data is written to the\nbuffer. A change of this bit from 0 to 1 occurs when top of block\ndata can be written to the buffer and generates the Buffer Write\nReady Interrupt."
          },
          {
            "name": "READTRANSACTIVE",
            "bit_range": "9",
            "attr": "RO",
            "reset": "0x0",
            "description": "1: Transferring data\n0: No valid data\nThis status is used for detecting completion of a read transfer.\nThis bit is set to 1 for either of the following conditions:\na. After the end bit of the read command\nb. When writing a 1 to continue Request in the Block Gap Control\nregister to restart a read transfer\nThis bit is cleared to 0 for either of the following conditions:\na. When the last data block as specified by block length is\ntransferred to the system.\nb. When all valid data blocks have been transferred to the system\nand no current block transfers are being sent as a result of the\nStop At Block Gap Request set to 1. A transfer complete interrupt\nis generated when this bit changes to 0."
          },
          {
            "name": "WRITETRANSACTIVE",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "1: transferring data\n0: No valid data\nThis status indicates a write transfer is active. If this bit is 0, it\nmeans no valid write data exists in the HC. This bit is set in either\nof the following cases:\na. After the end bit of the write command.\nb. When writing a 1 to Continue Request in the Block Gap Control\nregister to restart a write transfer.\nThis bit is cleared in either of the following cases:\na. After getting the CRC status of the last data block as specified\nby the transfer count (Single or Multiple).\nb. After getting a CRC status of any block where data\ntransmission is about to be stopped by a Stop At Block Gap\nRequest.\nDuring a write transaction, a Block Gap Event interrupt is\ngenerated when this bit is changed to 0, as a result of the Stop At\nBlock Gap Request being set. This status is useful for the HD in\ndetermining when to issue commands during write busy."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RETUNINGREQ",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Re-Tuning Request\n1: Sampling clock needs re-tuning\n0: Fixed or well tuned sampling clock\nHost Controller may request Host Driver to execute re-tuning\nsequence by setting this bit when the data window is shifted by\ntemperature drift and a tuned sampling point does not have a\ngood margin to receive correct data.\nThis bit is cleared when a command is issued with setting Execute\nTuning in the Host Control 2 register.\nChanging of this bit from 0 to 1 generates Re-Tuning Event. Refer\nto Normal Interrupt registers for more detail.\nThis bit isn't set to 1 if Sampling Clock Select in the Host Control\n2 register is set to 0 (using fixed sampling clock)."
          },
          {
            "name": "DATLINEACTIVE",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit indicates whether one of the DAT line on SD bus is in use.\n1: DAT line active\n0: DAT line inactive"
          },
          {
            "name": "DATINHIBIT",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "1: cannot issue command which uses the DAT line\n0: Can issue command which uses the DAT line\nThis status bit is generated if either the DAT Line Active or the\nRead transfer Active is set to 1. If this bit is 0, it indicates the HC\ncan issue the next SD command. Commands with busy signal\nbelong to Command Inhibit (DAT) (ex. R1b, R5b type).\nChanging from 1 to 0 generates a Transfer Complete interrupt in\nthe Normal interrupt status register.\nNote: The SD Host Driver can save registers in the range of 000-\n00Dh for a suspend transaction after this bit has changed from 1\nto 0."
          },
          {
            "name": "CMDINHIBIT",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "If this bit is 0, it indicates the CMD line is not in use and the HC\ncan issue a SD command using the CMD line. This bit is set\nimmediately after the Command register is written. This bit is\ncleared when the command response is received.\nEven if the Command Inhibit (DAT) is set to 1, Commands using\nonly the CMD line can be issued if this bit is 0. Changing from 1\nto 0 generates a Command complete interrupt in the Normal\nInterrupt Status register. If the HC cannot issue the command\nbecause of a command conflict error or because of Command Not\nIssued By Auto CMD12 Error, this bit shall remain 1 and the\nCommand Complete is not set. Status issuing Auto CMD12 is not\nread from this bit.\nAuto CMD12 and Auto CMD23 consist of two responses. In this\ncase, this bit is not cleared by the response of CMD12 or CMD23\nbut cleared by the response of a read/write command. Status\nissuing Auto CMD12 is not read from this bit. So if a command is\nissued during Auto CMD12 operation, Host Controller shall\nmanage to issue two commands: CMD12 and a command set by\nCommand register."
          }
        ],
        "description": "Present state register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_HOSTCTRL1",
        "offset": "0x0028",
        "size": "B",
        "reset": "0x00",
        "bit_ranges": [
          {
            "name": "CARDDETSGINALDET",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit selects source for card detection.\n1: The card detect test level is selected\n0: SDCD# is selected (for normal use)"
          },
          {
            "name": "CARDDETTESTLEVEL",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit is enabled while the Card Detect Signal Selection is set to\n1 and it indicates card inserted or not.\nGenerates (card ins or card removal) interrupt when the normal\nint sts enable bit is set.\n1: Card Inserted\n0: No Card"
          },
          {
            "name": "EXTENDEDDATATRANSWIDTH",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit controls 8-bit bus width mode for embedded device.\nSupport of this function is indicated in 8-bit Support for\nEmbedded Device in the Capabilities register. If a device supports\n8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width\nis controlled by Data Transfer Width in the Host Control 1\nregister.This bit is not effective when multiple devices are\ninstalled on a bus slot (Slot Type is set to 10b in the Capabilities\nregister). In this case, each device bus width is controlled by Bus\nWidth Preset field in the Shared Bus register.\n1: 8-bit Bus Width\n0: Bus Width is Selected by Data Transfer Width"
          },
          {
            "name": "DMASELECT",
            "bit_range": "4:3",
            "attr": "RW",
            "reset": "0x0",
            "description": "One of supported DMA modes can be selected. The host driver\nshall check support of DMA modes by referring the Capabilities\nregister.\n0: SDMA is selected\n1: 32-bit Address ADMA1 is selected\n2: 32-bit Address ADMA2 is selected\n3: 64-bit Address ADMA2 is selected"
          },
          {
            "name": "HIGHSPEEDENA",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: High Speed Mode\n0: Normal Speed Mode\nThis bit is optional. Before setting this bit, the HD shall check the\nHigh Speed Support in the capabilities register. If this bit is set to\n0 (default), the HC outputs CMD line and DAT lines at the falling\nedge of the SD clock (up to 25 MHz/20MHz for eMMC). If thisbit\nis set to 1, the HC outputs CMD line and DAT lines at the rising\nedge of the SD clock (up to 50 MHz for SD/52MHz for eMMC)/\n208Mhz (for SD3.0).\nIf Preset Value Enable in the Host Control 2 register is set to 1,\nHost Driver needs to reset SD Clock Enable before changing this\nfield to avoid generating clock glitches. After setting this field, the\nHost Driver sets SD Clock Enable again"
          },
          {
            "name": "DATATRANSWIDTH",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: 4 bit mode\n0: 1 bit mode\nThis bit selects the data width of the HC. The HD shall select it to\nmatch the data width of the SD card."
          },
          {
            "name": "RESERVED",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Host control 1 register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PWRCTRL",
        "offset": "0x0029",
        "size": "B",
        "reset": "0x00",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "7:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDBUSPOWER",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: Power on\n0: Power off"
          }
        ],
        "description": "Power control register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_BLKGAPCTRL",
        "offset": "0x002a",
        "size": "B",
        "reset": "0x00",
        "bit_ranges": [
          {
            "name": "BOOTACKCHK",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "To check for the boot acknowledge in boot operation.\n1: wait for boot ack from eMMC card\n0: Will not wait for boot ack from eMMC card"
          },
          {
            "name": "ALTBOOTEN",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "To start boot code access in alternative mode.\n1: To start alternate boot mode access\n0: To stop alternate boot mode access"
          },
          {
            "name": "BOOTEN",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "To start boot code access.\n1: To start boot code access\n0: To stop boot code access"
          },
          {
            "name": "SPIMODE",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "SPI mode enable bit.\n1: SPI mode\n0: SD mode"
          },
          {
            "name": "INTATBLKGAP",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Interrupt At Block Gap.\nThis bit is valid only in 4-bit mode of the SDIO card and selects a\nsample point in the interrupt cycle. Setting to 1 enables interrupt\ndetection at the block gap for a multiple block transfer. If the SD\ncard cannot signal an interrupt during a multiple block transfer,\nthis bit should be set to 0. When the HD detects an SD card\ninsertion, it shall set this bit according to the CCCR of the SDIO\ncard."
          },
          {
            "name": "READWAITCONTROL",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: Enable Read Wait Control\n0: Disable Read Wait Control\nThe read wait function is optional for SDIO cards. If the card\nsupports read wait, set this bit to enable use of the read wait\nprotocol to stop read data using DAT[2] line. Otherwise the HC\nhas to stop the SD clock to hold read data, which restricts\ncommands generation. When the HD detects an SD card\ninsertion, it shall set this bit according to the CCCR of the SDIO\ncard. If the card does not support read wait, this bit shall never\nbe set to 1 otherwise DAT line conflict may occur.\nIf this bit is set to 0, Suspend / Resume cannot be supported"
          },
          {
            "name": "CONTINUEREQUEST",
            "bit_range": "1",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "1: Restart\n0: Ignored\nThis bit is used to restart a transaction which was stopped using\nthe Stop At Block Gap Request. To cancel stop at the block gap,\nset Stop At block Gap Request to 0 and set this bit to restart the\ntransfer.\nThe HC automatically clears this bit in either of the following\ncases:\na. In the case of a read transaction, the DAT Line Active changes\nfrom 0 to 1 as a read transaction restarts.\nb. In the case of a write transaction, the Write transfer active\nchanges from 0 to 1 as the write transaction restarts.\nTherefore it is not necessary for Host driver to set this bit to 0. If\nStop At Block Gap Request is set to 1, any write to this bit is\nignored."
          },
          {
            "name": "STOPATBLKGAPREQ",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: Stop\n0: Transfer\nThis bit is used to stop executing a transaction at the next block\ngap for non-DMA,SDMA and ADMA transfers. Until the transfer\ncomplete is set to 1, indicating a transfer completion the HD shall\nleave this bit set to 1. Clearing both the Stop At Block Gap\nRequest and Continue Request shall not cause the transaction to\nrestart. Read Wait is used to stop the read transaction at the\nblock gap. The HC shall honour Stop At Block Gap Request for\nwrite transfers, but for read transfers it requires that the SD card\nsupport Read Wait.\nTherefore the HD shall not set this bit during read transfers\nunless the SD card supports Read Wait and has set Read Wait\nControl to 1. In case ofwrite transfers in which the HD writes data\nto the Buffer Data Port register, the HD shall set this bit after all\nblock data is written. If this bit is set to 1, the HD shall not write\ndata to Buffer data port register. This bit affects Read Transfer\nActive, Write Transfer Active, DAT line active and Command\nInhibit (DAT) in the Present State register."
          }
        ],
        "description": "Block gap control register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CLKCTRL",
        "offset": "0x002c",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "SDCLKFREQSEL",
            "bit_range": "15:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "SDCLK Frequency Select.\nThis register is used to select the frequency of the SDCLK pin.\nThe frequency is not programmed directly; rather this register\nholds the divisor of the Base Clock Frequency For SD clock in the\ncapabilities register. Only the following settings are allowed.\n(1) 8-bit Divided Clock Mode\n8'h80: base clock divided by 256\n8'h40: base clock divided by 128\n8'h20: base clock divided by 64\n8'h10: base clock divided by 32\n8'h08: base clock divided by 16\n8'h04: base clock divided by 8\n8'h02: base clock divided by 4\n8'h01: base clock divided by 2\n8'h00: base clock(10MHz-63MHz)\nSetting 8'h00 specifies the highest frequency of the SD Clock.\nWhen setting multiple bits, the most significant bit is used as the\ndivisor. But multiple bits should not be set. The two default\ndivider values can be calculated by the frequency that is defined\nby the Base Clock Frequency For SD Clock in the Capabilities\nregister.\na. 25 MHz divider value\nb. 400 KHz divider value\nThe frequency of the SDCLK is set by the following formula:\nClock Frequency = (Baseclock) / divisor.\nThus choose the smallest possible divisor which results in a clock\nfrequency that is less than or equal to the target frequency.\nMaximum Frequency for SD = 50Mhz (base clock)\nMaximum Frequency for eMMC = 52Mhz (base clock)\nMinimum Frequency = 195.3125Khz (50Mhz / 256), same\ncalculation for eMMC also.\n(2) 10-bit Divided Clock Mode\nHost Controller supports this mandatory mode instead of the 8-\nbit Divided Clock Mode. The length of divider is extended to10\nbits and all divider values shall be supported.\n10'h3FF:1/2046 Divided Clock\nN: 1/2N Divided Clock (Duty 50%)\n10'h002: 1/4 Divided Clock\n10'h001: 1/2 Divided Clock\n10'h000: Base Clock (10MHz-254MHz)"
          },
          {
            "name": "SDCLKFREQSELUPPER",
            "bit_range": "7:6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Field0001 Abstract\nUpper Bits of SDCLK Frequency Select.\nBit 07-06 is assigned to bit 09-08 of clock divider in SDCLK\nFrequency Select"
          },
          {
            "name": "CLKGENSEL",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Clock Generator Select.\n1: Programmable Clock Mode\n0: Divided Clock Mode\nThis bit is used to select the clock generator mode in SDCLK\nFrequency Select.\nIf the Programmable Clock Mode is supported (non-zero value is\nset to Clock Multiplier in the Capabilities register), this bit\nattribute is RW, and if not supported, this bit attribute is RO and\nzero is read.\nThis bit depends on the setting of Preset Value Enable in the Host\nControl 2 register.\nIf the Preset Value Enable= 0, this bit is set by Host Driver.\nIf the Preset Value Enable= 1, this bit is automatically set to a\nvalue specified in one of Preset Value registers."
          },
          {
            "name": "RESERVED",
            "bit_range": "4:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SDCLKENA",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "SD Clock Enable.\n1: Enable\n0: Disable\nThe HC shall stop SDCLK when writing this bit to 0. SDCLK\nfrequency Select can be changed when this bit is 0. Then, the HC\nshall maintain the same clock frequency until SDCLK is stopped\n(Stop at SDCLK = 0). If the HC detects the No Card state, this bit\nshall be cleared."
          },
          {
            "name": "INTERNALCLOCKSTABLE",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Internal Clock Stable.\n1: Ready\n0: Not Ready\nThis bit is set to 1 when SD clock is stable after writing to\nInternal Clock Enable in this register to 1. The SD Host Driver\nshall wait to set SD Clock Enable until this bit is set to 1.\nNote: This is useful when using PLL for a clock oscillator that\nrequires setup time."
          },
          {
            "name": "INTERNALCLOCKENABLE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: Oscillate\n0: Stop\nThis bit is set to 0 when the HD is not using the HC or the HC\nawaits a wakeup event. The HC should stop its internal clock to\ngo very low power state. Still, registers shall be able to be read\nand written. Clock starts to oscillate when this bit is set to 1.\nWhen clock oscillation is stable, the HC shall set Internal Clock\nStable in this register to 1. This bit shall not affect card detection."
          }
        ],
        "description": "Clock control Register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_TIMEOUT",
        "offset": "0x002e",
        "size": "B",
        "reset": "0x00",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATATIMEOUTCOUNTERVALUE",
            "bit_range": "3:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "This value determines the interval by which DAT line time-outs\nare detected.\nRefer to the Data Time-out Error in the Error Interrupt\nStatusregister for information on factors that dictate time-out\ngeneration. Time-out clock frequency will be generated by\ndividing the sdclockTMCLK by this value. When setting this\nregister, prevent inadvertent time-out events by clearing the\nData Time-out Error Status Enable (in the Error Interrupt Status\nEnable register).\n4'hf: Reserved\n4'he: TMCLK * 2^27\n......\n4'h1: TMCLK * 2^14\n4'h0: TMCLK * 2^13"
          }
        ],
        "description": "Timeout control register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_SWRST",
        "offset": "0x002f",
        "size": "B",
        "reset": "0x00",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "7:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SOFTWARERESETDAT",
            "bit_range": "2",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Software Reset for DAT Line.\n1: Reset\n0: Work\nOnly part of data circuit is reset. The following registers and bits\nare cleared by this bit:\na. Buffer Data Port Register:\nBuffer is cleared and Initialized\nb. Present State register:\nBuffer read Enable\nBuffer write Enable\nRead Transfer Active\nWrite Transfer Active\nDAT Line Active\nCommand Inhibit (DAT)\nc. Block Gap Control register:\nContinue Request\nStop At Block Gap Request\nd. Normal Interrupt Status register:\nBuffer Read Ready\nBuffer Write Ready\nBlock Gap Event\nTransfer Complete"
          },
          {
            "name": "SOFTWARERESETCMD",
            "bit_range": "1",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Only part of command circuit is reset.\n1: Reset\n0: Work\nThe following registers and bits are cleared by this bit:\na. Present State register:\nCommand Inhibit (CMD)\nb. Normal Interrupt Status register:\nCommand Complete"
          },
          {
            "name": "SOFTWARERESETALL",
            "bit_range": "0",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Software Reset for All\n1: Reset\n0: Work\nThis reset affects the entire HC except for the card detection\ncircuit. Register bits of type ROC, RW, RW1C, RWAC are cleared\nto 0. During its initialization, the HD shall set this bit to 1 to reset\nthe HC.\nThe HC shall reset this bit to 0 when capabilities registers are\nvalid and the HD can read them. Additional use of Software Reset\nFor All may not affect the value of the Capabilities registers. If\nthis bit is set to 1, the SD card shall reset itself and must be\nreinitialized by the HD."
          }
        ],
        "description": "Software reset register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_NORINTSTS",
        "offset": "0x0030",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "ERRORINTERRUPT",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "0: No Error\n1: Error\nIf any of the bits inthe Error Interrupt Status Register are set,\nthen this bit is set. Therefore the HD can test for an error by\nchecking this bit first."
          },
          {
            "name": "BOOTTERMINATEINTERRUPT",
            "bit_range": "14",
            "attr": "W1C",
            "reset": "0x0",
            "description": "This status is set if the boot operation get terminated\n0: Boot operation is not terminated\n1: Boot operation is terminated"
          },
          {
            "name": "BOOTACKRCV",
            "bit_range": "13",
            "attr": "W1C",
            "reset": "0x0",
            "description": "This status is set if the boot acknowledge is received from device.\n0: Boot ack is not received\n1: Boot ack is received"
          },
          {
            "name": "RETUNINGEVENT",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x0",
            "description": "1: Re-Tuning should be performed\n0: Re-Tuning is not required\nThis status is set if Re-Tuning Request in the Present State\nregister changes from 0 to 1.\nHost Controller requestsHost Driver to perform re-tuning for next\ndata transfer. Current data transfer (not large block count) can\nbe completed without re-tuning."
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARDINTERRUPT",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "0: No Card Interrupt\n1: Generate Card Interrupt\nWriting this bit to 1 does not clear this bit. It is cleared by\nresetting the SD card interrupt factor. In 1-bit mode, the HC shall\ndetect the Card Interrupt without SD Clock to support wakeup.\nIn 4-bit mode, the card interrupt signal is sampled during the\ninterrupt cycle, so there are some sample delays between the\ninterrupt signal from the card and the interrupt to the Host\nsystem.\nwhen this status has been set and the HD needs to start this\ninterrupt service, Card Interrupt Status Enable in the Normal\nInterrupt Status register shall be set to 0 in order to clear the\ncard interrupt statuses latched in the HC and stop driving the\nHost System. After completion of the card interrupt service (the\nreset factor in the SD card and the interrupt signal may not be\nasserted), set Card Interrupt Status Enable to 1 and start\nsampling the interrupt signal again.\nInterrupt detected by DAT[1] is supported when there is a card\nper slot."
          },
          {
            "name": "CARDREMOVAL",
            "bit_range": "7",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: Card State Stable or Debouncing\n1: Card Removed\nThis status is set if the Card Inserted in the Present State register\nchanges from 1 to 0.\nWhen the HD writes this bit to 1 to clear this status the status of\nthe Card Inserted in the Present State registershould be\nconfirmed.\nBecause the card detect may possibly be changed when the HD\nclear this bit an Interrupt event may not be generated."
          },
          {
            "name": "CARDINSERTION",
            "bit_range": "6",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: Card State Stable or Debouncing\n1: Card Inserted\nThis status is set if the Card Inserted in the Present State register\nchanges from 0 to 1.\nWhen the HD writes this bit to 1 to clear this status the status of\nthe Card Inserted in the Present State registershould be\nconfirmed.\nBecause the card detect may possibly be changed when the HD\nclear this bit an Interrupt event may not be generated."
          },
          {
            "name": "BUFFERREADREADY",
            "bit_range": "5",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: Not Ready to read Buffer\n1: Ready to read Buffer\nThis status is set if the Buffer Read Enable changes from 0 to 1.\nBuffer Read Ready is set to 1 for every CMD19 execution in\ntuning procedure."
          },
          {
            "name": "BUFFERWRITEREADY",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: Not Ready to Write Buffer\n1: Ready to Write Buffer\nThis status is set if the Buffer Write Enable changes from 0 to 1."
          },
          {
            "name": "DMAINTERRUPT",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No DMA Interrupt\n1: DMA Interrupt is Generated\nThis status is set if the HC detects the Host DMA Buffer Boundary\nin the Block Size regiser."
          },
          {
            "name": "BLOCKGAPEVENT",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Block Gap Event\n1: Transaction stopped at Block Gap\nIf the Stop At Block Gap Request in the Block Gap Control\nRegister is set, this bit is set.\na. Read Transaction:\nThis bit is set at the falling edge of the DAT Line Active Status\n(When the transaction is stopped at SD Bus timing. The Read\nWait must be supported inorder to use this function).\nb. Write Transaction:\nThis bit is set at the falling edge of Write Transfer Active Status\n(After getting CRC status at SD Bus timing)."
          },
          {
            "name": "TRANSFERCOMPLETE",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Data Transfer Complete\n1: Data Transfer Complete\nThis bit is set when a read / write transaction is completed.\na. Read Transaction:\nThis bit is set at the falling edge of Read Transfer Active Status.\nThere are two cases in which the Interrupt is generated. The first\nis when a data transfer is completed as specified by data length\n(After the last data has been read to the Host System). The\nsecond is when data has stopped at the block gap and completed\nthe data transfer by setting the Stop At Block Gap Request in the\nBlock Gap Control Register (After valid data has been read to the\nHost System).\nb. Write Transaction:\nThis bit is set at the falling edge of the DAT Line Active Status.\nThere are two cases in which the Interrupt is generated. The first\nis when the last data is written to the card as specified by data\nlength and Busy signal is released. The second is when data\ntransfers are stopped at the block gap by setting Stop At Block\nGap Request in the Block Gap Control Register and data transfers\ncompleted. (Aftervalid data is written to the SD card and the busy\nsignal is released).\nc. In case of command with busy\nThis bit is set when busy is deasserted.\nNote:\na. Transfer Complete has higher priority than Data Time-out\nError. If both bits are set to 1, the data transfer can be\nconsidered complete\nb. While performing tuning procedure (Execute Tuning is set to\n1), Transfer Complete is not set to 1"
          },
          {
            "name": "COMMANDCOMPLETE",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Command Complete\n1: Command Complete\nThis bit is set when we get the end bit of the command response\n(Except Auto CMD12 and Auto CMD23)\nNote: Command Time-out Error has higher priority than\nCommand Complete. If both are set to 1, it can be considered\nthat the response was not received correctly."
          }
        ],
        "description": "Normal interrupt status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ERRINTSTS",
        "offset": "0x0032",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TARGETRESPERR",
            "bit_range": "12",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: no error\n1: error\nOccurs when detecting ERROR in m_hresp(dma transaction)"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADMAERR",
            "bit_range": "9",
            "attr": "W1C",
            "reset": "0x0",
            "description": "1: Error\n0: No error\nThis bit is set when the Host Controller detects errors during\nADMA based data transfer. The state of the ADMA at an error\noccurrence is saved in the ADMA Error Status Register."
          },
          {
            "name": "AUTOCMDERR",
            "bit_range": "8",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Error\nAuto CMD12 and Auto CMD23 use this error status.\nThis bit is set when detecting that one of the bits D00-D04 in\nAuto CMD Error Status register has changed from 0 to 1. In case\nof Auto CMD12, this bit is set to 1, not only when the errors in\nAuto CMD12 occur but also when Auto CMD12 is not executed\ndue to the previous command error."
          },
          {
            "name": "CURRENTLIMITERR",
            "bit_range": "7",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Power Fail\nBy setting the SD Bus Power bit in the Power Control Register,\nthe HC is requested to supply power for the SD Bus. If the HC\nsupports the Current Limit Function, it can be protected from an\nIllegal card by stopping power supply to the card in which case\nthis bit indicates a failure status. Reading 1 means the HC is not\nsupplying power to SD card due to some failure. Reading 0\nmeans that the HC is supplying power and no error has occurred.\nThis bit shall always set to be 0, if the HC does not support this\nfunction.\nNote: The current_Limit_Error is to be implemented if customer\napplication requires it.. By default it is not implementedas there\nis no specific requirement from Customers."
          },
          {
            "name": "DATAENDBITERR",
            "bit_range": "6",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Error\nOccurs when detecting 0 at the end bit position of read data\nwhich uses the DAT line or the end bit position of the CRC status."
          },
          {
            "name": "DATACRCERR",
            "bit_range": "5",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Error\nOccurs when detecting CRC error when transferring read data\nwhich uses the DAT line or when detecting the Write CRC Status\nhaving a value of other than \"010\"."
          },
          {
            "name": "DATATIMEOUTERR",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Timeout\nOccurs when detecting one of following timeout conditions.\na. Busy Timeout for R1b, R5b type.\nb. Busy Timeout after Write CRC status\nc. Write CRC status Timeout\nd. Read Data Timeout"
          },
          {
            "name": "CMDINDEXERR",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Error\nOccurs if a Command Index error occurs in the Command\nResponse."
          },
          {
            "name": "CMDENDBITERR",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: No Error\n1: End Bit Error Generated\nOccurs when detecting that the end bit of a command response is\n0."
          },
          {
            "name": "CMDCRCERR",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: CRC Error Generated\nCommand CRC Error is generated in two cases.\na. If a response is returned and the Command Time-out Error is\nset to 0, this bit is set to 1 when detecting a CRT error in the\ncommand response\nb. The HC detects a CMD line conflict by monitoring the CMD line\nwhen a command is issued. If the HC drives the CMD line to 1\nlevel, but detects 0 level on the CMD line at the next SDCLK\nedge, then the HC shall abort the command (Stop driving CMD\nline) and set this bit to 1. The Command Timeout Error shall also\nbe set to 1 to distinguish CMD line conflict."
          },
          {
            "name": "CMDTIMEOUTERR",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "0: No Error\n1: Timeout\nOccurs only if the no response is returned within 64 SDCLK cycles\nfrom the end bit of the command. If the HC detects a CMD line\nconflict, in which case Command CRC Error shall also be set. This\nbit shall be set without waiting for 64 SDCLK cycles because the\ncommand will be aborted by the HC."
          }
        ],
        "description": "Error interrupt status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_NORINTSTSENA",
        "offset": "0x0034",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BOOTTERMINATEINTERRUPT",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BOOTACKRCV",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RETUNINGEVENT",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARDINTERRUPT",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CARDREMOVAL",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CARDINSERTION",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BUFFERREADREADY",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BUFFERWRITEREADY",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DMAINTERRUPT",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BLOCKGAPEVENT",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "TRANSFERCOMPLETE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "COMMANDCOMPLETE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          }
        ],
        "description": "Normal interrupt status enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ERRINTSTSENA",
        "offset": "0x0036",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TARGETRESPERR",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADMAERR",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "AUTOCMDERR",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CURRENTLIMITERR",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATAENDBITERR",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATACRCERR",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATATIMEOUTERR",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDINDEXERR",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDENDBITERR",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDCRCERR",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDTIMEOUTERR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          }
        ],
        "description": "Error interrupt status enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_NORINTSIGENA",
        "offset": "0x0038",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BOOTTERMINATEINTERRUPT",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BOOTACKRCV",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RETUNINGEVENT",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CARDINTERRUPT",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CARDREMOVAL",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CARDINSERTION",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BUFFERREADREADY",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BUFFERWRITEREADY",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DMAINTERRUPT",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "BLOCKGAPEVENT",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "TRANSFERCOMPLETE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "COMMANDCOMPLETE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          }
        ],
        "description": "Normal interrupt signal enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ERRINTSIGENA",
        "offset": "0x003a",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TARGETRESPERR",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADMAERR",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "AUTOCMDERR",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CURRENTLIMITERR",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATAENDBITERR",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATACRCERR",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "DATATIMEOUTERR",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDINDEXERR",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDENDBITERR",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDCRCERR",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          },
          {
            "name": "CMDTIMEOUTERR",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "0: Masked\n1: Enabled"
          }
        ],
        "description": "Error interrupt signal enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ACMDERRSTS",
        "offset": "0x003c",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDNOTISSBYACMD12ERR",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "Command Not Issued By Auto CMD12 Error.\nSetting this bit to 1 means CMD_wo_DAT is not executed due to\nan Auto CMD12 error (D04 - D01) in this register.\nThis bit is set to 0 when Auto CMD Error is generated by Auto\nCMD23.\n0: No Error\n1: Not Issued"
          },
          {
            "name": "RESERVED",
            "bit_range": "6:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ACMDINDEXERR",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto CMD Index Error.\nOccurs if the Command Index error occurs in response to a\ncommand.\n0: No Error\n1: Error"
          },
          {
            "name": "ACMDENDBITERR",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto CMD End Bit Error.\nOccurs when detecting that the end bit of command response is\n0.\n0: No Error\n1: End Bit Error Generated"
          },
          {
            "name": "ACMDCRCERR",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto CMD CRC Error\nOccurs when detecting a CRC error in the command response.\n0: No Error\n1: CRC Error Generated"
          },
          {
            "name": "ACMDTIMEOUTERR",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto CMD Timeout Error\nOccurs if the no response is returned within 64 SDCLK cycles\nfrom the end bit of the command.\nIf this bit is set to 1, the other error status bits (D04 - D02) are\nmeaningless.\n0: No Error\n1: Timeout"
          },
          {
            "name": "ACMD12NOTEXE",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Auto CMD12 not Executed\nIf memory multiple block data transfer is not started due to\ncommand error, this bit is not set because it is not necessary to\nissue Auto CMD12. Setting this bit to 1 means the HC cannot\nissue Auto CMD12 to stop memory multiple block transfer due to\nsome\nerror. If this bit isset to 1, other error status bits (D04 - D01) are\nmeaningless.\nThis bit is set to 0 when Auto CMD Error is generated by Auto\nCMD23.\n0: Executed\n1: Not Executed"
          }
        ],
        "description": "Auto CMD error status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_HOSTCTRL2",
        "offset": "0x003e",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "PRESETVALUEENABLE",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x0",
            "description": "1: Automatic Selection by Preset Value are Enabled\n0: SDCLK and Driver Strength are controlled by Host Driver\nAs the operating SDCLK frequency and I/O driver strength\ndepend on the Host System implementation, it is difficult to\ndetermine these parameters in the Standard Host Driver. When\nPreset Value Enable is set to automatic. This bit enablesthe\nfunctions defined in the Preset Value registers.\nIf this bit is set to 0, SDCLK Frequency Select, Clock Generator\nSelect in the Clock Control register and Driver Strength Select in\nHost Control 2 register are set by Host Driver.\nIf this bit is set to 1, SDCLK Frequency Select, Clock Generator\nSelect in the Clock Control register and Driver Strength Select in\nHost Control 2 register are set by Host Controller as specified in\nthe Preset Value registers."
          },
          {
            "name": "ASYNINTEN",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x0",
            "description": "Asynchronous Interrupt Enable\nThis bit can be set to 1 if a card support asynchronous interrupt\nand Asynchronous Interrupt Support is set to 1 in the Capabilities\nregister. Asynchronous interrupt is effective when DAT[1]\ninterrupt is used in 4-bit SD mode(and zero is set to Interrupt Pin\nSelect in the Shared Bus Control register). If this bit is set to 1,\nthe Host Driver can stop the SDCLK during asynchronous\ninterrupt period to save power. During this period, the Host\nController continues to deliver CardInterrupt to the host when it\nis asserted by the card.\n1: Enabled\n0: Disabled"
          },
          {
            "name": "RESERVED",
            "bit_range": "13:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SAMPLINGCLOCKSELECT",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x0",
            "description": "Sampling Clock Select\nThis bit is set by tuning procedure when Execute Tuning is\ncleared. Writing 1 to this bit is meaningless and ignored. Setting\n1 means that tuning is completed successfully and setting 0\nmeans that tuning is failed. Host Controller uses this bit to select\nsampling clock to receive CMD and DAT. This bit is cleared by\nwriting 0. Change of this bit is not allowed while the Host\nController is receiving response or a read data block.\n1: Tuned clock is used to sample data\n0: Fixed clock is used to sample data"
          },
          {
            "name": "EXECUTETUNING",
            "bit_range": "6",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "This bit is set to 1 to start tuning procedure and automatically\ncleared when tuning procedure is completed. The result of tuning\nis indicated to Sampling Clock Select. Tuning procedure is\naborted by writing 0 for more detail about tuning procedure.\n1: Execute Tuning\n0: Not Tuned or Tuning Completed"
          },
          {
            "name": "RESERVED",
            "bit_range": "5:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "UHSMODESELECT",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "UHS Mode Select.\nThis field is used to select one of UHS-I modes and effective\nwhen 1.8V Signaling Enable is set to 1.\nIf Preset Value Enable in the Host Control 2 register is set to 1,\nHost Controller sets SDCLK Frequency Select, Clock Generator\nSelect in the Clock Control register and Driver Strength Select\naccording to Preset Value registers. In this case, one of preset\nvalue registers is selected by this field. Host Driver needs to reset\nSD Clock Enable before changing this field to avoid generating\nclock glitch. After setting this field, Host Driver sets SD Clock\nEnable again.\n3'h0: SDR12\n3'h1: SDR25\n3'h2: SDR50\n3'h3: SDR104\n3'h4: DDR50\n3'h5: HS400\nothers: Reserved\nWhen SDR50, SDR104 or DDR50 is selected for SDIO card,\ninterrupt detection at the block gap shall not be used. Read Wait\ntiming is changed for these modes. Refer to the SDIO\nSpecification Version 3.00 for more detail."
          }
        ],
        "description": "Host Control 2 Register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CAP",
        "offset": "0x0040",
        "size": "DW",
        "reset": "0x80002007\n44ed0000",
        "bit_ranges": [
          {
            "name": "HS400SUPPORT",
            "bit_range": "63",
            "attr": "RO",
            "reset": "0x1",
            "description": "HS400 Support\n0: Not Supported\n1: Supported"
          },
          {
            "name": "RESERVED",
            "bit_range": "62:58",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SPIBLOCKMODE",
            "bit_range": "57",
            "attr": "RO",
            "reset": "0x0",
            "description": "SPI block mode\n0: Not Supported\n1: Supported"
          },
          {
            "name": "RESERVED",
            "bit_range": "56",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKMULTIPLIER",
            "bit_range": "55:48",
            "attr": "RO",
            "reset": "0x10",
            "description": "This field indicates clock multiplier value of programmable clock\ngenerator. Refer to Clock Control register. Setting 00h means\nthat Host Controller does not support programmable clock\ngenerator.\n8'hFF: Clock Multiplier M = 256\n....\n8'h02: Clock Multiplier M = 3\n8'h01: Clock Multiplier M = 2\n8'h00: Clock Multiplier is Not Supported"
          },
          {
            "name": "RETUNINGMODE",
            "bit_range": "47:46",
            "attr": "RO",
            "reset": "0x0",
            "description": "Re-tuning modes\nThis field defines the re-tuning capability of a Host Controller and\nhow to manage the data transfer length and a Re-Tuning Timer\nby the Host Driver\n0: Mode1\n1: Mode2\n2: Mode3\n3: Reserved\nThere are two re-tuning timings:\nRe-Tuning Request and expiration of a Re-Tuning Timer. By\nreceiving either timing, the Host Driver executes the re-tuning\nprocedure just before a next command issue"
          },
          {
            "name": "USETUNINGFORSDR50",
            "bit_range": "45",
            "attr": "RO",
            "reset": "0x1",
            "description": "Use Tuning for SDR50\nIf this bit is set to 1, this Host Controller requires tuning to\noperate SDR50. (Tuning is always required to operate SDR104.)\n1: SDR50 requires tuning\n0: SDR50 does not require tuning"
          },
          {
            "name": "RESERVED",
            "bit_range": "44",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TIMERCOUNTFORRETUNING",
            "bit_range": "43:40",
            "attr": "RO",
            "reset": "0x0",
            "description": "Timer count for ReTuning\nThis field indicates an initial value of the Re-Tuning Timer for Re-\nTuning Mode 1 to 3.\n4'h0 - Get information via other source\n4'h1 = 1 seconds\n4'h2 = 2 seconds\n4'h3 = 4 seconds\n4'h4 = 8 seconds\n........\n4'hB = 1024 seconds\n4'hF - Ch = Reserved"
          },
          {
            "name": "DRIVERTYPE4SUPPORT",
            "bit_range": "39",
            "attr": "RO",
            "reset": "0x1",
            "description": "Driver Type 4 Support\n1: Driver Type 4 is Supported\n0: Driver Type 4 is Not Supported"
          },
          {
            "name": "DRIVERTYPEDSUPPORT",
            "bit_range": "38",
            "attr": "RO",
            "reset": "0x1",
            "description": "This bit indicates support of Driver Type D for 1.8 Signaling.\n1: Driver Type D is Supported\n0: Driver Type D is Not Supported"
          },
          {
            "name": "DRIVERTYPECSUPPORT",
            "bit_range": "37",
            "attr": "RW",
            "reset": "0x1",
            "description": "This bit indicates support of Driver Type C for 1.8 Signaling.\n1: Driver Type C is Supported\n0: Driver Type C is Not Supported"
          },
          {
            "name": "DRIVERTYPEASUPPORT",
            "bit_range": "36",
            "attr": "RO",
            "reset": "0x1",
            "description": "This bit indicates support of Driver Type A for 1.8 Signaling.\n1: Driver Type A is Supported\n0: Driver Type A is Not Supported"
          },
          {
            "name": "RESERVED",
            "bit_range": "35",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DDR50SUPPORT",
            "bit_range": "34",
            "attr": "RO",
            "reset": "0x1",
            "description": "DDR50 Support\n1: DDR50 is Supported\n0: DDR50 is Not Supported"
          },
          {
            "name": "SDR104SUPPORT",
            "bit_range": "33",
            "attr": "RO",
            "reset": "0x1",
            "description": "SDR104 Support.\n1: SDR104 is Supported\n0: SDR104 is Not Supported"
          },
          {
            "name": "SDR50SUPPORT",
            "bit_range": "32",
            "attr": "RO",
            "reset": "0x1",
            "description": "SDR50 Support\n1: SDR50 is Supported\n0: SDR50 is Not Supported"
          },
          {
            "name": "SLOTTYPE",
            "bit_range": "31:30",
            "attr": "RO",
            "reset": "0x1",
            "description": "This field indicates usage of a slot by a specific Host System. (A\nhost controller register set is defined per slot.) Embedded slot for\none device (01b) means that only one non-removable device is\nconnected to a SD bus slot. Shared Bus Slot (10b) can be set if\nHost Controller supports Shared Bus Control register.\nThe Standard Host Driver controls only a removable card or one\nembedded device is onnected to a SD bus slot. If a slot is\nconfigured for shared bus (10b), the Standard Host Driver does\nnot control embedded devices connected to a shared bus. Shared\nbus slot is controlled by a specific host driver developed by a Host\nSystem.\n0: Removable Card Slot\n1: Embedded Slot for One Device\n2: Shared Bus Slot\n3: Reserved"
          },
          {
            "name": "ASYNINTSUPPORT",
            "bit_range": "29",
            "attr": "RO",
            "reset": "0x0",
            "description": "Asynchronous Interrupt Support\nRefer to SDIO Specification Version 3.00 about asynchronous\ninterrupt.\n1: Asynchronous Interrupt Supported\n0: Asynchronous Interrupt Not Supported"
          },
          {
            "name": "SYSTEMBUSSUPPORT",
            "bit_range": "28",
            "attr": "RO",
            "reset": "0x0",
            "description": "64-bit System Bus Support\n1: Supports 64 bit system address\n0: Does not support 64 bit system address"
          },
          {
            "name": "RESERVED",
            "bit_range": "27",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VOLTAGE18VSUPPORT",
            "bit_range": "26",
            "attr": "RO",
            "reset": "0x1",
            "description": "Voltage Support 1.8 V\n0: Not Supported\n1: Supported"
          },
          {
            "name": "VOLTAGE30VSUPPORT",
            "bit_range": "25",
            "attr": "RO",
            "reset": "0x0",
            "description": "Voltage Support 3.0 V\n0: Not Supported\n1: Supported"
          },
          {
            "name": "VOLTAGE33VSUPPORT",
            "bit_range": "24",
            "attr": "RW",
            "reset": "0x0",
            "description": "Voltage Support 3.3 V\n0: Not Supported\n1: Supported"
          },
          {
            "name": "SUSPENDRESUMESUPPORT",
            "bit_range": "23",
            "attr": "RW",
            "reset": "0x1",
            "description": "Suspend / Resume Support\nThis bit indicates whether the HC supports Suspend / Resume\nfunctionality. If this bit is 0, the Suspend and Resume mechanism\nare not supported and the HD shall not issue either Suspend /\nResume commands.\n0: Not Supported\n1: Supported"
          },
          {
            "name": "SDMASUPPORT",
            "bit_range": "22",
            "attr": "RO",
            "reset": "0x1",
            "description": "This bit indicates whether the HC is capable of using DMA to\ntransfer data between system memory and the HC directly.\n0: SDMA Not Supported\n1: SDMA Supported."
          },
          {
            "name": "HIGHSPEEDSUPPORT",
            "bit_range": "21",
            "attr": "RO",
            "reset": "0x1",
            "description": "High Speed Support\nThis bit indicates whether the HC and the Host System support\nHigh Speed mode and they can supply SD Clock frequency from\n25Mhz to 50 Mhz (for SD)/ 20MHz to 52MHz (for eMMC).\n0: High Speed Not Supported\n1: High Speed Supported"
          },
          {
            "name": "RESERVED",
            "bit_range": "20",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADMA2SUPPORT",
            "bit_range": "19",
            "attr": "RO",
            "reset": "0x1",
            "description": "ADMA2 Support\n1: ADMA2 support\n0: ADMA2 not support"
          },
          {
            "name": "EXTENDEDMEDIABUSSUPPORT",
            "bit_range": "18",
            "attr": "RO",
            "reset": "0x1",
            "description": "Extended Media Bus Support\nThis bit indicates whether the Host Controller is capable of using\n8-bit bus width mode. This bit is not effective when Slot Type is\nset to 10b. In this case, refer to Bus Width Preset in the Shared\nBus resister.\n1: Extended Media Bus Supported\n0: Extended Media Bus not Supported"
          },
          {
            "name": "MAXBLOCKLENGTH",
            "bit_range": "17:16",
            "attr": "RO",
            "reset": "0x1",
            "description": "Max Block Length\nThis value indicates the maximum block size that the HD can\nread and write to the buffer in the HC.\nThe buffer shall transfer this block size without wait cycles. Three\nsizes can be defined as indicated below.\n0: 512 byte\n1: 1024 byte\n2: 2048 byte\n3: 4096 byte"
          },
          {
            "name": "BASECLOCKFREQSDCLOCK",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0xc8",
            "description": "Base Clock Frequency for SD Clock\n(1) 6-bit Base Clock Frequency\nThis mode is supported by the Host Controller Version 1.00 and\n2.00. Upper 2-bit is not effective and always 0. Unit values are\n1MHz. The supported clock range is 10MHz to 63MHz.\n8'h00: Get information via another method\n8'h01: 1MHz\n8'h02: 2MHz\n......\n8'h3f: 63MHz\nothers: not supported\n(2) 8-bit Base Clock Frequency\nThis mode is supported by the Host Controller Version 3.00. Unit\nvalues are 1MHz. The supported clock range is 10MHz to 255MHz.\n8'h00: Get information via another method\n8'h01: 1MHz\n8'h02: 2MHz\n......\n8'hff: 255MHz\nIf the real frequency is 16.5MHz, the lager value shall be set\n0001 0001b (17MHz) because the Host Driver use this value to\ncalculate the clock divider value (Refer to the SDCLK Frequency\nSelect in the Clock Control register.) and it shall not exceed upper\nlimit of the SD Clock frequency. If these bits are all 0, the Host\nSystem has to get information via another method."
          },
          {
            "name": "TIMEOUTCLOCKUNIT",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x1",
            "description": "This bit shows the unit of base clock frequency used to detect\nData Timeout Error.\n0: Khz\n1: Mhz"
          },
          {
            "name": "RESERVED",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TIMEOUTCLOCKFREQUENCY",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "This bit shows the base clock frequency used to detect Data\nTimeout Error.\nNot 0: 1Khz to 63Khz or 1Mhz to 63Mhz\n0: Get Information viaanother method"
          }
        ],
        "description": "Capabilities register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_FEACMD",
        "offset": "0x0050",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CMDERR",
            "bit_range": "7",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for command not issued by Auto CMD12 Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "RESERVED",
            "bit_range": "6:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INDEXERR",
            "bit_range": "4",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD Index Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "ENDERR",
            "bit_range": "3",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD End bit Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CRCERR",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD CRC Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "TIMEOUTERR",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD timeout Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "NOTEXE",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD12 NOT Executed\n1: Interrupt is generated\n0: No interrupt"
          }
        ],
        "description": "Force event register for Auto CMD error status"
      },
      {
        "type": "register",
        "name": "EMMCCORE_FEERRINT",
        "offset": "0x0052",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "VENDORERR",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "Force Event for Vendor Specific Error Status"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADMAERR",
            "bit_range": "9",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for ADMA Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "ACMDERR",
            "bit_range": "8",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Auto CMD Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CURRENTERR",
            "bit_range": "7",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Current Limit Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "DATENDBITERR",
            "bit_range": "6",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Data End Bit Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "DATCRCERR",
            "bit_range": "5",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Data CRC Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "DATTIMEOUTERR",
            "bit_range": "4",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Data Timeout Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CMDINDEXERR",
            "bit_range": "3",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Command Index Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CMDENDBITERR",
            "bit_range": "2",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Command End Bit Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CMDCRCERR",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Command CRC Error\n1: Interrupt is generated\n0: No interrupt"
          },
          {
            "name": "CMDTIMEOUTERR",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "Force Event for Command Timeout Error\n1: Interrupt is generated\n0: No interrupt"
          }
        ],
        "description": "Force event register for error interrupt status"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ADMAERRSTS",
        "offset": "0x0054",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LENMISMATCH",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "ADMA Length Mismatch Error.\nWhile Block Count Enable being set, the total data length\nspecified by the Descriptor table is different from that specified\nby the Block Count and Block Length. Total data length can not\nbe divided by the block length.\n1: Error\n0: No error"
          },
          {
            "name": "ADMAERRORSTATE",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "This field indicates the state of ADMA when error is occurred\nduring ADMA data transfer. This field never indicates \"10\"\nbecause ADMA never stops in this state.\n0: ST_STOP (Stop DMA) Points to next of the error descriptor\n1: ST_FDS (Fetch Descriptor) Points to the error descriptor\n2: Never set this state (Not used)\n3: ST_TFR (Transfer Data) Points to the next of the error\ndescriptor"
          }
        ],
        "description": "ADMA error status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_ADMAADDR",
        "offset": "0x0058",
        "size": "DW",
        "reset": "0x00000000\n00000000",
        "bit_ranges": [
          {
            "name": "ADDRH32",
            "bit_range": "63:32",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "ADMA System Address [63:32]."
          },
          {
            "name": "ADDRL32",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "ADMA System Address [31:0].\nThis register holds byte address of executing command of the\nDescriptor table. 32-bit Address Descriptor uses lower 32-bit of\nthis register. At the start of ADMA, the Host Driver shall set start\naddress of the Descriptor table. The ADMA increments this\nregister address, which points to next line, when every fetching a\nDescriptor line. When the ADMA Error Interrupt is generated, this\nregister shall hold valid Descriptor address depending on the\nADMA state. The Host Driver shall program Descriptor Table on\n32-bit boundary and set 32-bit boundary address to this register.\nADMA2 ignores lower 2-bit of this register and assumes it to be 0."
          }
        ],
        "description": "ADMA system address register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALINIT",
        "offset": "0x0060",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for Initialization"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALDS",
        "offset": "0x0062",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for Default Speed"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALHS",
        "offset": "0x0064",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for High Speed"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALSDR12",
        "offset": "0x0066",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for SDR12"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALSDR25",
        "offset": "0x0068",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for SDR25"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALSDR50",
        "offset": "0x006a",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for SDR50"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALSDR104",
        "offset": "0x006c",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for SDR104"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALDDR50",
        "offset": "0x006e",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for DDR50"
      },
      {
        "type": "register",
        "name": "EMMCCORE_BOOTTIMEOUT",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "BOOTTIMEOUT",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Boot Data Timeout Counter Value\nThis value determines the interval by which DAT line time-outs\nare detected during boot operation for eMMC card.\nThe value is in number of sd clock."
          }
        ],
        "description": "Boot timeout control register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_PVALHS400",
        "offset": "0x0074",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "DRIVERSTRENGTHSELECTVALUE",
            "bit_range": "15:14",
            "attr": "RO",
            "reset": "0x0",
            "description": "Driver Strength is supported by 1.8V signaling bus speed modes.\nThis field is meaningless for 3.3V signaling.\n2'b11: Driver Type D is Selected\n2'b10: Driver Type C is Selected\n2'b01: Driver Type A is Selected\n2'b00: Driver Type B is Selected"
          },
          {
            "name": "RESERVED",
            "bit_range": "13:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLOCKGENERATORSELECTVALUE",
            "bit_range": "10",
            "attr": "RO",
            "reset": "0x0",
            "description": "This bit is effective when Host Controller supports programmable\nclockgenerator.\n1: Programmable Clock Generator\n0: Host Controller Ver2.00 Compatible Clock Generator"
          },
          {
            "name": "SDCLKFREQUENCYSELECTVALUE",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "10-bit preset value to set SDCLK Frequency Select in the Clock\nControl Register is described by a host system."
          }
        ],
        "description": "Preset value register for HS400"
      },
      {
        "type": "register",
        "name": "EMMCCORE_VENDOR",
        "offset": "0x0078",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ENHANCEDSTROBE",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit enables the enhanced strobe logic of the Host Controller"
          }
        ],
        "description": "Vendor register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_SLOTINTSTS",
        "offset": "0x00fc",
        "size": "HW",
        "reset": "0x0000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "15:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INTSLOT0",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "This status bit indicates the OR of Interrupt signal and Wakeup\nsignal for slot"
          }
        ],
        "description": "Slot interrupt status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_VERSION",
        "offset": "0x00fe",
        "size": "HW",
        "reset": "0x1002",
        "bit_ranges": [
          {
            "name": "VENDORVERSION",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x10",
            "description": "The Vendor Version Number is set to 0x10 (1.0)"
          },
          {
            "name": "SPECIFICATIONVERSION",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x02",
            "description": "The Host Controller Version Number is set to 0x02 (SD Host\nSpecification Version 3.00)."
          }
        ],
        "description": "Host controller version register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQVER",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000510",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MAJOR",
            "bit_range": "11:8",
            "attr": "RO",
            "reset": "0x5",
            "description": "eMMC Major Version Number (digit left of decimal point), in BCD\nformat"
          },
          {
            "name": "MINOR",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x1",
            "description": "eMMC Minor Version Number(digit right of decimal point), in BCD\nformat"
          },
          {
            "name": "SUFFIX",
            "bit_range": "3:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "eMMC Version Suffix (2nd digit right of decimal point), in BCD\nformat"
          }
        ],
        "description": "Command queueing version register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCAP",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ITCFMUL",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "nternal Timer Clock Frequency Multiplier\nITCFMUL and ITCFVAL indicate the frequency of the clock used\nfor interrupt coalescing timer and for determining the SQS polling\nperiod. See ITCFVAL definition for details.\n4'h0: 0.001 MHz\n4'h1: 0.01 MHz\n4'h2: 0.1 MHz\n4'h3: 1 MHz\n4'h4: 10 MHz\nOther values are reserved"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ITCFVAL",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "Internal Timer Clock Frequency Value\nTCFMUL and ITCFVAL indicate the frequency of the clock used for\ninterrupt coalescing timer and for determining the polling period\nwhen using periodic SEND_QUEUE_ STATUS (CMD13) polling.\nThe clock frequency is calculated as ITCFVAL* ITCFMUL.\nFor example, to encode 19.2 MHz, ITCFVAL shall be C0h (= 192\ndecimal) and ITCFMUL shall be 2h (0.1 MHz)\n192 * 0.1 MHz=19.2 MHz"
          }
        ],
        "description": "Command queueing capabilities register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCFG",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DCMDENA",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x0",
            "description": "Direct Command (DCMD) Enable\nThis bit indicates to the hardware whether the Task Descriptor in\nslot #31 of the TDL is a Data Transfer Task Descriptor, or a\nDirect Command Task Descriptor.\nCQE uses this bit when a task is issued in slot #31, to determine\nhow to decode the Task Descriptor.\n1: Task descriptor in slot #31 is a DCMD Task Descriptor\n0: Task descriptor in slot #31 is a Data Transfer Task Descriptor"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TASKDESCRIPTORSIZE",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "This bit indicates whether the task descriptor size is 128 bits or\n64 bits as detailed in Data Structures section. This bit can only be\nconfigured when Command Queueing Enable bit is 0 (command\nqueueing is disabled)\n1: Task descriptor size is 128 bits\n0: Task descriptor size is 64 bits"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CQENA",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Command Queueing Enable\nSoftware shall write 1 this bit when in order to enable command\nqueueing mode (i.e. enable CQE).\nWhen this bit is 0, CQE is disabled and software controls the\neMMC bus using the legacy eMMC host controller.\nBefore software writes 1 to this bit, software shall verify that the\neMMC host controller is in idle state and there are no commands\nor data transfers ongoing.\nWhen software wants to exit command queueing mode, it shall\nclear all previous tasks if such exist before setting this bit to 0."
          }
        ],
        "description": "Command queueing configuration register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCTRL",
        "offset": "0x020c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLEARALLTASKS",
            "bit_range": "8",
            "attr": "R/WSC",
            "reset": "0x0",
            "description": "Software shall write 1 this bit when it wants to clear all the tasks\nsent to the device.\nThis bit can only be written when CQE is in halt state (i.e. Halt bit\nis 1).\nWhen software writes 1, the value of the register is updated to 1,\nand CQE shall reset CQTDBR register and all other context\ninformation for all unfinished tasks.\nThen CQE will clear this bit.\nSoftware should poll on this bit until it is set to back 0 and may\nthen resume normal operation, by clearing the Halt bit.\nCQE does not communicate to the device that the tasks were\ncleared. It is software's responsibility to order the device to\ndiscard the tasks in its queue using CMDQ_TASK_MGMT\ncommand.\nWriting 0 to this register shall have no effect."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HALT",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Host software shall write 1 to the bit when it wants to acquire\nsoftware control over the eMMC bus and disable CQE from issuing\ncommands on the bus.\nFor example, issuing a Discard Task command\n(CMDQ_TASK_MGMT).\nWhen software writes 1, CQE shall complete the ongoing task if\nsuch a task is in progress.\nOnce the task is completed and CQE is in idle state, CQE shall not\nissue new commands and shall indicate so to software by setting\nthis bit to 1.\nSoftware may poll on this bit until it is set to 1, and may only\nthen send commands on the eMMC bus.\nIn order to exit halt state (i.e. resume CQE activity), software\nshall clear this bit (write 0). Writing 0 when the value is already 0\nshall have no effect."
          }
        ],
        "description": "Command queueing control register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQINTSTS",
        "offset": "0x0210",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TERR",
            "bit_range": "4",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Task Error Interrupt\nThis bit is asserted when task error is detected due to invalid task\ndescriptor"
          },
          {
            "name": "TCL",
            "bit_range": "3",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Task Cleared\nThis status bit is asserted (if CQISTE.TCL=1) when a task clear\noperation is completed by CQE. The completed task clear\noperation is either an individual task clear (CQTCLR) or clearing\nof all tasks (CQCTL)."
          },
          {
            "name": "RED",
            "bit_range": "2",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Response Error Detected Interrupt\nThis status bit is asserted (if CQISTE.RED=1) when a response is\nreceived with an error bit set in the device status field.\nSoftware uses CQRMEM register to configure which device status\nbit fields may trigger an interrupt, and which are masked."
          },
          {
            "name": "TCC",
            "bit_range": "1",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Task Complete Interrupt\nThis status bit is asserted(if CQISTE.TCC=1) when at least one of\nthe following two conditions are met:\na. A task is completed and the INT bit is set in its Task Descriptor\nb. Interrupt caused by Interrupt Coalescing logic"
          },
          {
            "name": "HAC",
            "bit_range": "0",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Halt Complete Interrupt\nThis status bit is asserted (if CQISTE.HAC=1) when halt bit in\nCQCTL register transitions from 0 to 1 indicating that host\ncontroller has completed its current ongoing task and has entered\nhalt state."
          }
        ],
        "description": "Command queueing interrupt status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQINTSTSENA",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TERR",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Error Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "TCL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Cleared\n1: enable\n0: disable"
          },
          {
            "name": "RED",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Response Error Detected Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "TCC",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Complete Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "HAC",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Halt Complete Interrupt\n1: enable\n0: disable"
          }
        ],
        "description": "Command queueing interrupt status enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQINTSIGENA",
        "offset": "0x0218",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TERR",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Error Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "TCL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Cleared\n1: enable\n0: disable"
          },
          {
            "name": "RED",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Response Error Detected Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "TCC",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Task Complete Interrupt\n1: enable\n0: disable"
          },
          {
            "name": "HAC",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Halt Complete Interrupt\n1: enable\n0: disable"
          }
        ],
        "description": "Command queueing interrupt signal enable register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQINTCOAL",
        "offset": "0x021c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "INTCOALENA",
            "bit_range": "31",
            "attr": "RW",
            "reset": "0x0",
            "description": "Interrupt Coalescing Enable/Disable:\nWhen set to 0 by software, command responses are neither\ncounted nor timed. Interrupts are still triggered by completion of\ntasks with INT=1 in the Task Descriptor.\nWhen set to 1, the interrupt coalescing mechanism is enabled\nand coalesced interrupts are generated."
          },
          {
            "name": "RESERVED",
            "bit_range": "30:21",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ICSB",
            "bit_range": "20",
            "attr": "RO",
            "reset": "0x0",
            "description": "Interrupt Coalescing Status Bit :\nThis bit indicates to software whether any tasks (with INT=0)\nhave completed and counted towards interrupt coalescing (i.e.,\nICSB is set ifand only if IC counter > 0).\n1: At least one task completion has been counted (IC counter >0)\n0: No task completions have occurred since last counter reset (IC\ncounter =0)"
          },
          {
            "name": "RESERVED",
            "bit_range": "19:17",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RESET",
            "bit_range": "16",
            "attr": "WO",
            "reset": "0x0",
            "description": "Counter and Timer Reset(ICCTR):\nWhen host driver writes 1, the interrupt coalescing timer and\ncounter are reset"
          },
          {
            "name": "ICCTHWEN",
            "bit_range": "15",
            "attr": "WO",
            "reset": "0x0",
            "description": "Interrupt Coalescing Counter Threshold Write Enable:\nWhen software writes 1, the value ICCTH is updated with the\ncontents written at the same cycle.\nWhen software writes 0, the value in ICCTH is not updated.\nNOTE: Write operations to ICCTH are only allowed when the task\nqueue is empty."
          },
          {
            "name": "RESERVED",
            "bit_range": "14:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ICCTH",
            "bit_range": "12:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Interrupt Coalescing Counter Threshold (ICCTH):\nSoftware uses this field to configure the number of task\ncompletions (only tasks withINT=0 in the Task Descriptor) which\nare required in order to generate an interrupt.\nCounter Operation: As data transfer tasks with INT=0 complete,\nthey are counted byCQE. The counter is reset by software during\nthe interrupt service routine.\nThe counter stops counting when it reaches the value configured\nin ICCTH.\nThe maximum allowed value is 31\nNOTE : When ICCTH is 0, task completions are not counted, and\ncounting-based interrupts are not generated.\nIn order to write to this field, the ICCTHWEN bit must be set at\nthe same write operation."
          },
          {
            "name": "ICTOVALWEN",
            "bit_range": "7",
            "attr": "WO",
            "reset": "0x0",
            "description": "Interrupt Coalescing Timeout Value Write Enable:\nWhen software writes 1, the value ICTOVAL is updated with the\ncontents written at the same cycle.\nWhen software writes 0, the value in ICTOVAL is not updated.\nNOTE: Write operations to ICTOVAL are only allowed when the\ntask queue is empty."
          },
          {
            "name": "ICTOVAL",
            "bit_range": "6:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Interrupt Coalescing Timeout Value (ICTOVAL):\nSoftware uses this field to configure the maximum time allowed\nbetween the completion of a task on the bus and the generation\nof an interrupt.\nTimer Operation: The timer is reset by software during the\ninterrupt service routine.\nIt starts running when a data transfer task with INT=0 is\ncompleted, after the timer was reset. When the timer reaches the\nvalue configured in ICTOVAL field it generates an interrupt and\nstops.\nThe timer's unit is equal to 1024 clock periods of the clock whose\nfrequency is specified in the Internal Timer Clock Frequency field\nCQCAP register.\nThe minimum value is 01h (1024 clock periods) and the\nmaximum value is 7Fh (127*1024 clock periods).\nFor example, a CQCAP field value of 0 indicates a 19.2 MHz clock\nfrequency (period = 52.08 ns). If the setting in ICTOVAL is 10h,\nthe calculated polling period is 16*1024*52.08 ns= 853.33 us.\nNOTE:When ICTOVAL is 0, the timer is not running, and timer-\nbased interrupts are not generated.In order to write to this field,\nthe ICTOVALWEN bit must be set at the same write operation."
          }
        ],
        "description": "Command queueing interrupt coalescing register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTDLBA",
        "offset": "0x0220",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TDLBA",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Task Descriptor List Base Address\nThis register stores the LSB bits (bits 31:0) of the byte address of\nthe head of the Task Descriptor List in system memory.\nThe size of the task descriptor list is 32 * (Task Descriptor size +\nTransfer Descriptor size) as configured by Host driver.\nThis address shall be set on Byte1 KByte boundary. The lower 10\nbits of this register shall be set to 0 by software and shall be\nignored by CQE."
          }
        ],
        "description": "Command queueing task descriptor list base address register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTDLBAU",
        "offset": "0x0224",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TDLBA",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Task Descriptor List Base Address\nThis register stores the MSB bits (bits 63:32) of the byte address\nof the head of the Task Descriptor List in system memory.\nThe size of the task descriptor list is 32 * (Task Descriptor size +\nTransfer Descriptor size) as configured by Host driver.\nThis register is reserved when using 32-bit addressing mode."
          }
        ],
        "description": "Command queueing task descriptor list base address upper 32bits register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTDB",
        "offset": "0x0228",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TASKDOORBELL",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Command Queueing Task Doorbell\nSoftware shall configure TDLBA and TDLBAU, and enable CQE in\nCQCFG before using this register.\nWriting 1 to bit n of this register triggers CQE to start processing\nthe task encoded in slot n of the TDL.\nCQE always processes tasks in-order according to the order\nsubmitted to the list by CQTDBR write transactions.\nCQE processes Data Transfer tasks by reading the Task\nDescriptor and sending QUEUED_TASK_PARAMS (CMD44) and\nQUEUED_TASK_ADDRESS (CMD45) commands to the device.\nCQE processes DCMD tasks (in slot #31, when enabled) by\nreading the Task Descriptor, and generating the command\nencoded by its index and argument.\nThe corresponding bit is cleared to 0 by CQE in one of the\nfollowing events:\na. When a task execution is completed (with success or error)\nb. The task is cleared using CQTCLR register\nc. All tasks are cleared using CQCTL register\nd. CQE is disabled using CQCFG register\nSoftware may initiate multiple tasks at the same time (batch\nsubmission) by writing 1 to multiple bits of this register in the\nsame transaction.\nIn the case of batch submission:\nCQE shall process the tasks in order of the task index, starting\nwith the lowest index.\nIf one or more tasks in the batch are marked with QBR, the\nordering of execution will be based on said processing order.\nWriting 0 by software shall have no impact on the hardware, and\nwill not change the value of the register bit."
          }
        ],
        "description": "Command queueing task doorbell register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTDBN",
        "offset": "0x022c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "TCN",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Task Complete Notification\nCQE shall set bit n of this register (at the same time it clears bit n\nof CQTDBR) when a task execution is completed (with success or\nerror).\nWhen receiving interrupt for task completion, software may read\nthis register to know which tasks have finished.\nAfter reading this register, software may clear the relevant bit\nfields by writing 1 to the corresponding bits."
          }
        ],
        "description": "Command queueing task doorbell notification register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQDQSTS",
        "offset": "0x0230",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DQS",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Device Queue Status\nEvery time the Host controller receives a queue status register\n(QSR) from the device, it updates this register with the response\nof status command, i.e. the device's queue status."
          }
        ],
        "description": "Command queueing device queue status register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQDPT",
        "offset": "0x0234",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DPT",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Device Pending Tasks\nBit n of this register is set if and only if QUEUED_TASK_PARAMS\n(CMD44) and QUEUED_TASK_ADDRESS (CMD45) were sent for\nthis specific task and if this task hasn\u2019t been executed yet.\nCQE shall set this bit after receiving a successful response for\nCMD45. CQE shall clear this bit after the task has completed\nexecution.\nSoftware needs to read this register in the task-discard\nprocedure, when the controlleris halted, to determine if the task\nis queued in the device. If the task is queued, the driver sends a\nCMDQ_TASK_MGMT (CMD48) to the device ordering it to discard\nthe task. Then software clears the task in the CQE. Only then the\nsoftware orders CQE to resume its operation using CQCTL\nregister."
          }
        ],
        "description": "Command queueing device pending tasks register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTCLR",
        "offset": "0x0238",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "CQTC",
            "bit_range": "31:0",
            "attr": "RW",
            "reset": "0x00000000",
            "description": "Command Queueing Task Clear\nWriting 1 to bit n of this register orders CQE to clear a task which\nsoftware has previously issued.\nThis bit can only be written when CQE is in Halt state as indicated\nin CQCFG register Halt bit.\nWhen software writes 1 to a bit in this register, CQE updates the\nvalue to 1, and starts clearing the data structures related to the\ntask. CQE clears the bit fields (sets a value of 0) in CQTCLR and\nin CQTDBR once clear operation is complete.\nSoftware should poll on the CQTCLR until it is cleared to verify\nclear operation was complete.\nWriting to this register only clears the task in the CQE and does\nnot have impact on the device. In order to discard the task in the\ndevice, host softwareshall send CMDQ_TASK _MGMT while CQE is\nstill in Halt state.\nHost driver is not allowed to use this register to clear multiple\ntasks at the same time. Clearing multiple tasks can be done using\nCQCTL register.\nWriting 0 to a register bit shall have no impact."
          }
        ],
        "description": "Command queueing task clear register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQSSC1",
        "offset": "0x0240",
        "size": "W",
        "reset": "0x00011000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:20",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SSCBC",
            "bit_range": "19:16",
            "attr": "RW",
            "reset": "0x1",
            "description": "Send Status Command Block Counter\nThis field indicates to CQE when to send SEND_QUEUE_STATUS\n(CMD13) command to inquire the status of the device's task\nqueue.\nA value of n means CQE shall send status command on the CMD\nline, during the transfer of data block BLOCK_CNT-n, on the data\nlines, where BLOCK_CNT is the number of blocks inthe current\ntransaction.\nA value of 0 means that SEND_QUEUE_STATUS (CMD13)\ncommand shall not be sent during the transaction. Instead it will\nbe sentonly when the data lines are idle.\nA value of 1 means that STATUS command is to be sent during\nthe last block of the transaction."
          },
          {
            "name": "SSCIT",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x1000",
            "description": "Send Status Command Idle Timer\nThis field indicates to CQE the polling period to use when using\nperiodic SEND_QUEUE_STATUS (CMD13) polling.\nPeriodic polling is used when tasks are pending in the device, but\nno data transfer is in progress. When a SEND_QUEUE_STATUS\nresponse indicating that no task is ready for execution, CQE\ncounts the configured time until it issues the next\nSEND_QUEUE_STATUS.\nTimer units are clock periods of the clock whose frequency is\nspecified in the Internal Timer Clock Frequency field CQCAP\negister.\nThe minimum value is 0001h (1 clock period) and the maximum\nvalue is FFFFh (65535 clock periods). Default interval is: 4096\nclock periods.\nFor example, a CQCAP field value of 0 indicates a 19.2 MHz clock\nfrequency (period = 52.08 ns). If the setting in CQSST is 1000h,\nthe calculated polling period is 4096*52.08 ns= 213.33 us."
          }
        ],
        "description": "Command queueing send status configuration register 1"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQSSC2",
        "offset": "0x0244",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SQRCA",
            "bit_range": "15:0",
            "attr": "RW",
            "reset": "0x0000",
            "description": "Send Queue RCA\nThis field provides CQE with the contents of the 16-bit RCA field\nin SEND_QUEUE_ STATUS (CMD13) command. argument.\nCQE shall copy this field to bits 31:16 of the argument when\ntransmitting SEND_ QUEUE_STATUS (CMD13) command"
          }
        ],
        "description": "Command queueing send status configuration register 2"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCRDT",
        "offset": "0x0248",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DCLR",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Direct Command Last Response\nThis register contains the response of the command generated by\nthe last direct-command (DCMD) task which was sent.\nCQE shall update this register when it receives the response for a\nDCMD task.\nThis register is considered valid only after bit 31 of CQTDBR\nregister is cleared by CQE."
          }
        ],
        "description": "Command queueing command response for direct-command task register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQRMEM",
        "offset": "0x0250",
        "size": "W",
        "reset": "0xfdf9a080",
        "bit_ranges": [
          {
            "name": "RMEM",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0xfdf9a080",
            "description": "Response Mode Error Mask\nThis bit is used as in interrupt mask on the device status filed\nwhich is received in R1/R1b responses.\nBit Value Description (for any bit i):\n1: When a R1/R1b response is received, with bit i in the device\nstatus set, a RED interrupt is generated\n0: When a R1/R1b response is received, bit i in the device status\nis ignored\nThe reset value of this register is set to trigger an interrupt on all\n'Error' type bits in the device status.\nNOTE: Responses to CMD13 (SQS) encode the QSR, so they are\nignored by this logic."
          }
        ],
        "description": "Command queueing response mode error mask register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQTEI",
        "offset": "0x0254",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DTECI",
            "bit_range": "21:16",
            "attr": "RO",
            "reset": "0x00",
            "description": "Data Transfer Error Command Index\nThis field indicates the index of the command which was executed\non the data lines when an error occurred.\nThe index shall be set to EXECUTE_READ_TASK (CMD46) or\nEXECUTE_WRITE_TASK (CMD47) according to the data direction.\nThe field is updated if a data transfer is in progress when an error\nis detected by CQE, or indicated by eMMC controller."
          },
          {
            "name": "RMEFV",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "Response Mode Error Fields Valid\nThis bit is updated when an error is detected by CQE, or indicated\nby eMMC controller.\nIf a command transaction is in progress when the error is\ndetected/indicated, the bit is set to 1.\nIf a no command transaction is in progress when the error is\ndetected/indicated, the bit is cleared to 0."
          },
          {
            "name": "RESERVED",
            "bit_range": "14:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RMETID",
            "bit_range": "12:8",
            "attr": "RO",
            "reset": "0x00",
            "description": "Response Mode Error Task ID\nThis field indicates the ID of the task which was executed on the\ncommand line when an error occurred.\nThe field is updated if a command transaction is in progress when\nan error is detected by CQE, or indicated by eMMC controller."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RMECI",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Response Mode Error Command Index\nThis field indicates the index of the command which was executed\non the command line when an error occurred.\nThe field is updated if a command transaction is in progress when\nan error is detected by CQE, or indicated by eMMC controller."
          }
        ],
        "description": "Command queueing task error information register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCRI",
        "offset": "0x0258",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LCRI",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Last Command Response Index\nThis field stores the index of the last received command\nresponse. CQE shall update the value every time a command\nresponse is received."
          }
        ],
        "description": "Command queueing command response index register"
      },
      {
        "type": "register",
        "name": "EMMCCORE_CQCRA",
        "offset": "0x025c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "LCRA",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Last Command Response Argument\nThis field stores the argument of the last received command. CQE\nshall update the value every time a command response is\nreceived."
          }
        ],
        "description": "Command queueing command response argument register"
      }
    ],
    "name": "EMMCCORE",
    "summary": [
      {
        "name": "EMMCCORE_SADDR",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "System address/ Argument 2 register"
      },
      {
        "name": "EMMCCORE_BLKSIZ",
        "offset": "0x0004",
        "size": "HW",
        "reset": "0x0000",
        "description": "Block size register"
      },
      {
        "name": "EMMCCORE_BLKCNT",
        "offset": "0x0006",
        "size": "HW",
        "reset": "0x0000",
        "description": "Block count register"
      },
      {
        "name": "EMMCCORE_ARG",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "Argument register"
      },
      {
        "name": "EMMCCORE_TRANSMOD",
        "offset": "0x000c",
        "size": "HW",
        "reset": "0x0000",
        "description": "Transfer mode register"
      },
      {
        "name": "EMMCCORE_CMD",
        "offset": "0x000e",
        "size": "HW",
        "reset": "0x0000",
        "description": "Command register"
      },
      {
        "name": "EMMCCORE_RESP0",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response register bit [31:0]"
      },
      {
        "name": "EMMCCORE_RESP1",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response register bit [63:32]"
      },
      {
        "name": "EMMCCORE_RESP2",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response register bit [95:64]"
      },
      {
        "name": "EMMCCORE_RESP3",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Response register bit [127:98]"
      },
      {
        "name": "EMMCCORE_BUFFER",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x00000000",
        "description": "Buffer data port register"
      },
      {
        "name": "EMMCCORE_PRESTS",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x1fff0000",
        "description": "Present state register"
      },
      {
        "name": "EMMCCORE_HOSTCTRL1",
        "offset": "0x0028",
        "size": "B",
        "reset": "0x00",
        "description": "Host control 1 register"
      },
      {
        "name": "EMMCCORE_PWRCTRL",
        "offset": "0x0029",
        "size": "B",
        "reset": "0x00",
        "description": "Power control register"
      },
      {
        "name": "EMMCCORE_BLKGAPCTRL",
        "offset": "0x002a",
        "size": "B",
        "reset": "0x00",
        "description": "Block gap control register"
      },
      {
        "name": "EMMCCORE_CLKCTRL",
        "offset": "0x002c",
        "size": "HW",
        "reset": "0x0000",
        "description": "Clock control Register"
      },
      {
        "name": "EMMCCORE_TIMEOUT",
        "offset": "0x002e",
        "size": "B",
        "reset": "0x00",
        "description": "Timeout control register"
      },
      {
        "name": "EMMCCORE_SWRST",
        "offset": "0x002f",
        "size": "B",
        "reset": "0x00",
        "description": "Software reset register"
      },
      {
        "name": "EMMCCORE_NORINTSTS",
        "offset": "0x0030",
        "size": "HW",
        "reset": "0x0000",
        "description": "Normal interrupt status register"
      },
      {
        "name": "EMMCCORE_ERRINTSTS",
        "offset": "0x0032",
        "size": "HW",
        "reset": "0x0000",
        "description": "Error interrupt status register"
      },
      {
        "name": "EMMCCORE_NORINTSTSENA",
        "offset": "0x0034",
        "size": "HW",
        "reset": "0x0000",
        "description": "Normal interrupt status enable register"
      },
      {
        "name": "EMMCCORE_ERRINTSTSENA",
        "offset": "0x0036",
        "size": "HW",
        "reset": "0x0000",
        "description": "Error interrupt status enable register"
      },
      {
        "name": "EMMCCORE_NORINTSIGENA",
        "offset": "0x0038",
        "size": "HW",
        "reset": "0x0000",
        "description": "Normal interrupt signal enable register"
      },
      {
        "name": "EMMCCORE_ERRINTSIGENA",
        "offset": "0x003a",
        "size": "HW",
        "reset": "0x0000",
        "description": "Error interrupt signal enable register"
      },
      {
        "name": "EMMCCORE_ACMDERRSTS",
        "offset": "0x003c",
        "size": "HW",
        "reset": "0x0000",
        "description": "Auto CMD error status register"
      },
      {
        "name": "EMMCCORE_HOSTCTRL2",
        "offset": "0x003e",
        "size": "HW",
        "reset": "0x0000",
        "description": "Host Control 2 Register"
      },
      {
        "name": "EMMCCORE_CAP",
        "offset": "0x0040",
        "size": "DW",
        "reset": "0x80002007\n44ed0000",
        "description": "Capabilities register"
      },
      {
        "name": "EMMCCORE_FEACMD",
        "offset": "0x0050",
        "size": "HW",
        "reset": "0x0000",
        "description": "Force event register for Auto CMD error status"
      },
      {
        "name": "EMMCCORE_FEERRINT",
        "offset": "0x0052",
        "size": "HW",
        "reset": "0x0000",
        "description": "Force event register for error interrupt status"
      },
      {
        "name": "EMMCCORE_ADMAERRSTS",
        "offset": "0x0054",
        "size": "HW",
        "reset": "0x0000",
        "description": "ADMA error status register"
      },
      {
        "name": "EMMCCORE_ADMAADDR",
        "offset": "0x0058",
        "size": "DW",
        "reset": "0x00000000\n00000000",
        "description": "ADMA system address register"
      },
      {
        "name": "EMMCCORE_PVALINIT",
        "offset": "0x0060",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for Initialization"
      },
      {
        "name": "EMMCCORE_PVALDS",
        "offset": "0x0062",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for Default Speed"
      },
      {
        "name": "EMMCCORE_PVALHS",
        "offset": "0x0064",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for High Speed"
      },
      {
        "name": "EMMCCORE_PVALSDR12",
        "offset": "0x0066",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for SDR12"
      },
      {
        "name": "EMMCCORE_PVALSDR25",
        "offset": "0x0068",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for SDR25"
      },
      {
        "name": "EMMCCORE_PVALSDR50",
        "offset": "0x006a",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for SDR50"
      },
      {
        "name": "EMMCCORE_PVALSDR104",
        "offset": "0x006c",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for SDR104"
      },
      {
        "name": "EMMCCORE_PVALDDR50",
        "offset": "0x006e",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for DDR50"
      },
      {
        "name": "EMMCCORE_BOOTTIMEOUT",
        "offset": "0x0070",
        "size": "W",
        "reset": "0x00000000",
        "description": "Boot timeout control register"
      },
      {
        "name": "EMMCCORE_PVALHS400",
        "offset": "0x0074",
        "size": "HW",
        "reset": "0x0000",
        "description": "Preset value register for HS400"
      },
      {
        "name": "EMMCCORE_VENDOR",
        "offset": "0x0078",
        "size": "HW",
        "reset": "0x0000",
        "description": "Vendor register"
      },
      {
        "name": "EMMCCORE_SLOTINTSTS",
        "offset": "0x00fc",
        "size": "HW",
        "reset": "0x0000",
        "description": "Slot interrupt status register"
      },
      {
        "name": "EMMCCORE_VERSION",
        "offset": "0x00fe",
        "size": "HW",
        "reset": "0x1002",
        "description": "Host controller version register"
      },
      {
        "name": "EMMCCORE_CQVER",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000510",
        "description": "Command queueing version register"
      },
      {
        "name": "EMMCCORE_CQCAP",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing capabilities register"
      },
      {
        "name": "EMMCCORE_CQCFG",
        "offset": "0x0208",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing configuration register"
      },
      {
        "name": "EMMCCORE_CQCTRL",
        "offset": "0x020c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing control register"
      },
      {
        "name": "EMMCCORE_CQINTSTS",
        "offset": "0x0210",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing interrupt status register"
      },
      {
        "name": "EMMCCORE_CQINTSTSENA",
        "offset": "0x0214",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing interrupt status enable register"
      },
      {
        "name": "EMMCCORE_CQINTSIGENA",
        "offset": "0x0218",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing interrupt signal enable register"
      },
      {
        "name": "EMMCCORE_CQINTCOAL",
        "offset": "0x021c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing interrupt coalescing register"
      },
      {
        "name": "EMMCCORE_CQTDLBA",
        "offset": "0x0220",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task descriptor list base address register"
      },
      {
        "name": "EMMCCORE_CQTDLBAU",
        "offset": "0x0224",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task descriptor list base address upper 32bits register"
      },
      {
        "name": "EMMCCORE_CQTDB",
        "offset": "0x0228",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task doorbell register"
      },
      {
        "name": "EMMCCORE_CQTDBN",
        "offset": "0x022c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task doorbell notification register"
      },
      {
        "name": "EMMCCORE_CQDQSTS",
        "offset": "0x0230",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing device queue status register"
      },
      {
        "name": "EMMCCORE_CQDPT",
        "offset": "0x0234",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing device pending tasks register"
      },
      {
        "name": "EMMCCORE_CQTCLR",
        "offset": "0x0238",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task clear register"
      },
      {
        "name": "EMMCCORE_CQSSC1",
        "offset": "0x0240",
        "size": "W",
        "reset": "0x00011000",
        "description": "Command queueing send status configuration register 1"
      },
      {
        "name": "EMMCCORE_CQSSC2",
        "offset": "0x0244",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing send status configuration register 2"
      },
      {
        "name": "EMMCCORE_CQCRDT",
        "offset": "0x0248",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing command response for direct-command task register"
      },
      {
        "name": "EMMCCORE_CQRMEM",
        "offset": "0x0250",
        "size": "W",
        "reset": "0xfdf9a080",
        "description": "Command queueing response mode error mask register"
      },
      {
        "name": "EMMCCORE_CQTEI",
        "offset": "0x0254",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing task error information register"
      },
      {
        "name": "EMMCCORE_CQCRI",
        "offset": "0x0258",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing command response index register"
      },
      {
        "name": "EMMCCORE_CQCRA",
        "offset": "0x025c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Command queueing command response argument register"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "PCIE_CLIENT_BASIC_STRAP_CONF",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x000000c1",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask bits\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PCIE_GEN_SEL",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x1",
            "description": "Generation support select\n1'b0: Gen1 mode\n1'b1: Gen2 mode\nThis strap input selects the generation of the PCI Express\nprotocol supported by the core. If Gen1 mode. The core\nadvertises only Gen1 capability in this mode, and will always\noperate at Gen1 speed. If Gen2 mode. The core advertises Gen1\nand Gen2 capabilities in this mode, but not Gen3. The link may\noperate at Gen1 or Gen2 speed."
          },
          {
            "name": "MODE_SELECT",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x1",
            "description": "Controller operation mode select\n1'b0: Endpoint operation\n1'b1: Root Port operation"
          },
          {
            "name": "LANE COUNT IN",
            "bit_range": "5:4",
            "attr": "RW",
            "reset": "0x2",
            "description": "configure the lane count supported\n2\u2019b11: reserved\n2\u2019b10: X4\n2\u2019b01: X2\n2\u2019b00: X1"
          },
          {
            "name": "ARI_EN",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "Alternate interpretation enable\n1'b0: legacy interpretation of the PCI Routing ID\n1'b1: alternate interpretation of the PCI Routing ID\nThis input is strapped to 0 for legacy interpretation of the PCI\nRouting ID (8-bit Bus + 5-bit Device + 3- bit Function). A 1 at\nthis input enables the alternate interpretation (8-bit Bus + 8-bit\nFunction)."
          },
          {
            "name": "SR_IOV_EN",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Single root I/O virtualization feature enable\n1'b0: disable SR-IOV feature\n1'b1: enable SR-IOV feature\nIn a core supporting the Single Root I/O Virtualization feature,\nthis strap input must be tied high to enable the SR-IOV feature.\nThe ari_en input must also be strapped high to enable the SR-\nIOV feature."
          },
          {
            "name": "LINK_TRAIN_EN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Link training enable\n1'b0: Quite state\n1'b1: enable link training\nThis input must be set to 1 to enable the LTSSM to bring up the\nlink. Setting it to 0 forces the LTSSM to stay in the Detect Quiet\nstate."
          },
          {
            "name": "CONF_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x1",
            "description": "Config enable\n1'b0: disable\n1'b1: enable\nWhen this input is set to 0 in the EP mode, the core will generate\na CRS Completion in response to Configuration Requests. In\nsystems where the core configuration registers are loaded from\nRAM on power-up, this prevents the core from responding to\nConfiguration Requests before all the registers are loaded. This\ninput can be strapped high when the power-on default values of\nthe Configuration Registers do not need to be modified before\nConfiguration Space enumeration."
          }
        ],
        "description": "Basic strap configuration register"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_POWER_CTRL",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask bits\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PWR_STCG_ACK_MODE",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Power state change ack mode select\n1'b0: select power state change ack source from bit\npwr_stcg_ack\n1'b1: select power state change ack source from constant, it\nalways keeps high."
          },
          {
            "name": "PWR_STCG_ACK",
            "bit_range": "8",
            "attr": "WO",
            "reset": "0x0",
            "description": "Power state change ack\n1'b0: keep 0\n1'b1: write 1 to generate one high pulse ack to controller\nThe client must assert this input to the core for one cycle in\nresponse to the assertion of power state change interrupt, when\nit is ready to transition to the low-power state requested by the\nconfiguration write request. The client may permanently maintain\nthis input high if it does not need to delay the return of the\ncompletions for the configuration write transactions causing\npower-state changes."
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HWCLR_EXIT_L1_REQ",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hardware clear exit L1 request\n1'b0: software polling and write clear mode\n1'b1: hardware polling and auto-clear mode"
          },
          {
            "name": "RESERVED",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "HWCLR_EXIT_L2_REQ",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x0",
            "description": "Hardware clear exit L2 request\n1'b0: software polling and write clear mode\n1'b1: hardware polling and auto-clear mode"
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CLT_REQ_EXIT_L1",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x0",
            "description": "Client request exit L1 power state\n1'b0: keep\n1'b1: request to exit the L1.1 or L1.2.Idle substate\nClient request to exit the L1.1 or L1.2.Idle substate. When the\ncore clock is turned off, the client must activate this input to\nrequest the L1 PM substate state machine to de-assert\nCLKREQ_OUT and transition the link out of L1. If the core clock is\nnot turned off in the L1.1 and L1.2 substates, this input can be\npermanently kept low."
          },
          {
            "name": "REQ_TRN_L23READY",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Request transition to L23_Ready state\n1'b0: keep\n1'b1: transition the power management state of the core to\nL23_READY\nWhen the core is configured as Endpoint, the client may assert\nthis input to transition the power management state of the core\nto L23_READY (see Chapter 5 of PCI Express Specifications for a\ndetailed description of power management). This is done after\nthe PCI Functions in the core have been placed in the D3 state\nand after the client has acknowledged the PME_Turn_Off\nmessage from the Root Port. Asserting this input causes the link\nto transition to the L2 state, and requires a power-on reset to\nresume operation. This input can be hardwired to 0 if the link is\nnot required to transition to L2.\nThis input is not used in the Root Port mode."
          },
          {
            "name": "CLT_REQ_EXIT_L2",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Client request exit L2 power state\n1'b0: keep\n1'b1: Exit from L2_IDLE\nThis input can be asserted by the client only in the short interval\nof time after the link enters L2 and before the system is powered\nOFF. While the power and clocks are still ON, the client can assert\nthis input to initiate an exit from L2_IDLE->DETECT."
          }
        ],
        "description": "PCIe client power control configuration"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_POWER_STATUS",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PWR_STCG_FC_NUM",
            "bit_range": "23:16",
            "attr": "RO",
            "reset": "0x00",
            "description": "Power state change function number\nFunction number of the function for which a power state change\noccurred."
          },
          {
            "name": "RESERVED",
            "bit_range": "15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "L1_PM_SUBST",
            "bit_range": "14:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "L1 power management substate\nThis output provides the current state of the L1 PM substates\nstate machine. This output is in the PM_CLK clock domain. Its\nencodings are:\n3'b000 = LTSSM not in L1 state\n3'b001 = L1.0 substate\n3'b010 = L1.1 substate\n3'b011 = Reserved\n3'b100 = L1.2.Entry substate\n3'b101 = L1.2.Idle substate\n3'b110 = L1.2.Exit substate\n3'b111 = Reserved"
          },
          {
            "name": "RESERVED",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FC_PWR_ST",
            "bit_range": "10:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "Function power state\nThese outputs provide the current power state of the Physical\nFunctions. Bits [2:0] capture the power state of Function 0 The\npossible power states are:\n3'b000: D0_uninitialized\n3'b001: D0_active\n3'b010: D1\n3'b100: D3_hot"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LINK_PWR_ST",
            "bit_range": "3:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Link power state\nCurrent power state of the PCIe link:\n4'b0001 = L0\n4'b0010 = L0s\n4'b0100 = L1\n4'b1000 = L2"
          }
        ],
        "description": "PCIe power management status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_LEGACY_INT_CTRL",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WRITE_MASK",
            "bit_range": "17:16",
            "attr": "WO",
            "reset": "0x0",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT_IN",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Legacy interrupt input\n1'b0: de-assert\n1'b1: assert\nWhen the core is configured as EP, this input is used by the client\napplication to signal an interrupt from any of its PCI Functions to\nthe RC using the Legacy PCI Express Interrupt Delivery\nmechanism of PCI Express. This input corresponds to INTA of the\nPCI bus. Asserting this signal causes the core to send out an\nAssert_INTx message, and de-asserting this signal causes the\ncore to transmit a Deassert_INTx message."
          },
          {
            "name": "INT_PEND_ST",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Legacy interrupt pending status\n1'b0: normal\n1'b1: pending\nWhen using legacy interrupts, this input is used to indicate the\ninterrupt pending status of the Physical Functions. The input i\nmust be set when an interrupt is pending in Function i."
          }
        ],
        "description": "Legacy interrupt control"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_ERR_CTRL",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CORR_ERR_CNT_EN",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable correctable error counter\n1'b0: disable counter\n1'b1: enable counter"
          },
          {
            "name": "NFATAL_ERR_CNT_EN",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable non-fatal error counter\n1'b0: disable counter\n1'b1: enable counter"
          },
          {
            "name": "FATAL_ERR_CNT_EN",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x0",
            "description": "Enable fatal error counter\n1'b0: disable counter\n1'b1: enable counter"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CORR_ERR_IN_EN",
            "bit_range": "1",
            "attr": "WO",
            "reset": "0x0",
            "description": "Assert a correctable error input to core\n1'b0: no error\n1'b1: write one to generate one pulse\nThe client may activate this input for one cycle to indicate a\ncorrectable error detected within the client logic that needs to be\nreported as an internal error through the PCI Express Advanced\nError Reporting mechanism. In response, the core sets the\nCorrected Internal Error Status bit in the AER Correctable Error\nStatus Register of all enabled Functions, and in EP mode also\nsends an error message if enabled to do so. This error is not\nconsidered Function-specific."
          },
          {
            "name": "UNCORR_ERR_IN_EN",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "Assert an uncorrectable error input to core\n1'b0: no error\n1'b1: write one to generate one pulse\nThe client may activate this input for one cycle to indicate an\nuncorrectable error detected within the client logic that needs to\nbe reported as an internal error through the PCI Express\nAdvanced Error Reporting mechanism. In response, the core sets\nthe Uncorrectable Internal Error Status bit in the AER\nUncorrectable Error Status Register of all enabled Functions, and\nin EP mode also sends an error message if enabled to do so. This\nerror is not considered Function-specific."
          }
        ],
        "description": "Error control register"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_ERR_CNT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "CORR_ERR_CNT",
            "bit_range": "23:16",
            "attr": "W1C",
            "reset": "0x00",
            "description": "Correctable error counter\nCorrectable error counter, write all one(8'hff) clear the counter."
          },
          {
            "name": "NFATAL_ERR_CNT",
            "bit_range": "15:8",
            "attr": "W1C",
            "reset": "0x00",
            "description": "Non-fatal error counter\nNon-fatal error counter, write all one(8'hff) clear the counter."
          },
          {
            "name": "FATAL_ERR_CNT",
            "bit_range": "7:0",
            "attr": "W1C",
            "reset": "0x00",
            "description": "Fatal error counter\nFatal error counter, write all one(8'hff) clear the counter."
          }
        ],
        "description": "Error counter"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_HOT_RESET_CTRL",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "WRITE_MASK",
            "bit_range": "17:16",
            "attr": "WO",
            "reset": "0x0",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LINK_DOWN_RST_CLT_MASK",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Mask link down reset client logic\n1'b0: disable link down reset client logic\n1'b1: enable link down reset client logic"
          },
          {
            "name": "HOT_RESET_IN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Assert hot reset to remote device\n0: de-assert\n1: assert\nWhen this input is asserted in the RC mode, the core initiates a\nHot Reset sequence on the PCIe link. This signal should be driven\nsynchronous to the CORE_CLK domain. The controller will keep\nthe\nPCIe link in hot reset till the time this signal is driven asserted.\nWhen de-asserted, controller will bring the PCIe link out of hot\nreset and initiate link training"
          }
        ],
        "description": "Hot reset control"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_SIDE_BAND_CTRL",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000004",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RX_STANDBY",
            "bit_range": "11:8",
            "attr": "RW",
            "reset": "0x0",
            "description": "PCIe phy receiver control\nControls whether the PHY RX is active when the PHY is in P0 or\nP0s states.\n1'b0: Active\n1'b1: Standby\nIn other modes not mentioned above, this signal is ignored. One\nbit for each lane."
          },
          {
            "name": "RESERVED",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "BYPASS_CODEC",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "PIPE bypass codec configuration\nControls whether the PHY performs 8b/10b encode and decode:\n1'b0: 8b/10b encode/decode performed normally\n1'b1: 8b/10b encode/decode bypassed\nData bus width is 20 bits, TxDataK and RxDataK interfaces are\nnot used, if encode/decode bypassed, and WIDTH_I shall be set\nhigh."
          },
          {
            "name": "TX_DEEMPHASIS_EXT",
            "bit_range": "5:4",
            "attr": "RW",
            "reset": "0x0",
            "description": "PIPE phy extended de-emphasis configuration, it combine with\nthe standard pipe de-emphasis."
          },
          {
            "name": "PWDN",
            "bit_range": "3:1",
            "attr": "RO",
            "reset": "0x2",
            "description": "Power state of the phy\nPower up or down the transceiver.\n3'b000: P0, normal operation\n3'b001: P0s, power saving state\n3'b010: P1, lower power state\n3'b011: P2, lowest power state, PLL not powered\n3'b111: L1SS.2, common mode off\nothers : L1SS.1, common mode on"
          },
          {
            "name": "NON_POSTED_REJ",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "PCIe target non posted reject\n1'b0: normal operation\n1'b1: reject non posted request\nThis is a single bit input signal which can be asserted by client\nlogic when it cannot service a non-posted request. The core will\nnot present any non-posted requests that it receives from the\nPCIe Link. It will hold them in the PNP FIFO RAM till the signal is\nde-asserted. If a non-posted TLP has already been queued from\nthe PNP FIFO and this signal is asserted, the core will place it on\nthe AXI bridge. The client logic must accept the non-posted TLP.\nThe in-flight non-posted TLPs in the core from the PNP FIFO\ncannot be stopped. However, non-posted TLPs that are in the PNP\nFIFO RAM when this signal is asserted or come in after the signal\nis asserted\nwill not be forwarded to the AXI interface. The client must assert\nthis signal when it still can process two or three non-posted TLPs.\nThis will allow posted TLPs to go past non-posted TLPs at the AXI\nmaster write interface due to client not being able to service non-\nposted TLPs."
          }
        ],
        "description": "Side band control configuration"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_SIDE_BAND_STATUS",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x000011f1",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PHY_ST",
            "bit_range": "12",
            "attr": "RO",
            "reset": "0x1",
            "description": "PIPE phy status\nIt indicates completion of several PHY functions including power\nmanagement state transition and receiver detection. When this\nsignal transitions during entry and exit from any PHY state where\nPCLK is not provided, then the signaling is asynchronous. When\nphy power up, \"0\" state can indicates pll locked"
          },
          {
            "name": "RESERVED",
            "bit_range": "11:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DATA_BUS_WIDTH",
            "bit_range": "9:8",
            "attr": "RO",
            "reset": "0x1",
            "description": "PIPE interface data bus width\nReports the width of the data bus that the PHY is configured for:\n1'b0: 32-bit mode\n1'b1: 16-bit mode\n0thers: reserved\nWhen bypass_codec is high, the interface is 20-bit and these two\nbits report a value of 2'b01."
          },
          {
            "name": "RX_STANDBY_ST",
            "bit_range": "7:4",
            "attr": "RO",
            "reset": "0xf",
            "description": "RX standby status\nIndicates PHY's RxStandby state\n1'b0: Active\n1'b1: Standby\nAlways high during P1/P2/L1SS state."
          },
          {
            "name": "RESERVED",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TX_DEEMPHASIS",
            "bit_range": "2:0",
            "attr": "RO",
            "reset": "0x1",
            "description": "PIPE phy de-emphasis status\nTransmitter de-emphasis selection, it combined by\ntx_deemphasis_ext,tx_deemphasis.\n3'b000: -6dB de-emphasis\n3'b001: -3.5dB de-emphasis\n3'b010: 0dB de-emphasis\n3'b011: -5.5dB de-emphasis\n3'b100: -6.5dB de-emphasis\n3'b101: -4dB de-emphasis\n3'b110: -1dB de-emphasis\n3'b111: -3dB de-emphasis"
          }
        ],
        "description": "Side band status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_FC_LEVEL_RST_DONE",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VF_FLR_DONE",
            "bit_range": "15:8",
            "attr": "WO",
            "reset": "0x00",
            "description": "Virtual function level reset done pulse generate\nThe client must assert bit i of this bus when it has completed the\nreset operation of Virtual Function i. This causes the core to de-\nassert FLR_IN_PROGRESS for VF i and to re-enable configuration\naccesses to the VF.\nWrite one to generate one high pulse."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FLR_DONE",
            "bit_range": "0",
            "attr": "WO",
            "reset": "0x0",
            "description": "Physical function level reset done pulse generate\nThe client must assert bit i of this bus when it has completed the\nreset operation of Function i. This causes the core to de-assert\nFLR_IN_PROGRESS for Function i and to re-enable configuration\naccesses to the Function.\nWrite one to generate one high pulse."
          }
        ],
        "description": "Generate function level reset done pulse"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_FLR_STATUS",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VF_FLR_IN_PROG",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x00",
            "description": "Virtual function level reset in progress\nThe core asserts bit i of this bus when the host initiates a reset of\nVirtual Function i though its FLR bit in the configuration space.\nThe core continues to maintain the output high until the client\nsets the FLR_DONE input for the corresponding VF to indicate the\ncompletion of the reset operation.\nOne bit for each function\n1'b0: normal\n1'b1: function level reset in progress"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FLR_IN_PROG",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Function level reset in progress\nThe core asserts bit i of this bus when the host initiates a reset of\nFunction i though its FLR bit in the configuration space. The core\ncontinues to maintain the output high until the client sets the\nFLR_DONE input for the corresponding Function to indicate the\ncompletion of the reset operation.\n1'b0: normal\n1'b1: function level reset in progress"
          }
        ],
        "description": "Function level reset status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_VF_STATUS",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VF_EN",
            "bit_range": "23:16",
            "attr": "RO",
            "reset": "0x00",
            "description": "Virtual function enable\nThe core sets bit i of this bus when the host has configured the\ncorresponding Virtual Function i. Client logic must check the state\nof this bit before initiating any request from the VF.\n1'b0: disable\n1'b1: enable\nOne bit for each function"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:8",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VF_BUS_MASTER_EN",
            "bit_range": "7:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Virtual function bus master enable\nBit i of this bus reflects the setting of the Bus Master Enable bit of\nthe PCI Command Register of Virtual Function i. Client logic must\ncheck the state of this bit before initiating any memory read or\nwrite transactions from the VF.\n1'b0: disable\n1'b1: enable\nOne bit for each function"
          }
        ],
        "description": "Virtual function status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_VF_PWR_STATUS",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "VF_PWR_ST",
            "bit_range": "23:0",
            "attr": "RO",
            "reset": "0x000000",
            "description": "Virtual function power status\nThese outputs provide the current power state of the Virtual\nFunctions. Bits [2:0] capture the power state of Virtual Function\n0 , bits [5:3] capture that of Virtual Function 1, and so on. The\npossible power states are:\n3'b000: D0_uninitialized\n3'b001: D0_active\n3'b010: D1\n3'b100: D3_hot"
          }
        ],
        "description": "Virtual function power status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_VF_TPH_STATUS",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "VF_TPH_REQR_EN",
            "bit_range": "31:24",
            "attr": "RO",
            "reset": "0x00",
            "description": "Virtual function TPH requester enable\nEach of the 16 bits of this output is driven the TPH Requester\nEnable bit [8] of the TPH Requester Control Register in the TPH\nRequester Capability Structure of the corresponding Virtual\nFunction.\nThese bits are active only in the Endpoint mode when SR-IOV is\nenabled. They indicate whether the software has enabled the\ndevice to generate requests with TPH Hints from the associated\nVirtual Function."
          },
          {
            "name": "VF_TPH_ST_MODE",
            "bit_range": "23:0",
            "attr": "RO",
            "reset": "0x000000",
            "description": "Virtual function TPH steering tag mode\nBits [2:0] of this output reflect the setting of the ST Mode Select\nbits in the TPH Requester Control Register of Virtual Function 0.\nBits [5:3] reflect the setting of the same register field of VF 1,\nand so on.\nThese bits are active only in the Endpoint mode. They indicate\nthe allowed modes for generation of TPH Hints by the\ncorresponding VF."
          }
        ],
        "description": "Virtual function TPH status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_TPH_STATUS",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:9",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TPH_REQR_EN",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "Physical function TPH requester enable\nBit 0 of this output is drives the TPH Requester Enable bit [8] of\nthe TPH Requester Control Register in the TPH Requester\nCapability Structure of the Physical Function 0.\nThese bits are active only in the Endpoint mode.\nThey indicate whether the software has enabled the device to\ngenerate requests with TPH Hints from the associated Physical\nFunction."
          },
          {
            "name": "RESERVED",
            "bit_range": "7:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "TPH_ST_MODE",
            "bit_range": "2:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Physical function TPH steering tag mode\nBits [2:0] of this output reflect the setting of the ST Mode Select\nbits in the TPH Requester Control Register of Physical Function 0.\nThese bits are active only in the Endpoint mode. They indicate\nthe allowed modes for generation of TPH Hints by the\ncorresponding Physical Function."
          }
        ],
        "description": "Physical TPH status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_DEBUG_OUT_0",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "DEBUG_DATA_OUT",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0000",
            "description": "Output data from the debug bus\n16-bit output data from the debug bus, described in Appendix A"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LTSSM_STATE",
            "bit_range": "5:0",
            "attr": "RO",
            "reset": "0x00",
            "description": "Link training and status state\nCurrent state of the Link Training and Status State\nMachine within the core. The encodings of this\noutput are described in Appendix B"
          }
        ],
        "description": "Debug information 0"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_DEBUG_OUT_1",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:18",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "PERF_DATA_OUT",
            "bit_range": "17:0",
            "attr": "RO",
            "reset": "0x00000",
            "description": "Performance data out\nEach of the bits of this vector is explained below:\nBit[17]:Pulse appears when event happens,described in Appendix\nB"
          }
        ],
        "description": "Debug information 1"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_BASIC_STATUS0",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000280",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:15",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MAX_PAYLOAD_SIZE",
            "bit_range": "14:12",
            "attr": "RO",
            "reset": "0x0",
            "description": "Max payload size\nThe maximum payload size field programmed in the PCI Express\nDevice Control Register. In multiple function cores, this output\nprovides the minimum of the max-payload-size field in the Device\nControl Registers of all the enabled Physical Functions.\nThe client logic must limit the size of Outgoing Completion\npayloads to this value. The 3-bit codes are the same as those\ndefined in PCIe Specifications:\n3'b000 = 128 bytes\n3'b001 = 256 bytes\n3'b010 = 512 bytes\n3'b011 = 1024 bytes\n3'b100 = 2048 bytes\n3'b101 = 4096 bytes"
          },
          {
            "name": "RESERVED",
            "bit_range": "11",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MAX_RDREQ_SIZE",
            "bit_range": "10:8",
            "attr": "RO",
            "reset": "0x2",
            "description": "Max read request size\nThe maximum request size field programmed in the PCI Express\nDevice Control Register. In multi?Function cores, this output\nprovides the minimum of the max-read-request field in the\nDevice Control Registers of all the Physical Functions. The client\nlogic must limit the size of outgoing read requests\nto this value. The 3-bit codes are the same as those defined in\nPCIe Specifications:\n3'b000 = 128 bytes\n3'b001 = 256 bytes\n3'b010 = 512 bytes\n3'b011 = 1024 bytes\n3'b100 = 2048 bytes\n3'b101 = 4096 bytes"
          },
          {
            "name": "NEGOTIATED_LINK_WIDTH",
            "bit_range": "7:6",
            "attr": "RO",
            "reset": "0x2",
            "description": "Negotiated link width\nCurrent link width are as follows:\n2'b10: x4\n2'b01: x2\n2'b00: x1\nothers: Reserved"
          },
          {
            "name": "NEGOTIATED_SPEED",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "Operation speed after negotiation\nCurrent operating speed of the link is as follows:\n1'b0: 2.5GT/s\n1'b1: 5GT/s"
          },
          {
            "name": "RESERVED",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "RCB_ST",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "Read completion boundary status\nProvides the setting of the Read Completion Boundary (RCB) bit\nin the Link Control Register of each Physical Function. In the\nEndpoint mode, bit 0 indicates the RCB for PF 0 and so on. In the\nRC mode,\nbit 0 indicates the RCB setting of the Link Control Register of the\nRC.\nFor each bit, a value of\n1'b0: indicates an RCB of 64 bytes\n1'b1: indicates 128 bytes"
          },
          {
            "name": "LTR_EN",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Latency tolerance reporting mechanism enable\nThe state of this output reflects the setting of the LTR Mechanism\nEnable bit in the Device Control 2 Register of Physical Function 0.\nWhen the core is configured as an Endpoint, client logic uses this\noutput to enable the generation of LTR messages.\nThis output is not to be used when the core is configured as a\nRoot Complex.\n1'b0: disable\n1'b1: enable"
          },
          {
            "name": "OBFF_EN",
            "bit_range": "1:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Optimized buffer flush and fill enable\nThis output reflects the setting of the OBFF Enable field in the\nDevice Control 2 Register\n2'b00: OBFF disabled,\n2'b01: OBFF enabled using message signaling, Variation A,\n2'b10: OBFF enabled using message signaling, Variation B,\n2'b11: OBFF enabled using WAKE# signaling."
          }
        ],
        "description": "Basic status 0"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_BASIC_STATUS1",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00080001",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:22",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LINK_ST",
            "bit_range": "21:20",
            "attr": "RO",
            "reset": "0x0",
            "description": "Link status\nStatus of the PCI Express link.\n2'b00 = No receivers detected.\n2'b01 = Link training in progress.\n2'b10 = Link up , DL initialization in progress.\n2'b11 = Link up, DL initialization completed."
          },
          {
            "name": "FC_ST",
            "bit_range": "19:16",
            "attr": "RO",
            "reset": "0x8",
            "description": "Function status\nThese outputs indicate the states of the Command Register bits\nin the PCI configuration space of each Function. These outputs\nare used to enable requests and completions from the host logic.\nThe assignment of bits is as follows:\nBit 0: Function 0 IO Space Enable\nBit 1: Function 0 Memory Space Enable\nBit 2: Function 0 Bus Master Enable\nBit 3: Function 0 INTx Disable\nand so on depending on the number of functions."
          },
          {
            "name": "SYS_PAGE_SIZE",
            "bit_range": "15:0",
            "attr": "RO",
            "reset": "0x0001",
            "description": "System page size\nThese bits reflect the setting of the System Page Size Register in\nthe SR IOV capability of each PF. Bits [15:0] reflect bits [15:0] of\nSystem Page Size register of PF0"
          }
        ],
        "description": "Basic status 1"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_INT_MASK",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x0000ffff",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "LEGACY_DONE_INT_MASK",
            "bit_range": "15",
            "attr": "RW",
            "reset": "0x1",
            "description": "Legacy interrupt send done interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "MSG_INT_MASK",
            "bit_range": "14",
            "attr": "RW",
            "reset": "0x1",
            "description": "Message receive done interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "HOT_RESET_INT_MASK",
            "bit_range": "13",
            "attr": "RW",
            "reset": "0x1",
            "description": "Hot reset interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "DPA_INT_MASK",
            "bit_range": "12",
            "attr": "RW",
            "reset": "0x1",
            "description": "DPA interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "FATAL_ERR_INT_MASK",
            "bit_range": "11",
            "attr": "RW",
            "reset": "0x1",
            "description": "Fatal error interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "NFATAL_ERR_INT_MASK",
            "bit_range": "10",
            "attr": "RW",
            "reset": "0x1",
            "description": "Non-fatal error interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "CORR_ERR_INT_MASK",
            "bit_range": "9",
            "attr": "RW",
            "reset": "0x1",
            "description": "Correctable error interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "INTD_MASK",
            "bit_range": "8",
            "attr": "RW",
            "reset": "0x1",
            "description": "INTD interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "INTC_MASK",
            "bit_range": "7",
            "attr": "RW",
            "reset": "0x1",
            "description": "INTC interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "INTB_MASK",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x1",
            "description": "INTB interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "INTA_MASK",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x1",
            "description": "INTA interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "LOCAL_INT_MASK",
            "bit_range": "4",
            "attr": "RW",
            "reset": "0x1",
            "description": "Local interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "UDMA_INT_MASK",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x1",
            "description": "uDMA interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "PHY_INT_MASK",
            "bit_range": "2",
            "attr": "RW",
            "reset": "0x1",
            "description": "Phy interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          },
          {
            "name": "HOT_PLUG_INT_MASK",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x1",
            "description": "Hot plug interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask\nreserved"
          },
          {
            "name": "PWR_STCG_INT_MASK",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x1",
            "description": "Power state change interrupt mask\n1'b0: interrupt enable\n1'b1: interrupt mask"
          }
        ],
        "description": "Interrupt mask"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_INT_STATUS",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:16",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "LEGACY_DONE_INT",
            "bit_range": "15",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Legacy interrupt send done interrupt\n1'b0: no interrupt\n1'b1: interrupt\nA pulse on this output indicates that the core has sent an INTx\nAssert or Deassert message in response to a change in the state\nof one of the int_in"
          },
          {
            "name": "MSG_INT",
            "bit_range": "14",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Message receive done interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen a message received done by Client message FIFO, an\ninterrupt will generate"
          },
          {
            "name": "HOT_RESET_INT",
            "bit_range": "13",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Hot reset interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen a hot reset send done interrupt generated in RC mode, it\nindicates that the Endpoint Device has also received the Hot\nReset, and then the hot_reset_in can be de-assert"
          },
          {
            "name": "DPA_INT",
            "bit_range": "12",
            "attr": "W1C",
            "reset": "0x0",
            "description": "DPA interrupt\n1'b0: no interrupt\n1'b1: interrupt\nThe core generates an interrupt when a Configuration Write\ntransaction writes into the Dynamic Power Allocation Control\nRegister to modify the DPA power state of the device. A interrupt\nindicates such a DPA event for PF 0, and so on. The local\nsoftware running on the End Point must read the DPA Control\nRegister of the corresponding Function to determine the DPA\nsubstate requested by the host and set the power state of the\ndevice accordingly"
          },
          {
            "name": "FATAL_ERR_INT",
            "bit_range": "11",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Fatal error interrupt\n1'b0: no interrupt\n1'b1: interrupt\nIn the EP mode, the core activates this output for one cycle when\nit has detected a fatal error and its reporting is not masked. In\nmulti-Function cores, this is the logical OR of the fatal error\nstatus bits in the Device Status Registers of all Functions.\nIn the RP mode, this output is activated on detection of a local\nfatal error, when its reporting is not masked. This signal also gets\nactivated in response to an error message received from the link\nif Fatal Error Reporting is enabled in the Root Error Command\nregister."
          },
          {
            "name": "NFATAL_ERR_INT",
            "bit_range": "10",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Non-fatal error interrupt\n1'b0: no interrupt\n1'b1: interrupt\nIn the EP mode, the core activates this output for one cycle when\nit has detected a non-fatal error and its reporting is not masked.\nIn multi-Function cores, this is the logical OR of the non-fatal\nerror status bits in the Device Status Registers of all Functions.\nIn the RC mode, this output is activated on detection of a local\nfatal error, when its reporting is not masked. This signal also gets\nactivated in response to an error message received from the link\nif Fatal Error Reporting is enabled in the Root Error Command\nregister."
          },
          {
            "name": "CORR_ERR_INT",
            "bit_range": "9",
            "attr": "W1C",
            "reset": "0x0",
            "description": "Correctable error interrupt\n1'b0: no interrupt\n1'b1: interrupt\nIn the EP mode, the core activates this output for one cycle when\nit has detected a correctable error and its reporting is not\nmasked. In multi-Function cores, this is the logical OR of the\ncorrectable error status bits in the Device Status Registers of all\nFunctions.\nIn the RC mode, this output is activated on detection of a local\ncorrectable error, when its reporting is not masked. This signal\nalso gets activated in response to an error message received\nfrom the link if Correctable Error Reporting is enabled in the Root\nError Command register."
          },
          {
            "name": "INTD",
            "bit_range": "8",
            "attr": "RO",
            "reset": "0x0",
            "description": "INTD interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen the core is configured as RC, this interrupt emulate the PCI\nlegacy interrupts INTD. The core asserts an interrupt output\nwhen it has received an Assert_INTD message from the link, and\ndeasserts it when it receives a Deassert_INTD message."
          },
          {
            "name": "INTC",
            "bit_range": "7",
            "attr": "RO",
            "reset": "0x0",
            "description": "INTC interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen the core is configured as RC, this interrupt emulate the PCI\nlegacy interrupts INTC. The core asserts an interrupt output when\nit has received an Assert_INTC message from the link, and\ndeasserts it when it receives a Deassert_INTC message."
          },
          {
            "name": "INTB",
            "bit_range": "6",
            "attr": "RO",
            "reset": "0x0",
            "description": "INTB interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen the core is configured as RC, this interrupt emulate the PCI\nlegacy interrupts INTB. The core asserts an interrupt output when\nit has received an Assert_INTB message from the link, and\ndeasserts it when it receives a Deassert_INTB message."
          },
          {
            "name": "INTA",
            "bit_range": "5",
            "attr": "RO",
            "reset": "0x0",
            "description": "INTA interrupt\n1'b0: no interrupt\n1'b1: interrupt\nWhen the core is configured as RC, this interrupt emulate the PCI\nlegacy interrupts INTA. The core asserts an interrupt output when\nit has received an Assert_INTA message from the link, and\ndeasserts it when it receives a Deassert_INTA message."
          },
          {
            "name": "LOCAL_INT",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "Local interrupt\n1'b0: no interrupt\n1'b1: interrupt\nLocal Error and Status Register Interrupt. This is a level interrupt\ntill cleared by software\nDetail information refers to Local Error and Status Register\ndescription in PCIe Core register section \"Local Management\nRegisters\""
          },
          {
            "name": "UDMA_INT",
            "bit_range": "3",
            "attr": "RO",
            "reset": "0x0",
            "description": "uDMA interrupt\n1'b0: no interrupt\n1'b1: interrupt\nDMA Interrupt to the system processor. Will be asserted on a\n\"DMA Done\" or a \"DMA Error\" event"
          },
          {
            "name": "PHY_INT",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Phy interrupt\n1'b0: no interrupt\n1'b1: interrupt\nThis interrupt is used by the core in the RP mode to signal one of\nthe following link training-related events:\n1. The link bandwidth changed as a result of the change in the\nlink width or operating speed and the change was initiated locally\n(not by the link partner), without the link going down. This\ninterrupt is enabled by the Link Bandwidth Management Interrupt\nEnable bit in the Link Control Register. The status of this interrupt\ncan be read from the Link Bandwidth Management Status bit of\nthe Link Status Register.\n2. The link bandwidth changed autonomously as a result of the\nchange in the link width or operating speed and the change was\ninitiated by the remote node. This interrupt is enabled by the Link\nAutonomous Bandwidth Interrupt Enable bit in the Link Control\nRegister. The status of this interrupt can be read from the Link\nAutonomous Bandwidth Status bit of the Link Status Register.\nThe phy interrupt is not active when the core is configured as an\nEndPoint."
          },
          {
            "name": "HOT_PLUG_INT",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Hot plug interrupt\n1'b0: no interrupt\n1'b1: interrupt\nHot Plug Interrupt Output for Software Notification of Hot Plug\nevents.\nCurrently, this interrupt reserved"
          },
          {
            "name": "PWR_STCG_INT",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Power state change interrupt\n1'b0: no interrupt\n1'b1: interrupt\nThe core asserts this output when the power state of a Physical\nor Virtual Function is being changed to the D1 or D3 states by a\nwrite into its Power Management Control Register. The core\nmaintains this output high until the client asserts the\npwr_stcg_ack input to the core. While interrupt remains high, the\ncore will not return completions for any pending configuration\nread or write transaction received by the core. The intent is to\ndelay the completion for the configuration write transaction that\ncaused the state change until the client is ready to transition to\nthe low- power state. When interrupt is asserted, the Function\nnumber associated with the configuration write transaction is\nprovided on the pwr_stcg_fc_num.\nWhen the client asserts pwr_stcg_ack, the new state of the\nFunction that underwent the state change will be reflected on the\nfc_pwr_st (for PFs) or the vf_pwr_st (for VFs) outputs of the\ncore."
          }
        ],
        "description": "Interrupt status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_CTRL",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "WRITE_MASK",
            "bit_range": "31:16",
            "attr": "WO",
            "reset": "0x0000",
            "description": "Write mask\nFor each served bit\n1'b0: write mask\n1'b1: write enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "15:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ALMFULL_WATER_MARK",
            "bit_range": "12:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Almost full water mark\nalmost full water mark configuration"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:2",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "MSG_FIFO_RX_MODE",
            "bit_range": "1",
            "attr": "RW",
            "reset": "0x0",
            "description": "Message fifo receive mode select\n1'b0: partial mode\n1'b1: full mode"
          },
          {
            "name": "MSG_FIFO_EN",
            "bit_range": "0",
            "attr": "RW",
            "reset": "0x0",
            "description": "Message fifo receive enable\n1'b0: disable message receive\n1'b1: enable client message receive"
          }
        ],
        "description": "Message receive control register"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_STATUS",
        "offset": "0x0058",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:13",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "SPACE2EMPTY",
            "bit_range": "12:8",
            "attr": "RO",
            "reset": "0x00",
            "description": "Space to empty\nData length before empty"
          },
          {
            "name": "RESERVED",
            "bit_range": "7:3",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "FIFO_FULL",
            "bit_range": "2",
            "attr": "RO",
            "reset": "0x0",
            "description": "Message fifo full\n1'b0: non-full\n1'b1: fifo full"
          },
          {
            "name": "FIFO_EMPTY",
            "bit_range": "1",
            "attr": "RO",
            "reset": "0x0",
            "description": "Message fifo empty\n1'b0: non-full empty\n1'b1: fifo_empty"
          },
          {
            "name": "ALMOST_FULL",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "Message fifo almost full flag\n1'b0: non-almost full\n1'b1: almost full"
          }
        ],
        "description": "Message control status"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_CODE0",
        "offset": "0x005c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "MTPAT4",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 4\nPattern4"
          },
          {
            "name": "MTPAT3",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 3\nPattern3"
          },
          {
            "name": "MTPAT2",
            "bit_range": "15:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 2\nPattern2"
          },
          {
            "name": "MTPAT1",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 1\nPattern 1"
          }
        ],
        "description": "Message code 0"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_CODE1",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "MTPAT8",
            "bit_range": "31:24",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 8\nPattern8"
          },
          {
            "name": "MTPAT7",
            "bit_range": "23:16",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 7\nPattern7"
          },
          {
            "name": "MTPAT6",
            "bit_range": "15:8",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 6\nPattern6"
          },
          {
            "name": "MTPAT5",
            "bit_range": "7:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "Match pattern 5\nPattern5"
          }
        ],
        "description": "Message code 1"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_DATA_LEN",
        "offset": "0x0064",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "LENGTH4",
            "bit_range": "31:24",
            "attr": "RC",
            "reset": "0x00",
            "description": "Length4\nLength4, record the 4th recently received message length."
          },
          {
            "name": "LENGTH3",
            "bit_range": "23:16",
            "attr": "RC",
            "reset": "0x00",
            "description": "Length3\nLength3, record the 3rd recently received message length."
          },
          {
            "name": "LENGTH2",
            "bit_range": "15:8",
            "attr": "RC",
            "reset": "0x00",
            "description": "Length2\nLength2, record the 2nd recently received message length."
          },
          {
            "name": "LENGTH1",
            "bit_range": "7:0",
            "attr": "RC",
            "reset": "0x00",
            "description": "Length1\nLength1, record the recently received message length."
          }
        ],
        "description": "Message data length"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_MSG_FIFO_RD_DATA",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RD_DATA",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x00000000",
            "description": "Message fifo read data\nMessage fifo read data"
          }
        ],
        "description": "Message fifo read data"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_CONF_NU0",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Configuration no used"
      },
      {
        "type": "register",
        "name": "PCIE_CLIENT_CONF_NU1",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:0",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          }
        ],
        "description": "Configuration no used"
      }
    ],
    "name": "PCIE",
    "summary": [
      {
        "name": "PCIE_CLIENT_BASIC_STRAP_CONF",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x000000c1",
        "description": "Basic strap configuration register"
      },
      {
        "name": "PCIE_CLIENT_POWER_CTRL",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "PCIe client power control configuration"
      },
      {
        "name": "PCIE_CLIENT_POWER_STATUS",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "PCIe power management status"
      },
      {
        "name": "PCIE_CLIENT_LEGACY_INT_CTRL",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Legacy interrupt control"
      },
      {
        "name": "PCIE_CLIENT_ERR_CTRL",
        "offset": "0x0010",
        "size": "W",
        "reset": "0x00000000",
        "description": "Error control register"
      },
      {
        "name": "PCIE_CLIENT_ERR_CNT",
        "offset": "0x0014",
        "size": "W",
        "reset": "0x00000000",
        "description": "Error counter"
      },
      {
        "name": "PCIE_CLIENT_HOT_RESET_CTRL",
        "offset": "0x0018",
        "size": "W",
        "reset": "0x00000000",
        "description": "Hot reset control"
      },
      {
        "name": "PCIE_CLIENT_SIDE_BAND_CTRL",
        "offset": "0x001c",
        "size": "W",
        "reset": "0x00000004",
        "description": "Side band control configuration"
      },
      {
        "name": "PCIE_CLIENT_SIDE_BAND_STATUS",
        "offset": "0x0020",
        "size": "W",
        "reset": "0x000011f1",
        "description": "Side band status"
      },
      {
        "name": "PCIE_CLIENT_FC_LEVEL_RST_DONE",
        "offset": "0x0024",
        "size": "W",
        "reset": "0x00000000",
        "description": "Generate function level reset done pulse"
      },
      {
        "name": "PCIE_CLIENT_FLR_STATUS",
        "offset": "0x0028",
        "size": "W",
        "reset": "0x00000000",
        "description": "Function level reset status"
      },
      {
        "name": "PCIE_CLIENT_VF_STATUS",
        "offset": "0x002c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Virtual function status"
      },
      {
        "name": "PCIE_CLIENT_VF_PWR_STATUS",
        "offset": "0x0030",
        "size": "W",
        "reset": "0x00000000",
        "description": "Virtual function power status"
      },
      {
        "name": "PCIE_CLIENT_VF_TPH_STATUS",
        "offset": "0x0034",
        "size": "W",
        "reset": "0x00000000",
        "description": "Virtual function TPH status"
      },
      {
        "name": "PCIE_CLIENT_TPH_STATUS",
        "offset": "0x0038",
        "size": "W",
        "reset": "0x00000000",
        "description": "Physical TPH status"
      },
      {
        "name": "PCIE_CLIENT_DEBUG_OUT_0",
        "offset": "0x003c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Debug information 0"
      },
      {
        "name": "PCIE_CLIENT_DEBUG_OUT_1",
        "offset": "0x0040",
        "size": "W",
        "reset": "0x00000000",
        "description": "Debug information 1"
      },
      {
        "name": "PCIE_CLIENT_BASIC_STATUS0",
        "offset": "0x0044",
        "size": "W",
        "reset": "0x00000280",
        "description": "Basic status 0"
      },
      {
        "name": "PCIE_CLIENT_BASIC_STATUS1",
        "offset": "0x0048",
        "size": "W",
        "reset": "0x00080001",
        "description": "Basic status 1"
      },
      {
        "name": "PCIE_CLIENT_INT_MASK",
        "offset": "0x004c",
        "size": "W",
        "reset": "0x0000ffff",
        "description": "Interrupt mask"
      },
      {
        "name": "PCIE_CLIENT_INT_STATUS",
        "offset": "0x0050",
        "size": "W",
        "reset": "0x00000000",
        "description": "Interrupt status"
      },
      {
        "name": "PCIE_CLIENT_MSG_CTRL",
        "offset": "0x0054",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message receive control register"
      },
      {
        "name": "PCIE_CLIENT_MSG_STATUS",
        "offset": "0x0058",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message control status"
      },
      {
        "name": "PCIE_CLIENT_MSG_CODE0",
        "offset": "0x005c",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message code 0"
      },
      {
        "name": "PCIE_CLIENT_MSG_CODE1",
        "offset": "0x0060",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message code 1"
      },
      {
        "name": "PCIE_CLIENT_MSG_DATA_LEN",
        "offset": "0x0064",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message data length"
      },
      {
        "name": "PCIE_CLIENT_MSG_FIFO_RD_DATA",
        "offset": "0x0100",
        "size": "W",
        "reset": "0x00000000",
        "description": "Message fifo read data"
      },
      {
        "name": "PCIE_CLIENT_CONF_NU0",
        "offset": "0x0200",
        "size": "W",
        "reset": "0x00000000",
        "description": "Configuration no used"
      },
      {
        "name": "PCIE_CLIENT_CONF_NU1",
        "offset": "0x0204",
        "size": "W",
        "reset": "0x00000000",
        "description": "Configuration no used"
      }
    ]
  },
  {
    "type": "group",
    "registers": [
      {
        "type": "register",
        "name": "SARADC_DATA",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:10",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADC_DATA",
            "bit_range": "9:0",
            "attr": "RO",
            "reset": "0x000",
            "description": "A/D value of the last conversion (DOUT[9:0])."
          }
        ],
        "description": "This register contains the data after A/D Conversion."
      },
      {
        "type": "register",
        "name": "SARADC_STAS",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:1",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADC_STATUS",
            "bit_range": "0",
            "attr": "RO",
            "reset": "0x0",
            "description": "ADC status (EOC)\n0: ADC stop\n1: Conversion in progress"
          }
        ],
        "description": "The status register of A/D Converter."
      },
      {
        "type": "register",
        "name": "SARADC_CTRL",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:7",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "INT_STATUS",
            "bit_range": "6",
            "attr": "RW",
            "reset": "0x0",
            "description": "Interrupt status.\nThis bit will be set to 1 when end-of-conversion.\nSet 0 to clear the interrupt."
          },
          {
            "name": "INT_EN",
            "bit_range": "5",
            "attr": "RW",
            "reset": "0x0",
            "description": "Interrupt enable.\n0: Disable\n1: Enable"
          },
          {
            "name": "RESERVED",
            "bit_range": "4",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "ADC_POWER_CTRL",
            "bit_range": "3",
            "attr": "RW",
            "reset": "0x0",
            "description": "ADC power down control bit\n0: ADC power down;\n1: ADC power up and reset.\nstart signal will be asserted (DLY_PU_SOC + 2) sclk clock period\nlater after power up"
          },
          {
            "name": "ADC_INPUT_SRC_SEL",
            "bit_range": "2:0",
            "attr": "RW",
            "reset": "0x0",
            "description": "ADC input source selection(CH_SEL[2:0]).\n000 : Input source 0 (SARADC_AIN[0])\n001 : Input source 1 (SARADC_AIN[1])\n010 : Input source 2 (SARADC_AIN[2])\n011 : Input source 3 (SARADC_AIN[3])\n100 : Input source 4 (SARADC_AIN[4])\n101 : Input source 5 (SARADC_AIN[5])\nOthers : Reserved"
          }
        ],
        "description": "The control register of A/D Converter."
      },
      {
        "type": "register",
        "name": "SARADC_DLY_PU_SOC",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "bit_ranges": [
          {
            "name": "RESERVED",
            "bit_range": "31:6",
            "attr": "RO",
            "reset": "0x0",
            "description": "reserved"
          },
          {
            "name": "DLY_PU_SOC",
            "bit_range": "5:0",
            "attr": "RW",
            "reset": "0x00",
            "description": "delay between power up and start command\nThe start signal will be asserted (DLY_PU_SOC + 2) sclk clock\nperiod later after power up"
          }
        ],
        "description": "delay between power up and start command"
      }
    ],
    "name": "SARADC",
    "summary": [
      {
        "name": "SARADC_DATA",
        "offset": "0x0000",
        "size": "W",
        "reset": "0x00000000",
        "description": "This register contains the data after A/D Conversion."
      },
      {
        "name": "SARADC_STAS",
        "offset": "0x0004",
        "size": "W",
        "reset": "0x00000000",
        "description": "The status register of A/D Converter."
      },
      {
        "name": "SARADC_CTRL",
        "offset": "0x0008",
        "size": "W",
        "reset": "0x00000000",
        "description": "The control register of A/D Converter."
      },
      {
        "name": "SARADC_DLY_PU_SOC",
        "offset": "0x000c",
        "size": "W",
        "reset": "0x00000000",
        "description": "delay between power up and start command"
      }
    ]
  }
]